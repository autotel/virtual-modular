//TODO: separate .cpp and .h
#include "FastLED.h"
#include "_name_signals.h"
#define REFRESHRATE 20
#ifndef HARDWAREH
#define HARDWAREH
//useful about callback functions https://stackoverflow.com/questions/14427917/call-function-in-main-program-from-a-library-in-arduino
//hardware controlling functions for physical modular rev 1 board
class LedButtons {
  public:
    LedButtons() {

    };
#define NUM_LEDS 28
#define NUM_BUTTONS 28
#define DATA_PIN 43
    CRGB leds[NUM_LEDS];


    char lcdStr[33];
    void setup() {
      delay(1000);

      FastLED.addLeds<WS2811, DATA_PIN, RGB>(leds, NUM_LEDS);
      LEDS.setBrightness(110);


      for (uint8_t a = 0; a < 33; a++) {
        lcdStr[a] = 0;
      }
      //encoder pins setup
      DDRA = 0x00; //0x3<<6
      PORTA |= 3 << 6;

    }
    void loop() {
      readMatrixButtons();
      doEncoderButton();
      if (millis() - lastLedsUpdate > 1000 / REFRESHRATE) {
        refreshLeds();
        lastLedsUpdate = millis();
      }
    }
    uint16_t lastEncoderPressTimer = 0;
    uint16_t debounceTime = 250;
    void doEncoderButton() {
      //not working
      //set MUXBX0 low MUXAX4 to high;
      PORTK &= ~(0x1 << 0);
      PORTH |= 0x1 << 7;
      if ((PINH >> 7) & 1) {
        if (lastEncoderPressTimer >= debounceTime) {
          encoderPressedCallback();
          lastEncoderPressTimer = 0;
        }
      } else {
        if (lastEncoderPressTimer <= debounceTime) {
          lastEncoderPressTimer++;
        }
      }
    }
#define divideEncoderRotation 4
    const uint8_t grayToBinary = 0b10110100;
    int8_t enc_last = 0;
    int8_t enc_sub = 0;
    unsigned int encoder0Pos = 0;
    char sign(char x) {
      return (x > 0) - (x < 0);
    }

    void doEncoder() {
      //encread turns around as follows: <- 0,1,3,2 ->
      //upon conversion it will turn as: <- 0,1,2,3 ->
      int8_t enc_read = (grayToBinary >> ( ( (PINA >> 6) & 0x3) * 2 ) ) & 0x3;
      if (enc_read != enc_last) {
        int8_t enc_inc = enc_read - enc_last;

        if (enc_inc > 2) {
          enc_inc = -1;
        }
        if (enc_inc < -2) {
          enc_inc = +1;
        }

        enc_sub += enc_inc;
        if (abs(enc_sub) >= divideEncoderRotation) {
          encoder0Pos += sign(enc_sub);
          enc_sub = 0;
          encoderRotatedCallback(encoder0Pos);
        }
        enc_last = enc_read;
      }
    }
    int readMatrixButtons() {
      uint16_t i, j, currentButton;
      //POX = pin out register n., PIN= pin in register n.
      //H, columns
#define POX PORTH //bits 3-7, digital
#define PIX PINH
#define PORTXMASK 0b00000111
      DDRH = 0xFF;
      //K, rows
#define POY PORTK //bits 0-6, analog
#define PIY PINK
      //#define YREGMASK 0b00111111
      DDRK = 0x00;
      POY = 0xFF;
      // int inpinbase = 8;

      for (currentButton = 0; currentButton < NUM_LEDS; currentButton++) {
        uint16_t col = currentButton % 4;
        uint16_t row = currentButton / 4;

        POX &= PORTXMASK;

        //not 1<< because starts in PH3
        POX = ~(0b1000 << col);
        //set test to a mask according to the row we want to check
        uint32_t test = 1UL << row;
        //TODO: there should be a juggling of the scan with the rest of the code ranther than a delay.
        //delay is to avoid leaks of voltage due to capacitances?
        delayMicroseconds(100);

        uint32_t an = PIY & test;

        //we checked the row, now we want to use the test to compare with the pixel number.
        //I am recycling the variable
        test = 1UL << currentButton;
        //check button is pressed, but in inverted logic
        if (!an) {
          //button is pressed, and not the last time
          if (!(test & pressedButtonsBitmap)) {

            pressedButtonsBitmap = pressedButtonsBitmap | test;
            CB_buttonPressed(currentButton, pressedButtonsBitmap);
          }

        } else {
          //button is depressed, and was pressed last time
          if (test & pressedButtonsBitmap) {

            pressedButtonsBitmap = pressedButtonsBitmap & (~test);
            CB_buttonReleased(currentButton);
          }
        }

      }

    }
    void refreshLeds() {
      //uint16_t a;
      /*for (a = 0; a < strip.numPixels(); a++) {
        strip.setPixelColor(a, strip.Color(ledColors[a], ledColors[a], ledColors[a])); //Wheel((i*1+j)
        }*/
      FastLED.show();
    }
    void lcdPulseEnable
    void writeLcd() {
      //PL0-PL5
      DDRD = 0xFF >> 2;

      //rs<<0, enable<<1, d0<<2, d1<<3, d2<<4, d3<<5

      //d3,d2,d1,d0,enable,rs

    }

    void setButtonCallbacks( void (*fpa)(byte, uint32_t), void (*fpb)(byte) ) {
      CB_buttonPressed = fpa;
      CB_buttonReleased = fpb;
    }
    void setEncoderCallbacks(void (*fpa)(int8_t), void (*fpb)(), void (*fpc)()) {
      CB_encoderRotated = fpa;
      CB_encoderPressed = fpb;
      CB_encoderReleased = fpc;
    };
    void setButtonColor(uint16_t button, uint8_t a, uint8_t b, uint8_t c ) {
      if (a | b | c > 0) {
        //c |= 80;
        leds[button] = CRGB(a, b, c);//CHSV
      } else {
        leds[button] = CRGB::Black;
      }
    }
    void setButtonColorHSV(uint16_t button, uint8_t a, uint8_t b, uint8_t c ) {
      if ( c > 0) {
        //c |= 80;
        leds[button] = CHSV(a, b, c);//CHSV
      } else {
        leds[button] = CRGB::Black;
      }
    }
  private:
    long lastLedsUpdate = 0;
    uint8_t lcdChange = 0;
    void (*CB_buttonPressed)(byte, uint32_t) = 0;
    void (*CB_buttonReleased)(byte) = 0;
    void (*CB_encoderRotated)(int8_t) = 0;
    void (*CB_encoderPressed)() = 0;
    void (*CB_encoderReleased)() = 0;
    uint32_t pressedButtonsBitmap = 0;
    void buttonPressedCallback(byte button, uint32_t bitmap) {
      if ( 0 != CB_buttonPressed ) {
        (*CB_buttonPressed)(button, bitmap);
      }
      else {
        for (uint16_t a = 0; a < NUM_LEDS; a++) {
          leds[button] = CRGB(a, a, a);
          // strip.setPixelColor(a, Wheel(a * 12)); //Wheel((i*1+j)
        }
      }
    }
    void buttonReleasedCallback(byte button) {
      if ( 0 != CB_buttonReleased ) {
        (*CB_buttonReleased)(button);
      }
      else {
      }
    }
    void encoderRotatedCallback(byte delta) {
      if ( 0 != CB_encoderRotated ) {
        (*CB_encoderRotated)(delta);
      }
      else {
      }
    }
    void encoderPressedCallback() {
      if ( 0 != CB_encoderPressed ) {
        (*CB_encoderPressed)();
      }
      else {
      }
    }
    void encoderReleasedCallback() {
      if ( 0 != CB_encoderReleased ) {
        (*CB_encoderReleased)();
      }
      else {
      }
    }
};

#endif
