this["environment"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/browser-process-hrtime/index.js":
/*!******************************************************!*\
  !*** ./node_modules/browser-process-hrtime/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = process.hrtime || hrtime\n\n// polyfil for window.performance.now\nvar performance = global.performance || {}\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3\n  var seconds = Math.floor(clocktime)\n  var nanoseconds = Math.floor((clocktime%1)*1e9)\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0]\n    nanoseconds = nanoseconds - previousTimestamp[1]\n    if (nanoseconds<0) {\n      seconds--\n      nanoseconds += 1e9\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\n//# sourceURL=webpack://environment/./node_modules/browser-process-hrtime/index.js?");

/***/ }),

/***/ "./node_modules/fifo/index.js":
/*!************************************!*\
  !*** ./node_modules/fifo/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Node (list, val) {\n  this.prev = this.next = this\n  this.value = val\n  this.list = list\n}\n\nNode.prototype.link = function (next) {\n  this.next = next\n  next.prev = this\n  return next\n}\n\nfunction FIFO () {\n  if (!(this instanceof FIFO)) return new FIFO()\n  this.node = null\n  this.length = 0\n}\n\nFIFO.prototype.set = function (node, value) {\n  if (!node || node.list !== this) return null\n  node.value = value\n  return node\n}\n\nFIFO.prototype.next = function (node) {\n  if (!node) return this.node\n  return node.next === this.node ? null : node.next\n}\n\nFIFO.prototype.prev = function (node) {\n  if (!node) return this.node\n  return node === this.node ? null : node.prev\n}\n\nFIFO.prototype.get = function (node) {\n  if (!node || node.list !== this) return null\n  return node.value\n}\n\nFIFO.prototype.remove = function (node) {\n  if (!node || node.list !== this) return null\n  this.length--\n  node.list = null\n  node.prev.link(node.next)\n  if (node === this.node) this.node = node.next === node ? null : node.next\n  return node.link(node).value\n}\n\nFIFO.prototype.unshift = function (value) {\n  return this.node = this.push(value)\n}\n\nFIFO.prototype.push = function (value) {\n  return this.add(new Node(this, value))\n}\n\nFIFO.prototype.bump = function (node) {\n  if (node.list !== this) return false\n  this.remove(node)\n  this.add(node)\n  return true\n}\n\nFIFO.prototype.add = function (node) {\n  this.length++\n  if (!node.list) node.list = this\n  if (!this.node) return this.node = node\n  this.node.prev.link(node)\n  node.link(this.node)\n  return node\n}\n\nFIFO.prototype.first = function () {\n  return this.node && this.node.value\n}\n\nFIFO.prototype.last = function () {\n  return this.node && this.node.prev.value\n}\n\nFIFO.prototype.shift = function () {\n  return this.node && this.remove(this.node)\n}\n\nFIFO.prototype.pop = function () {\n  return this.node && this.remove(this.node.prev)\n}\n\nFIFO.prototype.isEmpty = function () {\n  return this.length === 0 || this.node === null\n}\n\nFIFO.prototype.removeAll =\nFIFO.prototype.clear = function () {\n  if (this.length !== 0 && this.node !== null) {\n    this.length = 0\n    this.node = null\n  }\n}\n\nFIFO.prototype.forEach = function (fn) {\n  for (var node = this.node; node; node = this.next(node)) {\n    fn(node.value, node)\n  }\n}\n\nFIFO.prototype.toArray = function () {\n  var list = []\n  for (var node = this.node; node; node = this.next(node)) {\n    list.push(node.value)\n  }\n  return list\n}\n\nmodule.exports = FIFO\n\n\n//# sourceURL=webpack://environment/./node_modules/fifo/index.js?");

/***/ }),

/***/ "./node_modules/onhandlers/on.js":
/*!***************************************!*\
  !*** ./node_modules/onhandlers/on.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\nyou make the onHandlers.call(this) in the object that needs to have handlers.\r\nthen you can create a function callback for that object using object.on(\"handlerName.optionalName\",callbackFunction(){});\r\nthe object can run the handle callbacks by using this.handle(\"handlerName\",parametersToFeed);\r\n*/\r\nvar OnHandlers=function() {\r\n  var eventVerbose=false;\r\n  var self=this;\r\n  var CallbackObject=function(callback){\r\n    this.callback=callback;\r\n  }\r\n  if (!this.ons) {\r\n    this.ons = [];\r\n  }\r\n  this.on = function(name, callback) {\r\n    var name = name.split(\" \");\r\n    if (typeof callback === 'function') {\r\n      if (name.length == 0) {\r\n        throw (\"sorry, you gave an invalid event name\");\r\n        return false;\r\n      } else if (name.length > 0) {\r\n        var unique=new CallbackObject(callback);\r\n        for(var evtName of name){\r\n          if (!self.ons[evtName]) self.ons[evtName] = [];\r\n          self.ons[evtName].push(unique);\r\n        }\r\n        return unique;\r\n      }\r\n    } else {\r\n      throw (\"error at mouse.on, provided callback that is not a function\");\r\n      return false;\r\n    }\r\n  }\r\n  this.off = function(name) {\r\n    if (typeof name == \"string\") {\r\n      var nameList=name.split(\" \");\r\n      for(var name of nameList){\r\n        this.ons[name] = [];\r\n      }\r\n    } else if (name instanceof CallbackObject) {\r\n      //console.log(\"off by ref\");\r\n      for(var evtListNameItem in self.ons){\r\n        //console.log(evtListNameItem)\r\n        for(var evtNum in self.ons[evtListNameItem]){\r\n          //console.log(evtNum);\r\n          if(name===self.ons[evtListNameItem][evtNum]) self.ons[evtListNameItem].splice(evtNum,1);\r\n        }\r\n      }\r\n    } else {\r\n      throw (\"sorry, you gave an invalid listener reference: \",name);\r\n    }\r\n  }\r\n  this.handle = function(fname, params) {\r\n    if(eventVerbose) console.log(\"Event \"+fname+\":\",{caller:this,params:params});\r\n    if (self.ons[fname]) {\r\n      for (var n in self.ons[fname]) {\r\n        // console.log(self.ons[fname][n][1]);\r\n        self.ons[fname][n].callback(params);\r\n      }\r\n    }\r\n  }\r\n};\r\nmodule.exports=OnHandlers;\r\n\n\n//# sourceURL=webpack://environment/./node_modules/onhandlers/on.js?");

/***/ }),

/***/ "./src/datatypes/EventMessage.js":
/*!***************************************!*\
  !*** ./src/datatypes/EventMessage.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n@example ` myOutput.receive(new EventMessage([0x01,0x40,0x30])) `\r\n*/\r\nvar EventMessage=function(inputValue){\r\n  var thisEm = this;\r\n  var self = this;\r\n  this.isEventMessage=true;\r\n  /**\r\n  value of the EventMessage\r\n\r\n  [0]=function header, indicates the receiving module what function to perform with the following data\r\n\r\n  [1]=main event number, indicates information such as what note to play, what cc to change, or what event to trigger.\r\n\r\n  [2]=submode/ voice specification (channel), indicates a variation of the mode or what voice to play. Sometimes unused\r\n\r\n  [3 ... ]= more data, depending on the particular function of the receiver following data may make sense or not.\r\n\r\n  all the efforts are done to avoid it's value to be a reference. to simulate modular elements, the EventMessages must have their own copy of the data, otherwise it could happen that a module edits an EventMessage that has been received by other. This is why to modify the .value of EventMessage, you can opt for\r\n  * set a single index of the value `myEventMessage.value[2]=0x44`\r\n  * or use the set function `myEventMessage.set({value:[0x44,0x44,0x44]});\r\n  */\r\n\r\n  this.value=[];\r\n  /**\r\n  valuenames is correlated to values array, and is used to have friendlier names to a certain EventMessage. It helps make these more readable; however you must avoid referencing to values using the names because that doesn't ensure compatibility with modules that may name values differently, and also it is slower in execution.\r\n  @example myEventMessage.print();\r\n  */\r\n  this.valueNames=[];\r\n  /**print to the console it's values with index and names (if applicable)*/\r\n  this.print=function(){\r\n    console.log(\"EventMessage { \");\r\n    for(var a in this.value){\r\n      var str=\"[\"+a+\"]\";\r\n      if(this.valueNames[a]) str+=\"(\"+valueNames[a]+\") \";\r\n      str+=\": \"+ this.value[a];\r\n      console.log(\" \"+str);\r\n    }\r\n    console.log(\"}\");\r\n  }\r\n  /**\r\n  set parameters of the EventMessage Data contains properties to set.\r\n  @example myEventMessage.set({value:[0x44,0x44,0x44],note:\"example event message\"});\r\n\r\n  the only standard property that can be set is the value, other properties such as the exaple \"note\" are not standard, avoid using non-standard parameters unless it excplusively within the same module that is using it\r\n  */\r\n  this.set=function(data){\r\n    for(var a in data){\r\n      if(typeof data[a]!==\"function\")\r\n        this[a]=JSON.parse(JSON.stringify(data[a]));\r\n    }\r\n  }\r\n  /**\r\n  @returns a copy of itself\r\n  */\r\n  this.clone=function(){\r\n    return new EventMessage(this);\r\n  }\r\n  this.compareValuesTo=function(otherEvent,valuesList){\r\n    if(otherEvent===self)return true;\r\n    for(var index of valuesList){\r\n      if(otherEvent.value[index]!==self.value[index]) return false;\r\n    }\r\n    return true;\r\n  }\r\n  this.compareTo=function(otherEvent,propertyList){\r\n    if(otherEvent===self) return true;\r\n    function recurse(currentObject,pathArr,level=-1){\r\n      // console.log(\"R\",currentObject);\r\n      var nextLevel=level+1;\r\n      if(level==pathArr.length-1){\r\n        // console.log(\"<<\",currentObject);\r\n        return currentObject;\r\n      }else if(currentObject[pathArr[nextLevel]]){\r\n        // console.log(\">>\",currentObject[pathArr[nextLevel]]);\r\n        return recurse(currentObject[pathArr[nextLevel]],pathArr,nextLevel);\r\n      }else{\r\n        // console.log(\"?! currentObject[\"+pathArr[nextLevel]+\"]=\",currentObject[pathArr[nextLevel]]);\r\n        return;\r\n      }\r\n    }\r\n    for(var a of propertyList){\r\n      var splitVal=a.split('.');\r\n      if(splitVal.length>1){\r\n        let comparableA=recurse(self,splitVal);\r\n        let comparableB=recurse(otherEvent,splitVal);\r\n        // console.log(\"compare\",comparableA,comparableB);\r\n        if(comparableA!=comparableB){\r\n          // console.log(comparableA,\"!==\",comparableB);\r\n          return false;\r\n        }\r\n      }else{\r\n        if(JSON.stringify(self[a])!=JSON.stringify(otherEvent[a])){\r\n          // console.log(`${JSON.stringify(self[a])}!=${JSON.stringify(otherEvent[a])}`,JSON.stringify(self[a])!=JSON.stringify(otherEvent[a]))\r\n          return false;\r\n        }else{\r\n          // console.log(`${JSON.stringify(self[a])}==${JSON.stringify(otherEvent[a])}`,JSON.stringify(self[a])==JSON.stringify(otherEvent[a]))\r\n\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**apply all the characteristics of other event message to this one, except the ones that are\r\n  \"transparent\" in the other (value==-1)*/\r\n  this.superImpose=function(otherEvent){\r\n    for(var a in otherEvent.value){\r\n      if(otherEvent.value[a]>=0){\r\n        thisEm.value[a]=otherEvent.value[a];\r\n      }\r\n    }\r\n    return thisEm;\r\n  }\r\n  /**apply only the characteristics of other event message if the ones in  this are transparent*/\r\n  this.underImpose=function(otherEvent){\r\n    for (var a in otherEvent.value) {\r\n      if (!(thisEm.value[a] >= 0)) {\r\n        thisEm.value[a] = otherEvent.value[a];\r\n      }\r\n    }\r\n    return thisEm;\r\n  }\r\n  this.set(inputValue);\r\n}\r\nEventMessage.from=function(original){\r\n  return new EventMessage(original);\r\n}\r\nEventMessage.test=function(){\r\n\r\n  var eM=new EventMessage({value:[0,2,2]});\r\n  function aa (){ return  }\r\n\r\n  var scripts=[\r\n    function(){\r\n      return eM\r\n    },\r\n    function(){\r\n      return eM.clone()\r\n    },\r\n    function(){\r\n      return eM.compareTo(eM.clone(),['value'])\r\n    },\r\n    function(){\r\n      return eM.compareTo( new EventMessage({ value:[0,1,2,3] }), ['value'] )\r\n    },\r\n    function(){\r\n      return eM.compareTo(eM.clone(),['value.1'])\r\n    },\r\n    function(){\r\n      return eM.compareTo( new EventMessage({ value:[0,1,2,3] }), ['value.2'] )\r\n    },\r\n    function(){\r\n      return eM.compareTo( new EventMessage({ value:[0,1,2,3] }), ['value.1','value.2'] )\r\n    },\r\n  ];\r\n  for(var scr of scripts){\r\n    console.log(String(scr)+'\\n\\n>',eval(scr)(),\"\\n\");\r\n  }\r\n}\r\nEventMessage.fromMidi=function(midiMessage){\r\n  var headers = EventMessage.headers;\r\n\r\n  var fnHeader = midiMessage[0] & 0xf0;\r\n  var channel = midiMessage[0] & 0xf;\r\n  var num = midiMessage[1];\r\n  var numb = midiMessage[2];\r\n  var outputMessage = new EventMessage({\r\n    value: [fnHeader, num, channel, numb]\r\n  });\r\n  switch (outputMessage.value[0]) {\r\n    case 0x90: {\r\n      if (numb) {\r\n        outputMessage.value[0] = headers.triggerOn;\r\n      } else {\r\n        outputMessage.value[0] = headers.triggerOff;\r\n      }\r\n      break;\r\n    }\r\n    case 0x80:\r\n      outputMessage.value[0] = headers.triggerOff;\r\n      break;\r\n    case 0xF0:\r\n      {\r\n        if (outputMessage.value[1] == 0x8) {\r\n          outputMessage.value[0] = headers.clockTick;\r\n          outputMessage.value[1] = 6;\r\n          outputMessage.value[2] = inputClockCount % 6;\r\n          inputClockCount += 1;\r\n          break;\r\n        } else if (outputMessage.value[1] == 0xa) {\r\n          outputMessage.value[0] = headers.playhead;\r\n          outputMessage.value[1] = 0;\r\n          outputMessage.value[2] = 0;\r\n          inputClockCount = 0;\r\n          break;\r\n        } else if (outputMessage.value[1] == 0xb) {\r\n          outputMessage.value[0] = headers.triggerOn;\r\n          break;\r\n        } else if (outputMessage.value[1] == 0xc) {\r\n          outputMessage.value[0] = headers.triggerOff;\r\n          break;\r\n        }\r\n      }\r\n    default:\r\n    // console.log(\"message header not transformed:\",outputMessage.value);\r\n  }\r\n  return outputMessage;\r\n}\r\nEventMessage.toMidi=function(eventMessage){\r\n  var headers = EventMessage.headers;\r\n  var midiOut = [0, 0, 0];\r\n  if (eventMessage.value[0] == headers.changeRate) {\r\n    midiOut[0] = 0xB0 | (0x0F & eventMessage.value[2]); //cc channel\r\n    midiOut[1] = eventMessage.value[1]; //is the controller number.\r\n    midiOut[2] = eventMessage.value[3]; //is the value\r\n  }\r\n  if (eventMessage.value[0] == headers.triggerOn) {\r\n    midiOut[0] = 0x90 | (0x0F & eventMessage.value[2]);\r\n    midiOut[1] = eventMessage.value[1];\r\n    midiOut[2] = eventMessage.value[3];\r\n  }\r\n  if (eventMessage.value[0] == headers.triggerOff) {\r\n    midiOut[0] = 0x80 | (0x0F & eventMessage.value[2]);\r\n    midiOut[1] = eventMessage.value[1];\r\n    midiOut[2] = 0;\r\n  }\r\n  // console.log(\"sendimid\", midiOut);\r\n  midiOut = midiOut.map(function (a, b) {\r\n    var a = parseInt(a);\r\n    a %= (b > 0 ? 128 : 256);\r\n    if (isNaN(a)) a = 0;\r\n    return a;\r\n  });\r\n  // console.log(\" convert\",midiOut);\r\n  return midiOut;\r\n    // console.log(midiOut);\r\n}\r\n\r\nEventMessage.headers={\r\n  clockTick:0x0,\r\n  triggerOn:0x01,\r\n  triggerOff:0x02,\r\n  changePreset: 0x03,\r\n  changeRate: 0x04,\r\n  choke: 0x05,\r\n  playhead:0x06,\r\n  record:0xAA,\r\n  recordStatus:0xAB\r\n}\r\n// EventMessage.test();\r\nmodule.exports=EventMessage;\r\n/**/\r\n\n\n//# sourceURL=webpack://environment/./src/datatypes/EventMessage.js?");

/***/ }),

/***/ "./src/datatypes/TimeIndex.js":
/*!************************************!*\
  !*** ./src/datatypes/TimeIndex.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var TimeIndex=function(properties){\r\n  var self=this;\r\n  this.max=false;\r\n  this[0]=0;\r\n  this[1]=0;\r\n  for(var a of [0,1,'max']){\r\n    if(properties[a]) this[a]=properties[a];\r\n  }\r\n  this.wrapAround=function(wrap = this.max){\r\n    if(!self.max) return self;\r\n    return TimeIndex.wrapAround(self,wrap);\r\n  }\r\n  this.getWrapped=function(){\r\n    if(!self.max) return self;\r\n    return self.clone().wrapAround();\r\n  }\r\n  this.add=function(other){\r\n    return TimeIndex.add(self,other);\r\n  }\r\n  return this;\r\n}\r\n\r\nTimeIndex.wrapAround=function(timeIndex,wrap){\r\n  if(timeindex[1]>wrap[1]){\r\n    timeIndex[0]+=1;\r\n  }\r\n  timeIndex[0]%=wrap[0];\r\n  return timeIndex;\r\n}\r\nTimeIndex.add=function(timeIndex,other){\r\n  timeIndex[0]+=other[0];\r\n  timeIndex[1]+=other[1];\r\n  return timeIndex;\r\n}\r\nTimeIndex.new=function(properties){\r\n  var ret=new TimeIndex(properties);\r\n  return timeIndex;\r\n}\n\n//# sourceURL=webpack://environment/./src/datatypes/TimeIndex.js?");

/***/ }),

/***/ "./src/environment/HardwareManager.js":
/*!********************************************!*\
  !*** ./src/environment/HardwareManager.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n//\r\n// var hardwareDriverPrototypes={\r\n//   X16v0:require(\"../hardwares/driver-x16v0.js\"),\r\n//   X28v0:require(\"../hardwares/driver-x28v0.js\"),\r\n//   Defcli:require(\"../hardwares/driver-defcli.js\")\r\n// };\r\n\r\n/**\r\nHardware manager\r\n*/\r\nmodule.exports = function(environment) {\r\n  var hardwareConstructors = {};\r\n  this.addConstructor = function(Constructor) {\r\n    // console.log(`Add hardwareConstructors[${Constructor.name}]=${Constructor};`);\r\n    hardwareConstructors[Constructor.name] = Constructor;\r\n  }\r\n  this.list = [];\r\n  // setTimeout(process.exit,500);\r\n\r\n  // environment.on('created',detector.start);\r\n}\n\n//# sourceURL=webpack://environment/./src/environment/HardwareManager.js?");

/***/ }),

/***/ "./src/environment/ModuleInstanceBase.js":
/*!***********************************************!*\
  !*** ./src/environment/ModuleInstanceBase.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar onHandlers=__webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nvar EventMessage=__webpack_require__(/*! ../datatypes/EventMessage */ \"./src/datatypes/EventMessage.js\");\r\nvar headers = EventMessage.headers;\r\n\r\nmodule.exports=function(properties,environment){\r\n  onHandlers.call(this);\r\n  var self=this;\r\n  var outputs=this.outputs=new Set();\r\n  var inputs=this.inputs=new Set();\r\n  var recordOutputs=this.recordOutputs=new Set();\r\n  var recordInputs=this.recordInputs=new Set();\r\n  this.baseName=\"base\";\r\n  this.name=\"base\";\r\n  this.isModuleInstance=true;\r\n  this.mute=false;\r\n  this.interfaces={};\r\n  this._instancedInterfaces={};\r\n  //patching capabilities\r\n  this.toggleOutput=function(what){\r\n    var ret=outputs.has(what);\r\n    if(ret){\r\n      self.removeOutput(what);\r\n    }else{\r\n      self.addOutput(what);\r\n    }\r\n    return outputs.has(what);\r\n  }\r\n\r\n  this.addOutput=function(what){\r\n    if(what){\r\n      if(what===self){\r\n        self.handle('+!connection',{origin:self, destination:what});\r\n        console.error(\"can't patch a module to itself!\");\r\n      }else{\r\n        if(what.isModuleInstance){\r\n          console.log(self.name+\"--->\"+what.name);\r\n          outputs.add(what);\r\n          what.inputs.add(self);\r\n          self.handle('+connection',{origin:self,destination:what});\r\n        }else{\r\n          // console.error(what);\r\n          self.handle('+!connection',{origin:self, destination:what});\r\n          throw [\"Forbidden output: you tried to connect \"+self.name+\" to a \"+what,what];\r\n        }\r\n      }\r\n    }else{\r\n      throw \"Forbidden output: Attempted to connect \"+self.name+\" to \"+what;\r\n    }\r\n  }\r\n  this.removeOutput=function(what){\r\n    var rpt=outputs.delete(what);\r\n    what.inputs.delete(self);\r\n\r\n    console.log(self.name+\"-\"+(rpt?\"X\":\" \")+\"->\"+what.name);\r\n    self.handle('-connection',{origin:self,destination:what});\r\n\r\n  }\r\n  this.addInput=function(what){\r\n    try{\r\n      what.addOutput(self);\r\n    }catch(e){\r\n      console.error(\"could not add input\");\r\n      console.log(e);\r\n    }\r\n  }\r\n\r\n  this.enqueue=setImmediate;\r\n  this.getOutputs=function(){\r\n    return Array.from(outputs);\r\n  }\r\n  this.getInputs=function(){\r\n    return Array.from(inputs);\r\n  }\r\n  this.output=function(eventMessage,overrideMute){\r\n    if((!self.mute)||overrideMute){\r\n      //outputs don't get executed right away, this avoids a crash in case there is a patching loop\r\n      self.enqueue(function(){\r\n        outputs.forEach(function(tModule){\r\n          // console.log(eventMessage.value);\r\n          tModule.messageReceived({eventMessage:eventMessage.clone(),origin:self});\r\n          self.handle('>message',{origin:self,destination:tModule,val:eventMessage});\r\n          // console.log(\"handle>\",tModule.name);\r\n        })\r\n      });\r\n    }\r\n  }\r\n  this.messageReceived=function(evt){\r\n  }\r\n  this.recordingReceived=function(evt){}\r\n  this.removeInput=function(what){\r\n    what.removeOutput(self)\r\n  }\r\n\r\n  /**\r\n  Record patching capabilities (it is a layer of abstraction over normal output). recOutput=normalOutput+recording header\r\n  A message to be recorded is an ordinary message, with 0xAA prepended. This means that modules with the ability to record incoming events, should take a special reception action when such is the header. Modules which do not have recording capabilities should discard these events.\r\n  There is a parallel patcing of recording outputs, this is an interface nuance to allow easier management of recording events from all other events. in this way, it can still be implemented in modular hardware.\r\n\r\n  */\r\n\r\n  this.toggleRecordOutput=function(what){\r\n    var ret=recordOutputs.has(what);\r\n    if(ret){\r\n      self.removeRecordOutput(what);\r\n    }else{\r\n      self.addRecordOutput(what);\r\n    }\r\n    return recordOutputs.has(what);\r\n  }\r\n\r\n  var recordStartedEm=new EventMessage({value:[headers.recordStatus,1,0,0]});\r\n  var recordEndedEm=new EventMessage({value:[headers.recordStatus,0,0,0]});\r\n\r\n  this.addRecordOutput=function(what){\r\n    if(what){\r\n      if(what.isModuleInstance){\r\n        self.handle('+recopt',{origin:self,data:what});\r\n        console.log(self.name+\" rec> \"+what.name);\r\n        recordOutputs.add(what);\r\n        what.recordInputs.add(self);\r\n        self.addInput(what);\r\n        self.enqueue(function(){\r\n          what.recordingReceived({eventMessage:recordStartedEm,origin:self});\r\n        });\r\n\r\n      }else{\r\n        // console.error(what);\r\n        throw [\"Forbidden output: you tried to connect \"+self.name+\" to a \"+what,what];\r\n        self.handle('fail + recopt',{origin:self,data:what});\r\n      }\r\n    }else{\r\n      throw \"Forbidden output: Attempted to connect \"+self.name+\" to \"+what;\r\n    }\r\n  }\r\n  this.removeRecordOutput=function(what){\r\n    var rpt=recordOutputs.delete(what);\r\n    what.recordInputs.delete(self);\r\n\r\n    self.enqueue(function(){\r\n      what.recordingReceived({eventMessage:recordEndedEm,origin:self});\r\n    });\r\n    console.log(self.name+\" r\"+(rpt?\"X\":\" \")+\"c> \"+what.name);\r\n    self.handle('-recopt',{origin:self,data:what});\r\n  }\r\n  this.addRecordInput=function(what){\r\n    try{\r\n      what.addRecordOutput(self);\r\n    }catch(e){\r\n      console.error(\"could not add input\");\r\n      console.log(e);\r\n    }\r\n  }\r\n  this.recordOutput=function(eventMessage){\r\n    // console.log(\"RECO\");\r\n\r\n    recordOutputs.forEach(function(tModule){\r\n      // console.log(\"RECO \",eventMessage.value,\">\",tModule.name);\r\n\r\n      var recordEventMessage=eventMessage.clone();\r\n      recordEventMessage.value.unshift(headers.record);\r\n      // console.log(recordEventMessage.value);\r\n      tModule.recordingReceived({eventMessage:recordEventMessage,origin:self});\r\n    });\r\n  }\r\n  // this.recordmessageReceived=function(evt){\r\n  //   // console.log(evt);\r\n  // }\r\n  this.remove=function(){\r\n    for(let output of outputs){\r\n      self.removeOutput(output);\r\n    }\r\n    for(let recoutput of recordOutputs){\r\n      self.removeRecordOutput(recoutput);\r\n    }\r\n    self.messageReceived=function(evt){\r\n      console.log(\"deleted module\",evt);\r\n      if(evt.origin){\r\n        self.removeInput(evt.origin);\r\n        evt.origin.removeOutput(self);\r\n        evt.origin.removeRecordOutput(self);\r\n      }\r\n    }\r\n    self.handle('-module',{origin:self});\r\n    if(self.onRemove){\r\n      return self.onRemove();\r\n    }\r\n    return true;\r\n  }\r\n  self.handle('+module',{origin:self});\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/environment/ModuleInstanceBase.js?");

/***/ }),

/***/ "./src/environment/ModulesManager.js":
/*!*******************************************!*\
  !*** ./src/environment/ModulesManager.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// var modulePrototypesList=require('./modulePrototypesList');\r\nvar utils = __webpack_require__(/*! ./utils */ \"./src/environment/utils.js\");\r\nvar ModuleInstanceBase = __webpack_require__(/*! ./ModuleInstanceBase */ \"./src/environment/ModuleInstanceBase.js\");\r\n/**\r\n@constructor\r\nModulesManager manages the pattern modifying modules.\r\n*/\r\nvar ModulesManager = function (environment) {\r\n  var modules = this.list = [];\r\n  var constructors = {};\r\n\r\n  var thisMan = this;\r\n  console.log(\"+ modulesManager\");\r\n  environment.handle('+modulesManager', this);\r\n  this.addConstructor = function (Constructor) {\r\n    console.log(\"modules constructor add \" + Constructor.name, \"color\", Constructor.color);\r\n    // console.log(\"instancing module: \",moduleName);\r\n    try {\r\n      // if(!moduleName) moduleName=\"unnamed\";\r\n      // if(!properties) properties={};\r\n      if (constructors[Constructor.name]) { console.error(\"module named \" + Constructor.name + \" is registered\"); }\r\n\r\n    } catch (e) {\r\n      console.error(\"error registering a module named \" + Constructor.name, e);\r\n    }\r\n    constructors[Constructor.name] = Constructor;\r\n  }\r\n  this.getRegistered = function () {\r\n    return constructors;\r\n  }\r\n  this.getModuleConstructors = function () {\r\n    return constructors;\r\n  }\r\n\r\n\r\n  //this prevents the program from freezing in a case of extreme module feedback\r\n  var lazyQueue = new utils.LazyQueue();\r\n\r\n  this.getModuleWithName = function (name) {\r\n    // console.log(modules);\r\n    for (var module of modules) {\r\n      if (module.name == name) {\r\n        return module;\r\n      }\r\n    }\r\n  }\r\n  this.tryGetN = function (n) {\r\n    if (this.list[n]) {\r\n      return this.list[n];\r\n    }\r\n    return false;\r\n  }\r\n  this.removeModule = function (mod) {\r\n    if (mod.remove()) {\r\n      modules.splice(modules.indexOf(mod), 1);\r\n      environment.handle('-module', { module: mod });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  this.removeModuleN = function (n) {\r\n    if (modules[n].remove()) {\r\n      modules.splice(n, 1);\r\n      environment.handle('-module', { module: modules[n] });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  /** @function\r\n  instanciate and register a new module.\r\n  Two example uses of this function are in the superinteractor, when you create a new module using the buttons, and the midi IO, which creates one module per midi input\r\n  */\r\n  this.instantiate = function (moduleName, properties = {}, callback = false) {\r\n    var newInstance = false;\r\n    try {\r\n      console.log(\"+module \" + moduleName);\r\n      newInstance = new ModuleInstanceBase(properties, environment)\r\n      constructors[moduleName].call(newInstance, properties, environment);\r\n      newInstance.enqueue = lazyQueue.enq;\r\n      newInstance.type = moduleName;\r\n      if (constructors[moduleName].color) {\r\n        newInstance.color = constructors[moduleName].color;\r\n      }\r\n      modules.push(newInstance);\r\n      if (typeof callback === \"function\") {\r\n        callback(newInstance);\r\n      }\r\n      environment.handle('+module', { module: newInstance, properties:properties });\r\n\r\n    } catch (e) {\r\n      console.error(\"error instantiating module \", moduleName, e);\r\n    }\r\n    return newInstance;\r\n  }\r\n\r\n\r\n  this.applyProperties = function (props) {\r\n    console.log(\"Creating modules net:\");\r\n    for (var n in props) {\r\n      moduleDefinition = props[n];\r\n      if (!props[n].properties) props[n].properties = {};\r\n      var newModule = thisMan.instantiate(moduleDefinition.type, moduleDefinition.properties);\r\n      props[n].properties.name = newModule.name;\r\n      \r\n    }\r\n    console.log(\"patching modules net:\");\r\n    for (var moduleDefinition of props) {\r\n      // console.log(moduleDefinition.properties.name);\r\n      var module = thisMan.getModuleWithName(moduleDefinition.properties.name);\r\n      console.log(\" - patch module \\\"\" + moduleDefinition.properties.name + \"\\\" (\" + moduleDefinition.type + \") \");\r\n\r\n      if (moduleDefinition.outputs) for (var outputName of moduleDefinition.outputs) {\r\n        console.log(\" - to \\\"\" + outputName + \"\\\"\");\r\n        try {\r\n          var output = thisMan.getModuleWithName(outputName);\r\n          if (!output) throw \"  -couldn't find module named \" + outputName\r\n          module.addOutput(output);\r\n        } catch (e) {\r\n          // console.log(module);\r\n          console.error(\" -could't set output of \" + moduleDefinition.properties.name + \" to \" + outputName + \": \\n\", e);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return this;\r\n};\r\nmodule.exports = ModulesManager;\r\n\r\n\r\n\n\n//# sourceURL=webpack://environment/./src/environment/ModulesManager.js?");

/***/ }),

/***/ "./src/environment/index.js":
/*!**********************************!*\
  !*** ./src/environment/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Observable=__webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\n\r\nvar ModulesManager=__webpack_require__(/*! ./ModulesManager */ \"./src/environment/ModulesManager.js\");\r\n\r\nvar HardwareManager=__webpack_require__(/*! ./HardwareManager.js */ \"./src/environment/HardwareManager.js\");\r\nvar utils=__webpack_require__(/*! ./utils.js */ \"./src/environment/utils.js\");\r\nvar requireProperties=utils.requireProperties;\r\n\r\nvar Environment=function(){\r\n  this.utils=utils;\r\n  this.log=console.log;\r\n  Observable.call(this);\r\n  var self=this;\r\n  var environment=this;\r\n  this.on('a',console.log)\r\n\r\n  /**\r\n  TODO:\r\n  interactionMan is not yet re-structured. do a project search of interactionmanager and see how to get nobody to depend on it.\r\n\r\n   interactionMan is responsible for relating hardware events to actions in the modular environment */\r\n  this.interactionMan = __webpack_require__(/*! ../interaction/interactionManager.js */ \"./src/interaction/interactionManager.js\")(this);\r\n\r\n  var modules=this.modules=new ModulesManager(this);\r\n\r\n  this.module=function(Constructor){\r\n    var fails=requireProperties.call(Constructor,['name','constructor']);\r\n    if(fails){\r\n      console.error(\"a module couldn't be added because of problems the properties:\",fails);\r\n      return;\r\n    }else{\r\n      console.log(\"added module\",Constructor.name);\r\n    }\r\n    if(typeof Constructor.initialization===\"function\"){\r\n      Constructor.initialization(self);\r\n    }\r\n    modules.addConstructor(Constructor);\r\n    return this;\r\n  }\r\n\r\n  var hardwares=this.hardwares= new HardwareManager(this);\r\n\r\n  this.useHardware=function(Constructor){\r\n    var fails=requireProperties.call(Constructor,['name','constructor','initialization']);\r\n    if(fails){\r\n      console.error(\"a module couldn't be added because of problems the properties:\",fails);\r\n      return;\r\n    }else{\r\n      console.log(\"added hardware\",Constructor.name);\r\n    }\r\n    if(typeof Constructor.initialization===\"function\"){\r\n      // console.log(\"INIT\",Constructor.name);\r\n      Constructor.initialization(self);\r\n    }\r\n    hardwares.addConstructor(Constructor);\r\n    return this;\r\n  }\r\n}\r\n\r\n\r\n\r\nmodule.exports=Environment;\n\n//# sourceURL=webpack://environment/./src/environment/index.js?");

/***/ }),

/***/ "./src/environment/utils.js":
/*!**********************************!*\
  !*** ./src/environment/utils.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.LazyQueue=function(properties) {\r\n  var stackLimit = false;\r\n  var stack = [];\r\n  var self=this;\r\n  // this.interval = 1;\r\n  // this.tPerStep=50;\r\n  this.dequeuing=false;\r\n  this.messagePriority=50;\r\n  this.maxStack=false;\r\n  for(var a in properties){\r\n    this[a]=properties[a];\r\n  }\r\n\r\n\r\n  this.enq = function(cb) {\r\n    stack.push(cb);\r\n    if(self.maxStack){\r\n      if(stack.length>self.maxStack){\r\n        stack.splice(0,self.maxStack-stack.length);\r\n        // console.log(`stack.splice(0,${self.maxStack-stack.length});`);\r\n      }\r\n    }\r\n    if(!self.dequeuing){\r\n      deq();\r\n    }\r\n  }\r\n  function deq(){\r\n    self.dequeuing=true;\r\n    let count=0;\r\n    while(stack.length && count<self.messagePriority){\r\n      (stack.shift())();\r\n      count++\r\n    }\r\n    if(stack.length){\r\n      setImmediate(deq);\r\n      console.warn(\"! EVENTS FIFO: \"+stack.length+\"\");\r\n\r\n    }else{\r\n      self.dequeuing=false;\r\n    }\r\n  };\r\n};\r\nmodule.exports.requireProperties=function(propList){\r\n  var missing={};\r\n  for(var a in propList){\r\n    if(typeof propList[a] === 'function'){\r\n      let eval=propList[a](this[a]);\r\n      if(!eval){\r\n        missing[a]=eval;\r\n      }\r\n    }else{\r\n      if(!this[propList[a]]){\r\n        missing[propList[a]]=\"is \"+missing[a];\r\n      }else{\r\n      }\r\n    }\r\n  }\r\n  if(Object.keys(missing).length==0) missing=false;\r\n  return missing;\r\n}\n\n//# sourceURL=webpack://environment/./src/environment/utils.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n// var X16Hardware=require('./hardwares/DriverX16v0.js');\r\n// var Http=require('./hardwares/Driver-http.js');\r\n\r\n/** Environment is the lower-level global scope, objects that have environment can access the hardware, modules and others */\r\nvar environment = new(__webpack_require__(/*! ./environment */ \"./src/environment/index.js\"))();\r\n\r\n// examples\r\n// var X28Hardware=require('./hardwares/DriverX28v0.js');\r\n// environment.useHardware(X28Hardware);\r\n// environment.useHardware(Http);\r\n\r\nvar modulesToLoad = {\r\n  'Sequencer': {},\r\n  'PianoRoll': {},\r\n  'NoteSustainer': {},\r\n  'PresetKit': {},\r\n  // 'Alteration': {},\r\n  'Harmonizer': {},\r\n  'Arpeggiator': {},\r\n  'Narp': {},\r\n  'Noise': {},\r\n  'Chord': {},\r\n  'Operator': {},\r\n  'GameOfLife': {},\r\n  'Bouncer': {},\r\n  'RouteSequencer': {},\r\n  'FixNoteLen': {},\r\n  'DelayClockBased': {},\r\n  'ModModify': {},\r\n  // 'MultiTape': {},\r\n  'ClockGenerator': {},\r\n  'Bus': {},\r\n  'CalculeitorMidi': {},\r\n};\r\n\r\nfor (var a in modulesToLoad) {\r\n  console.log(\"requiring module \" + a);\r\n  modulesToLoad[a] = __webpack_require__(\"./src/modules sync recursive ^\\\\.\\\\/.*$\")(\"./\" + a);\r\n}\r\n\r\n/** modulesMan is responsible for the modular environment */\r\n// environment.modules=require(\"./modules/modulesManager.js\")(environment);\r\nfor (var a in modulesToLoad) {\r\n  environment.module(modulesToLoad[a]);\r\n  //  for testing\r\n  // environment.modules.instantiate(a, {});\r\n}\r\n//\r\nenvironment.vars = {\r\n  light: 56,\r\n  advancedRecording: false,\r\n  messagePriority: 50,\r\n  interfacePriority: 15,\r\n  interfaceMaxStack: 15,\r\n}\r\n\r\nenvironment.modules.instantiate('Bus',{name:\"global\"});\r\n\r\n// environment.handle('created');\r\n\r\nmodule.exports = environment;\r\n\n\n//# sourceURL=webpack://environment/./src/index.js?");

/***/ }),

/***/ "./src/interaction/DefCli/index.js":
/*!*****************************************!*\
  !*** ./src/interaction/DefCli/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar SuperInteractorSingleton=__webpack_require__(/*! ./superInteractor.js */ \"./src/interaction/DefCli/superInteractor.js\");\r\nvar myInteractorBase=__webpack_require__(/*! ./interactorBase.js */ \"./src/interaction/DefCli/interactorBase.js\");\r\n\r\n/**\r\neach hardware needs a interface definition. The interface definition is instanced only once per run, and there is one different interface per each hardware. The interface instances the SuperInteractorSingleton, and provides the SuperInteractor constructor to the {@link interactionManager}. This avoids having to load one interactorBase, and one SuperInteractor for each different hardware that could exist.\r\n*/\r\nmodule.exports=(function(environment){\r\n  /**\r\n  definition of the base for interactors to be .called(this) on every interactor\r\n  */\r\n  this.interactorBase=myInteractorBase;\r\n  /**\r\n  my SuperInteractor singleton\r\n  */\r\n  this.superInteractorSingleton=new SuperInteractorSingleton(environment);\r\n  this.SuperInteractor=this.superInteractorSingleton.SuperInteractor;\r\n})\n\n//# sourceURL=webpack://environment/./src/interaction/DefCli/index.js?");

/***/ }),

/***/ "./src/interaction/DefCli/interactorBase.js":
/*!**************************************************!*\
  !*** ./src/interaction/DefCli/interactorBase.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar InteractorBase=__webpack_require__(/*! ../Interactor.js */ \"./src/interaction/Interactor.js\");\r\n/**\r\n base template for interactors when they are x16basic compatible\r\n*/\r\nvar DefCLiInteractor=function(controlledModule){\r\n  var thisInteractor=this;\r\n  this.controlledModule=controlledModule;\r\n  InteractorBase.call(this,controlledModule);\r\n  this.compatibilityTags=[\"cli\"];\r\n  this.commandInput=function(){}\r\n  this.engage=function(event){};\r\n  this.disengage=function(event){}\r\n}\r\nmodule.exports=DefCLiInteractor;\n\n//# sourceURL=webpack://environment/./src/interaction/DefCli/interactorBase.js?");

/***/ }),

/***/ "./src/interaction/DefCli/superInteractor.js":
/*!***************************************************!*\
  !*** ./src/interaction/DefCli/superInteractor.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\nDefinition of hardware specific translations of hardware events into internal events\r\nthings such as \"when the user press a button\" become \"view the sequencer user interface\"\r\n\r\nA superInteractor defines the main context for the interactors of the specific hardware. A superinteractor is the entry point to any of the other interfaces. For instance, if somebody created a hardware that is designed only for one specific module, the superinteractor would be in charge of routing the compatible module to that hardware device. If the module is supposed to be able to create and route modules (like in this case), a superinteractor defines the user interaction patterns of how the modules are created; and how one switches between interface.\r\n*/\r\nmodule.exports = {};\r\nvar onHandlers = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\n\r\nvar moduleInterfaces = [];\r\n/**\r\n * @constructor\r\n * singleton\r\n * @param {environment} input to pass the environment. Needed to access the modulesMan, for things such as adding modules, jumping to modules, etc.\r\n */\r\nvar DefCliSuperInteractorSingleton = function(environment) {\r\n  /**check compatibility of a certain interactor*/\r\n  var compatibilityTags = [\"cli\"];\r\n  var compatible = function(tagSet) {\r\n    for (var tag of tagSet) {\r\n      if (compatibilityTags.indexOf(tag) != -1) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n  affects all the DefCliInteractors. Depending on how much sense it makes, there could be a function that adds an interactor only to a certain hardware instance.\r\n  */\r\n  this.appendModuleInteractor=function(what){\r\n    // console.log(\"WAT\",what);\r\n    if(what==undefined){\r\n      console.log(\"undefined interactor\");\r\n      \r\n    }else if(what.type==\"interactor\"){\r\n      if(compatible(what.compatibilityTags)){\r\n        moduleInterfaces.push(what);\r\n      }else{\r\n        // console.log(what);\r\n        //   throw \"x16v0 Superinteractor is incompatible with interface\",what;\r\n      }\r\n    }else{\r\n      throw \"tried to add an object to a SuperInteractor that is not an interactor\";\r\n    }\r\n  }\r\n  /** get the list of interactors @return array*/\r\n  this.getModuleInteractors = function() {\r\n    return moduleInterfaces;\r\n  }\r\n\r\n  /**\r\n   * @constructor\r\n   * Super interactor instance: one per connected ui. hardware\r\n   * X16SuperInteractor a {@link superInteractor} prototype for x16basic {@link HardwareDriver}.\r\n   * @param {x16Hardware}\r\n   * @returns {undefined} no return\r\n   */\r\n  this.SuperInteractor = function(myHardware) {\r\n    /** @private @var engagedInterface stores the module that is currently engaged, the interaction events are forwarded to the {@link moduleInterface} that is referenced here*/\r\n    var engagedInterface = false;\r\n    onHandlers.call(this);\r\n    var thisInteractor = this;\r\n\r\n    // console.log(\"HWWW\",myHardware);\r\n\r\n    this.commandInput = function(command) {\r\n      if (engagedInterface) {\r\n        engagedInterface.commandInput(command);\r\n      }else{\r\n        console.log(command);\r\n        if(command[\">\"]==\"exit\") process.exit();\r\n      }\r\n    }\r\n\r\n    environment.on('+module', function(evt) {\r\n      myHardware.print(\"new module\",evt.module.name);\r\n    });\r\n\r\n    this.engage = function(evt) {\r\n      sayHi();\r\n      displayModules();\r\n      engagedInterface = false;\r\n    }\r\n\r\n    function sayHi() {\r\n      myHardware.print(\"command line root\");\r\n    }\r\n\r\n    function help() {\r\n      myHardware.print(\"help:\");\r\n    }\r\n    return this;\r\n  }\r\n};\r\n\r\nmodule.exports = DefCliSuperInteractorSingleton;\n\n//# sourceURL=webpack://environment/./src/interaction/DefCli/superInteractor.js?");

/***/ }),

/***/ "./src/interaction/Interactor.js":
/*!***************************************!*\
  !*** ./src/interaction/Interactor.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar onHandlers=__webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\n/**\r\n@typedef {Object} SuperInteractor are the interactors that ultimately receive the events from the hardware and forward these events to the corresponding interactor. It also defines the interaction pattern when there is no Interactor engaged (e.g. at the start)\r\n@typedef {Object} Interactor are the patterns of interaction that will most likely be designed by users. They serve to produce changes in some {@link Module}s. They have a specific definition of compatible hardware interfaces.\r\n*/\r\nvar interactorBase=function(controlledModule){\r\n  onHandlers.call(this);\r\n  // if(controlledModule){\r\n  //    this.name=controlledModule.name;\r\n  // }else{\r\n  //   console.warn(\"call interactor base providing controlledModule\");\r\n  // }\r\n  this.compatibilityTags=[];\r\n  this.name=\"empty interactor\";\r\n  this.type=\"interactor\";\r\n  this.controlledModule=controlledModule;\r\n}\r\nmodule.exports=interactorBase;\n\n//# sourceURL=webpack://environment/./src/interaction/Interactor.js?");

/***/ }),

/***/ "./src/interaction/interactionManager.js":
/*!***********************************************!*\
  !*** ./src/interaction/interactionManager.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//this module handles what happen when there is a hardware event (such as pressing a button)\r\nlet onHandlers=__webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nlet X16bs=__webpack_require__(/*! ./x16basic */ \"./src/interaction/x16basic/index.js\");\r\nlet X28bs = __webpack_require__(/*! ./x28basic */ \"./src/interaction/x28basic/index.js\");\r\nlet X8bs=__webpack_require__(/*! ./x8basic */ \"./src/interaction/x8basic/index.js\");\r\nlet DefCli=__webpack_require__(/*! ./DefCli */ \"./src/interaction/DefCli/index.js\");\r\n\r\n/**\r\nInteractionManager contains a list of all the running instances of {@link HardwareDriver}s and links them to instances of {@link superInteractorPrototypes} and {@link Interactor}s\r\n*/\r\nvar interactionManager=function(environment){ return new(function(){\r\n  var interfaces=({});\r\n  this.interfaces=interfaces;\r\n  //entry interactors are the interactors that each hardware will use as starting point. they define how to patch and access modules\r\n  var superInteractorSingletons=[];\r\n  var superInteractorInstances=[];\r\n  var moduleInteractorSingletons=[];\r\n  // var moduleInteractorInstances=[];\r\n  //create the interface element and register it's singleton\r\n  //TODO: change this structure. This is a total mess!\r\n  interfaces.x16basic=new X16bs(environment);\r\n  superInteractorSingletons.push(interfaces.x16basic.superInteractorSingleton);\r\n  interfaces.x28basic=new X28bs(environment);\r\n  superInteractorSingletons.push(interfaces.x28basic.superInteractorSingleton);\r\n  // interfaces.DefCli = new DefCli(environment);\r\n  // superInteractorSingletons.push(interfaces.DefCli.superInteractorSingleton);\r\n  interfaces.x8basic = new X8bs(environment);\r\n  superInteractorSingletons.push(interfaces.x8basic.superInteractorSingleton);\r\n  /**\r\n    @function\r\n    called by a hardwareManager: when there is a new hardware connected, it is associated with a {@link superInteractor}\r\n    @param {string} type specifies the SuperInteractor constructor to call\r\n    @param {Object} HardwareDriver instance. The hardware to which to assign this SuperInteractor\r\n  */\r\n  this.newSuperInteractor=function(type,hardware){\r\n    console.log(\"new superinteractor \",type);\r\n    var ret=new interfaces[type].SuperInteractor(hardware);\r\n    // console.log(\"...\",ret);\r\n    superInteractorInstances.push(ret);\r\n    return ret;\r\n  };\r\n\r\n/**\r\n  @param {prototype} interactorSingleton the constructor for the interactor's singleton. Every interactor needs a parent singleton, that is called by the interactionManager. It is called passing the environment as parameter, allowing all the interactors to share the environment. Some other initialization functions could be called in this construction according to the interactor needs.\r\n*/\r\n  this.appendInteractorSingleton=function(interactorSingleton){\r\n    moduleInteractorSingletons.push(interactorSingleton);\r\n  }\r\n\r\n  // environment.on('+module',function(evt){\r\n    // var newInteractor=evt.module.interactor;\r\n    // moduleInteractorInstances.push(newInteractor);\r\n    // for(var sis of superInteractorSingletons){\r\n    //   sis.appendModuleInteractor(newInteractor);\r\n    // }\r\n  // })\r\n  return this;\r\n})};\r\nmodule.exports=interactionManager;\n\n//# sourceURL=webpack://environment/./src/interaction/interactionManager.js?");

/***/ }),

/***/ "./src/interaction/x16basic/ModuleCreator.js":
/*!***************************************************!*\
  !*** ./src/interaction/x16basic/ModuleCreator.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\n/**\r\n *Tiny pseudo-interactor that is used to choose what module to isntantiate when we press on an empty slot of the \"patchboard\" (i.e. button that is not lid)\r\n */\r\nfunction ModuleCreator(myHardware,environment) {\r\n  var possibleModules = [];\r\n  var possibleModulesBitmap = 0;\r\n  var moduleToCreateOnDisengage = false;\r\n  var lastMatrixButton = false;\r\n  var modulesMan=environment.modulesMan;\r\n  this.engaged = false;\r\n\r\n  function updatePossibleModulesList() {\r\n    possibleModules = possibleModules = Object.keys(environment.modules.getRegistered());\r\n    possibleModulesBitmap = ~(0xffff << possibleModules.length);\r\n  }\r\n\r\n  function updateHardware() {\r\n    myHardware.sendScreenA(\"create module\");\r\n    var head = 0;\r\n    if (lastMatrixButton) head = 1 << lastMatrixButton;\r\n    myHardware.draw([possibleModulesBitmap | head, 0 | head, possibleModulesBitmap | head]);\r\n  }\r\n  this.engage = function() {\r\n    if (possibleModules.length == 0) updatePossibleModulesList();\r\n    updateHardware();\r\n    this.engaged = true;\r\n  }\r\n  this.disengage = function() {\r\n    var ret = false;\r\n    this.engaged = false;\r\n    if (moduleToCreateOnDisengage) {\r\n      var defaultProps = {};\r\n      environment.modules.instantiate(moduleToCreateOnDisengage, defaultProps);\r\n      var nMod=modules.list[modules.list.length - 1];\r\n      ret = {\r\n        module:nMod,\r\n        interface:nMod.interface,\r\n        number:modules.list.length - 1\r\n      };\r\n    }\r\n    return ret;\r\n  }\r\n  this.matrixButtonPressed = function(evt) {\r\n    /*if(evt.data[0]===lastMatrixButton){ deprecated create module on second tap.\r\n      this.disengage();\r\n    }else */\r\n    if (evt.data[0] < possibleModules.length) {\r\n      lastMatrixButton = evt.data[0];\r\n      moduleToCreateOnDisengage = possibleModules[evt.data[0]];\r\n      myHardware.sendScreenA(\"Release to create\");\r\n      myHardware.sendScreenB(\"+\" + moduleToCreateOnDisengage);\r\n    } else {\r\n      moduleToCreateOnDisengage = false;\r\n      this.disengage();\r\n    }\r\n  }\r\n  this.matrixButtonReleased = function(evt) {}\r\n}\r\nmodule.exports=ModuleCreator;\n\n//# sourceURL=webpack://environment/./src/interaction/x16basic/ModuleCreator.js?");

/***/ }),

/***/ "./src/interaction/x16basic/index.js":
/*!*******************************************!*\
  !*** ./src/interaction/x16basic/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar myInteractorBase=__webpack_require__(/*! ./interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar SuperInteractorSingleton=__webpack_require__(/*! ./superInteractor.js */ \"./src/interaction/x16basic/superInteractor.js\");\r\n/**\r\neach hardware needs a interface definition. The interface definition is instanced only once per run, and there is one different interface per each hardware. The interface instances the SuperInteractorSingleton, and provides the SuperInteractor constructor to the {@link interactionManager}. This avoids having to load one interactorBase, and one SuperInteractor for each different hardware that could exist.\r\n*/\r\nmodule.exports=(function(environment){\r\n  /**\r\n  definition of the base for interactors to be .called(this) on every interactor\r\n  */\r\n  this.interactorBase=myInteractorBase;\r\n  /**\r\n  my SuperInteractor singleton\r\n  */\r\n  this.superInteractorSingleton=new SuperInteractorSingleton(environment);\r\n  this.SuperInteractor=this.superInteractorSingleton.SuperInteractor;\r\n})\n\n//# sourceURL=webpack://environment/./src/interaction/x16basic/index.js?");

/***/ }),

/***/ "./src/interaction/x16basic/interactorBase.js":
/*!****************************************************!*\
  !*** ./src/interaction/x16basic/interactorBase.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar InteractorBase=__webpack_require__(/*! ../Interactor.js */ \"./src/interaction/Interactor.js\");\r\n/**\r\n base template for interactors when they are x16basic compatible\r\n*/\r\nvar x16InteractorBase=function(controlledModule){\r\n  var thisInteractor=this;\r\n  this.controlledModule=controlledModule;\r\n  InteractorBase.call(this,controlledModule);\r\n  this.compatibilityTags=[\"x28v0\",\"x16v0\"];\r\n  // console.log(\".....\",this.compatibilityTags);\r\n  this.matrixButtonPressed=function(event){};\r\n  this.matrixButtonReleased=function(event){};\r\n  this.matrixButtonVelocity=function(event){};\r\n  this.matrixButtonHold=function(event){};\r\n  this.selectorButtonPressed=function(event){};\r\n  this.selectorButtonReleased=function(event){};\r\n  this.bottomButtonPressed=function(event){};\r\n  this.bottomButtonReleased=function(event){};\r\n  this.encoderScrolled=function(event){};\r\n  this.encoderPressed=function(event){};\r\n  this.encoderReleased=function(event){};\r\n  this.engage=function(event){};\r\n  this.disengage=function(event){};\r\n  this.outsideScroll=function(event){};\r\n}\r\nmodule.exports=x16InteractorBase;\n\n//# sourceURL=webpack://environment/./src/interaction/x16basic/interactorBase.js?");

/***/ }),

/***/ "./src/interaction/x16basic/superInteractor.js":
/*!*****************************************************!*\
  !*** ./src/interaction/x16basic/superInteractor.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar RARROW = String.fromCharCode(126);\r\n/**\r\nDefinition of hardware specific translations of hardware events into internal events\r\nthings such as \"when the user press a button\" become \"view the sequencer user interface\"\r\n\r\nA superInteractor defines the main context for the interactors of the specific hardware. A superinteractor is the entry point to any of the other interfaces. For instance, if somebody created a hardware that is designed only for one specific module, the superinteractor would be in charge of routing the compatible module to that hardware device. If the module is supposed to be able to create and route modules (like in this case), a superinteractor defines the user interaction patterns of how the modules are created; and how one switches between interface.\r\n*/\r\nmodule.exports = {};\r\nvar onHandlers = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nvar ModuleCreator = __webpack_require__(/*! ./ModuleCreator */ \"./src/interaction/x16basic/ModuleCreator.js\");\r\n\r\n/**\r\n * @constructor\r\n * singleton\r\n * @param {environment} input to pass the environment. Needed to access the modulesMan, for things such as adding modules, jumping to modules, etc.\r\n */\r\nvar SuperInteractorsSingleton = function(environment) {\r\n  /**\r\n   * @constructor\r\n   * Super interactor instance: one per connected ui. hardware\r\n   * X16SuperInteractor a {@link superInteractor} prototype for x16basic {@link HardwareDriver}.\r\n   * @param {x16Hardware}\r\n   * @returns {undefined} no return\r\n   */\r\n  this.SuperInteractor = function(myHardware) {\r\n\r\n    /** @private @var engagedInterface stores the module that is currently engaged, the interaction events are forwarded to the {@link moduleInterface} that is referenced here*/\r\n\r\n    var muteMode = false;\r\n    var deleteMode = false;\r\n\r\n    var modulesMan=environment.modules;\r\n\r\n    /** @private @var selectedInterface stores the {@link moduleInterface} that will become engaged once the patching button is released / the superInteractor disengaged.\r\n    selectedInterface is also subject to patching\r\n    */\r\n    var selectedModule = false;\r\n    var selectedInterface=false;\r\n    var selectedModuleNumber=false;\r\n    /**\r\n    keeps the interface that is currently engaged\r\n    */\r\n    var engagedInterface = false;\r\n    var thisInteractor = this;\r\n    /** store what are the modules over which a button was pressed\r\n    this allows to switch to another module and still detect the\r\n    release in the module where the button was pressed. Furthermore,\r\n    if we are using some sort of expression out of the pressure sensing,\r\n    we can assign it to the module where it was pressed\r\n    @private @var matrixButtonOwners={};\r\n    @private @var selectorButtonOwners={};\r\n    */\r\n    var matrixButtonOwners = {};\r\n    var selectorButtonOwners = {};\r\n    //for the matrix button pressed event, it indicates if this is the only matrix button that is pressed or not (allows selecting a module's outputs)\r\n    var firstPressedMatrixButton = false;\r\n    onHandlers.call(this);\r\n    var myModuleCreator = new ModuleCreator(myHardware,environment);\r\n    this.on('interaction', function(event) {\r\n      if (engagedInterface) {\r\n        engagedInterface.handle('interaction', event);\r\n      }\r\n    });\r\n    // this.on('interaction',console.log);\r\n    environment.on('+module', function(evt) {\r\n      if (!(engagedInterface || myModuleCreator.engaged)) {\r\n        updateHardware();\r\n      }\r\n    });\r\n    this.on('matrixButtonPressed', function(event) {\r\n      if (myModuleCreator.engaged) {\r\n        myModuleCreator.matrixButtonPressed(event);\r\n      } else if (!engagedInterface) {\r\n        if (firstPressedMatrixButton === false) {\r\n          selectedModule = tryGetModuleN(event.button);\r\n          selectedInterface=tryGetInterfaceN(event.button);\r\n          selectedModuleNumber=(selectedModule?event.button:false);\r\n          firstPressedMatrixButton = event.data[0];\r\n          updateHardware();\r\n        } else {\r\n          var modulea = tryGetModuleN(firstPressedMatrixButton);\r\n          var moduleb = tryGetModuleN(event.button);\r\n\r\n          if (modulea && moduleb) try {\r\n            var connected = modulea.toggleOutput(moduleb);\r\n            myHardware.sendScreenB((connected ? RARROW : \"X\") + moduleb.name);\r\n          } catch (e) {\r\n            console.error(e);\r\n            myHardware.sendScreenB(\"X\");\r\n          }\r\n          updateLeds();\r\n\r\n        }\r\n        if (muteMode) {\r\n          selectedInterface.controlledModule.mute = (false == selectedInterface.controlledModule.mute);\r\n\r\n        } else if (deleteMode) {\r\n          if (environment.modules.removeModuleN(event.button)) {\r\n            modules.list.splice(event.button, 1);\r\n            selectedInterface = false;\r\n            selectedModule = false;\r\n          }\r\n        } else {}\r\n        updateLeds();\r\n        if (!selectedInterface) {\r\n          selectedInterface = false;\r\n          if (event.data[0] == modules.list.length) myModuleCreator.engage();\r\n        } else {\r\n\r\n        }\r\n      } else {\r\n        engagedInterface.matrixButtonPressed(event);\r\n        matrixButtonOwners[event.data[0]] = engagedInterface;\r\n      }\r\n\r\n    });\r\n    this.on('matrixButtonReleased', function(event) {\r\n      if (firstPressedMatrixButton === event.data[0]) {\r\n        firstPressedMatrixButton = false;\r\n      }\r\n      // event.button=event.data[0];\r\n      if (matrixButtonOwners[event.data[0]]) {\r\n        matrixButtonOwners[event.data[0]].matrixButtonReleased(event);\r\n        delete matrixButtonOwners[event.data[0]];\r\n      } else {}\r\n    });\r\n    this.on('matrixButtonHold', function(event) {\r\n      //  event.button=event.data[0];\r\n      if (matrixButtonOwners[event.data[0]]) {\r\n        matrixButtonOwners[event.data[0]].matrixButtonHold(event);\r\n      } else {}\r\n    });\r\n    this.on('bottomButtonPressed', function(event) {\r\n      if (engagedInterface) {\r\n        // engagedInterface.disengage(event);\r\n        // console.log(engagedInterface.controlledModule.outputs[event.data[0]-8]);\r\n        // engagedInterface.controlledModule.inputs[event.data[0]].engage();\r\n      }\r\n    });\r\n    this.on('bottomButtonReleased', function(event) {\r\n      if (engagedInterface) {\r\n        // engagedInterface.controlledModule.outputs[event.data[0]-8].disengage();\r\n        // engagedInterface.engage(event);\r\n      }\r\n    });\r\n    this.on('selectorButtonPressed', function(event) {\r\n      //if the button is the patchMenu button}\r\n      //  console.log(event.button);\r\n      if (event.button == 0) {\r\n        if (engagedInterface) {\r\n          engagedInterface.disengage(event);\r\n          thisInteractor.engage();\r\n        }\r\n      } else {\r\n        //  event.button=event.data[0];\r\n        if (engagedInterface) {\r\n          engagedInterface.selectorButtonPressed(event);\r\n          selectorButtonOwners[event.data[0]] = engagedInterface;\r\n        } else {\r\n          if (event.button == 6) {\r\n            // deleteMode=!deleteMode;\r\n            deleteMode = true;\r\n            // console.log(\"DEL\",deleteMode);\r\n            // console.log(\"DEL\");\r\n            updateHardware();\r\n          } else if (event.button == 5) {\r\n            // muteMode=!muteMode;\r\n            muteMode = true;\r\n            // console.log(\"DEL\");\r\n            updateHardware();\r\n          } else {\r\n            thisInteractor.engage(event);\r\n          }\r\n        }\r\n      }\r\n    });\r\n    this.on('selectorButtonReleased', function(event) {\r\n      // event.button=event.data[0];\r\n      if (deleteMode || muteMode) {\r\n        if (event.button == 6 || event.button == 5) {\r\n          deleteMode = false;\r\n          muteMode = false;\r\n        }\r\n      } else if (selectorButtonOwners[event.data[0]]) {\r\n        selectorButtonOwners[event.data[0]].selectorButtonReleased(event);\r\n        delete selectorButtonOwners[event.data[0]];\r\n      } else {\r\n        {\r\n          var newCreated = false;\r\n          if (myModuleCreator.engaged) newCreated = myModuleCreator.disengage();\r\n          if (newCreated){\r\n            selectedInterface = newCreated.interface;\r\n            selectedModuleNumber=newCreated.number;\r\n            selectedModule=newCreated.module;\r\n          };\r\n          if (selectedInterface) {\r\n            engagedInterface = selectedInterface;\r\n            // console.log(\"engaged\",engagedInterface);\r\n            selectedInterface.engage(event);\r\n          }\r\n        }\r\n\r\n        if (!engagedInterface)\r\n          updateHardware();\r\n      }\r\n    });\r\n    this.on('encoderPressed', function(event) {\r\n      if (!engagedInterface) {} else {\r\n        engagedInterface.encoderPressed(event);\r\n      }\r\n    });\r\n    this.on('encoderReleased', function(event) {\r\n      if (!engagedInterface) {} else {\r\n        engagedInterface.encoderReleased(event);\r\n      }\r\n    });\r\n    this.on('encoderScrolled', function(event) {\r\n      if (!engagedInterface) {} else {\r\n        engagedInterface.encoderScrolled(event);\r\n      }\r\n    });\r\n    this.engage = function(evt) {\r\n      updateHardware();\r\n      engagedInterface = false;\r\n    }\r\n\r\n    function updateHardware() {\r\n      if (muteMode) {\r\n        myHardware.sendScreenA(\"Mute module\");\r\n      } else if (deleteMode) {\r\n        myHardware.sendScreenA(\"Delete module!\");\r\n      } else {\r\n        myHardware.sendScreenA(\"Select module\");\r\n      }\r\n      myHardware.sendScreenB((selectedModule ? selectedModule.name : \"none\") + \"\");\r\n      updateLeds();\r\n    }\r\n\r\n    function updateLeds() {\r\n      var outputsBmp = 0;\r\n      var mutedBitmap = 0;\r\n      //calculate bitmap for muted modules\r\n      for (let a in modules.list) {\r\n        let amodule = modules.list[a];\r\n        if (amodule.mute) mutedBitmap |= 1 << a;\r\n      }\r\n      if (selectedModule) {\r\n        //displaying the selected module output is rather awkward:\r\n        //for each output of the module that the interface controls\r\n        // console.log(selectedInterface.controlledModule.outputs)\r\n        for (var siOpts of selectedModule.outputs) {\r\n          //we add a bit to the array position of the interactor that iterated output module has\r\n          outputsBmp |= 1 << modules.list.indexOf(siOpts);\r\n        }\r\n      }\r\n\r\n      var creatorBtn = 1 << (modules.list.length);\r\n      var selectable = ~(0xffff << modules.list.length);\r\n\r\n      var selectedBmp = (selectedModule?1 << selectedModuleNumber:0);\r\n\r\n      myHardware.draw([\r\n        (selectedBmp | outputsBmp) ^ mutedBitmap,\r\n        (selectedBmp | creatorBtn),\r\n        (selectedBmp | (selectable ^ outputsBmp)) | creatorBtn\r\n      ]);\r\n    }\r\n\r\n\r\n    function tryGetModuleN(number) {\r\n      if (number < modules.list.length) {\r\n        return modules.list[number];\r\n      }\r\n      return false;\r\n    }\r\n    function tryGetInterfaceN(number) {\r\n      if (number < modules.list.length) {\r\n        //the module interactor is instnced by the superInteractor, hence, each module could have one interactor instance per each hardware that is connected. This would allow more independent control of modules.\r\n        var moduleInstance=modules.list[number];\r\n        if (moduleInstance._instancedInterfaces.X16){\r\n          return moduleInstance._instancedInterfaces.X16;\r\n        }else{\r\n          if (moduleInstance.interfaces.X16) {\r\n            // console.log(\"GET INTERFACE\",modules.list[number].interfaces.X16);\r\n            moduleInstance._instancedInterfaces.X16 = new moduleInstance.interfaces.X16(moduleInstance,environment);\r\n            return moduleInstance._instancedInterfaces.X16;\r\n          } else {\r\n            console.log(moduleInstance.name, \" had no interfaces.X16 property\");\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = SuperInteractorsSingleton;\n\n//# sourceURL=webpack://environment/./src/interaction/x16basic/superInteractor.js?");

/***/ }),

/***/ "./src/interaction/x28basic/IoView.js":
/*!********************************************!*\
  !*** ./src/interaction/x28basic/IoView.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Base=__webpack_require__(/*! ./interactorBase.js */ \"./src/interaction/x28basic/interactorBase.js\");\r\nvar IoView=function(hardware,environment){\r\n  this.engaged=false;\r\n  var self=this;\r\n  Base.call(this);\r\n\r\n  //   module <---> num <---> button\r\n  var buttonToNum=[\r\n    undefined,        6,        7,        8,\r\n            0,undefined,        9,       10,\r\n            1,        3,undefined,       11,\r\n            2,        4,        5,undefined,\r\n  ]\r\n\r\n  var numToButton=[];\r\n  var numToModule=[];\r\n  var selectedModule=false;\r\n  var centeredModule=false;\r\n  for(var a=0; a<6; a++){\r\n    var ntb=buttonToNum.indexOf(a);\r\n    numToButton=ntb;\r\n  }\r\n  function centerAroundModule(module){\r\n    centeredModule=module;\r\n    var i=Array.from(module.inputs);\r\n    var o=Array.from(module.outputs);\r\n    while(i.length<6) i.push(undefined);\r\n    numToModule=i.concat(o);\r\n    self.updateHardware();\r\n  }\r\n  function getModuleAtButton(button) {\r\n    var num=undefined;\r\n    num=buttonToNum[button];\r\n    if(num!==undefined) return numToModule[num];\r\n    return centeredModule;//default to selectedModule\r\n  }\r\n  function getButtonOfModule(module) {\r\n    var num=numToModule.indexOf(module);\r\n    if(num!==-1){\r\n      return numToButton[num]?numToButton[num]:0;//default to button 0\r\n    }\r\n    return 0;//default to button 0\r\n  }\r\n  this.selectModule=function(module){\r\n    selectedModule=module;\r\n    centerAroundModule(selectedModule);\r\n  }\r\n  this.engage=function(event){\r\n    self.updateHardware();\r\n    self.engaged=true;\r\n  }\r\n  this.disengage=function(event){\r\n    self.engaged=false;\r\n  }\r\n  this.updateHardware=function(){\r\n    self.updateLeds();\r\n    self.updateScreen();\r\n  }\r\n  this.updateLeds=function(){\r\n    hardware.clear();\r\n    let lowLight = environment.vars.light;\r\n\r\n    for (let button = 0; button < 16; button++) {\r\n      var bmodule = getModuleAtButton(button);\r\n      if (bmodule) {\r\n        var posBmp = 1 << button;\r\n        var color = [0, 0, 127];\r\n        if (bmodule.color) {\r\n          color = bmodule.color;\r\n        }\r\n\r\n        if (bmodule.mute) {\r\n          color = panton.mixColors(panton.disabled, color, 0.4);\r\n          color = panton.homogenize(color, lowLight / 16);\r\n        } else {\r\n          color = panton.homogenize(color, lowLight);\r\n        }\r\n\r\n        if (selectedModule == bmodule) {\r\n          color = panton.homogenize(color, Math.min((lowLight << 2), 0xff));\r\n        }\r\n\r\n        hardware.drawColor(posBmp, color);\r\n      }\r\n    }\r\n  }\r\n  this.updateScreen=function(){\r\n    hardware.sendScreenB(selectedModule.name+\"\");\r\n  }\r\n\r\n  this.matrixButtonPressed=function(event){\r\n    var btnInt=getModuleAtButton(event.button);\r\n    if(btnInt){\r\n      selectedModule=btnInt;\r\n    }\r\n    self.updateHardware();\r\n  };\r\n  this.matrixButtonReleased=function(event){\r\n  };\r\n  this.matrixButtonHold=function(event){};\r\n  this.matrixButtonVelocity=function(event){};\r\n  this.selectorButtonPressed=function(event){};\r\n  this.selectorButtonReleased=function(event){};\r\n  this.encoderScrolled=function(event){};\r\n  this.encoderPressed=function(event){};\r\n  this.encoderReleased=function(event){};\r\n}\r\nmodule.exports=IoView;\r\n\n\n//# sourceURL=webpack://environment/./src/interaction/x28basic/IoView.js?");

/***/ }),

/***/ "./src/interaction/x28basic/ModuleCreator.js":
/*!***************************************************!*\
  !*** ./src/interaction/x28basic/ModuleCreator.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar panton = __webpack_require__(/*! ./panton */ \"./src/interaction/x28basic/panton.js\");\r\n/**\r\n *Tiny pseudo-interactor that is used to choose what module to isntantiate when we press on an empty slot of the \"patchboard\" (i.e. button that is not lid)\r\n */\r\nfunction ModuleCreator(myHardware, environment) {\r\n  var possibleModules = [];\r\n  var possibleModulesBitmap = 0;\r\n  var possibleModuleConstructors = {};\r\n  var colors = [];\r\n  var moduleToCreateOnDisengage = false;\r\n  var lastMatrixButton = false;\r\n  this.invokerButton = 0;\r\n  var page = 0;\r\n  var pages = 0;\r\n  var modules = environment.modules;\r\n  this.engaged = false;\r\n  var self = this;\r\n  function updatePossibleModulesList() {\r\n    possibleModuleConstructors = environment.modules.getRegistered();\r\n    possibleModules = Object.keys(possibleModuleConstructors);\r\n    possibleModulesBitmap = ~(0xffff << possibleModules.length);\r\n    for (var mnum in possibleModules) {\r\n      var mname = possibleModules[mnum];\r\n      var iscolor = possibleModuleConstructors[mname].color;\r\n      console.log(mname, \"module color\", iscolor);\r\n      if (!iscolor) {\r\n        iscolor = [25, 25, 25];\r\n      }\r\n      colors[mnum] = iscolor;\r\n    }\r\n    pages = Math.ceil(possibleModules.length / 16);\r\n    console.log(\"pages\", pages);\r\n  }\r\n\r\n  function updateHardware() {\r\n    myHardware.sendScreenA(\"+ module (p.\" + page + \")\");\r\n    var head = 0;\r\n    myHardware.draw([possibleModulesBitmap | head, 0 | head, possibleModulesBitmap | head]);\r\n    paintModuleColors();\r\n    var pageLed = 1 << (page + 4);\r\n    var exitLed = 1 << 2;\r\n    var doLed = 1 << 3;\r\n    pageLed &= 0xf << 4;\r\n    exitLed &= 0xf;\r\n    doLed &= 0xf;\r\n    myHardware.drawSelectors([exitLed | doLed | pageLed, doLed | pageLed, pageLed]);\r\n\r\n    if (lastMatrixButton) head = 1 << lastMatrixButton;\r\n  }\r\n  function paintModuleColors() {\r\n    myHardware.clear()\r\n    let lowLight = environment.vars.light;\r\n    var offset = page * 16;\r\n    for (let button = 0; button < 16; button++) {\r\n      var color = colors[button + offset];\r\n      console.log(color, button);\r\n      if (color) {\r\n        var posBmp = 1 << button;\r\n        color = panton.homogenize(color, button === lastMatrixButton ? lowLight * 5 / 3 : lowLight * 2 / 3);\r\n        myHardware.drawColor(posBmp, color);\r\n      }\r\n    }\r\n  }\r\n  this.engage = function (event, buttonLoc) {\r\n    if (possibleModules.length == 0) updatePossibleModulesList();\r\n    updateHardware();\r\n    self.invokerButton = buttonLoc;\r\n    self.engaged = true;\r\n  }\r\n  this.disengage = function () {\r\n    var ret = moduleToCreateOnDisengage;\r\n    self.engaged = false;\r\n    return ret;\r\n  }\r\n  this.matrixButtonPressed = function (evt) {\r\n    lastMatrixButton = evt.button;\r\n    var offset = page * 16;\r\n    if (evt.data[0] + offset < possibleModules.length) {\r\n      moduleToCreateOnDisengage = possibleModules[evt.data[0] + offset];\r\n      myHardware.sendScreenA(\"Release to create\");\r\n      myHardware.sendScreenB(\"+\" + moduleToCreateOnDisengage);\r\n    } else {\r\n      moduleToCreateOnDisengage = false;\r\n      this.disengage();\r\n    }\r\n    updateHardware();\r\n  }\r\n  this.matrixButtonReleased = function (evt) { }\r\n  this.selectorButtonPressed = function (event) {\r\n    console.log(\"CSEL\");\r\n    if (event.button > 3 && event.button < 8) {\r\n      page = (event.button - 4) % (pages || 1);\r\n      console.log(page, pages, event.button);\r\n      updateHardware();\r\n    }\r\n  }\r\n  this.selectorButtonReleased = function (event) { }\r\n}\r\nmodule.exports = ModuleCreator;\n\n//# sourceURL=webpack://environment/./src/interaction/x28basic/ModuleCreator.js?");

/***/ }),

/***/ "./src/interaction/x28basic/index.js":
/*!*******************************************!*\
  !*** ./src/interaction/x28basic/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar myInteractorBase=__webpack_require__(/*! ./interactorBase.js */ \"./src/interaction/x28basic/interactorBase.js\");\r\nvar SuperInteractorSingleton=__webpack_require__(/*! ./superInteractor.js */ \"./src/interaction/x28basic/superInteractor.js\");\r\n/**\r\neach hardware needs a interface definition. The interface definition is instanced only once per run, and there is one different interface per each hardware. The interface instances the SuperInteractorSingleton, and provides the SuperInteractor constructor to the {@link interactionManager}. This avoids having to load one interactorBase, and one SuperInteractor for each different hardware that could exist.\r\n*/\r\nmodule.exports=(function(environment){\r\n  /**\r\n  definition of the base for interactors to be .called(this) on every interactor\r\n  */\r\n  this.interactorBase=myInteractorBase;\r\n  /**\r\n  my SuperInteractor singleton\r\n  */\r\n  this.superInteractorSingleton=new SuperInteractorSingleton(environment);\r\n  this.SuperInteractor=this.superInteractorSingleton.SuperInteractor;\r\n})\n\n//# sourceURL=webpack://environment/./src/interaction/x28basic/index.js?");

/***/ }),

/***/ "./src/interaction/x28basic/interactorBase.js":
/*!****************************************************!*\
  !*** ./src/interaction/x28basic/interactorBase.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar InteractorBase=__webpack_require__(/*! ../Interactor.js */ \"./src/interaction/Interactor.js\");\r\n/**\r\n base template for interactors when they are x16basic compatible\r\n*/\r\nvar x28InteractorBase=function(controlledModule){\r\n  var thisInteractor=this;\r\n\r\n  var thisInteractor=this;\r\n  this.controlledModule=controlledModule;\r\n  InteractorBase.call(this,controlledModule);\r\n  this.compatibilityTags=[\"x28v0\"];\r\n  this.buttonLocation=false;\r\n  // console.log(\".....\",this.compatibilityTags);\r\n  this.matrixButtonPressed=function(event){};\r\n  this.matrixButtonReleased=function(event){};\r\n  this.matrixButtonHold=function(event){};\r\n  this.matrixButtonVelocity=function(event){};\r\n  this.selectorButtonPressed=function(event){};\r\n  this.selectorButtonReleased=function(event){};\r\n  this.encoderScrolled=function(event){};\r\n  this.encoderPressed=function(event){};\r\n  this.encoderReleased=function(event){};\r\n  this.engage=function(event){};\r\n  this.disengage=function(event){}\r\n  this.outsideScroll=function(event){};\r\n}\r\nmodule.exports=x28InteractorBase;\r\n\n\n//# sourceURL=webpack://environment/./src/interaction/x28basic/interactorBase.js?");

/***/ }),

/***/ "./src/interaction/x28basic/panton.js":
/*!********************************************!*\
  !*** ./src/interaction/x28basic/panton.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("panton = {\r\n  disabled: [10, 7, 11],\r\n  selected: [255, 255, 255],\r\n  connected: [190, 0, 0],\r\n  isInput: [0, 190, 190],\r\n  black: [0, 0, 0]\r\n}\r\n\r\nfunction interpol(x, x0, y0, x1, y1) {\r\n  return y0 * (1 - x) + y1 * (x - 0);\r\n}\r\npanton.mixColors = function(cola, colb, lerp = 0.5) {\r\n  var retCol = [];\r\n  if (lerp <= 0) return cola;\r\n  if (lerp >= 1) return colb;\r\n  for (let c = 0; c < 3; c++) {\r\n    // retCol[c]=interpol(lerp,0,cola[c],1,colb[c]);\r\n    retCol[c] = Math.round(cola[c] + (colb[c] - cola[c]) * lerp);\r\n  }\r\n  return retCol;\r\n}\r\npanton.homogenize = function(color, targetValue) {\r\n  // var ret = [];\r\n  // var values = [0.26, 0.39, 0.45];\r\n  // var currentValue = ((color[0] * values[0]) + (color[1] * values[1]) + (color[2] * values[2]));\r\n  // var factor = targetValue / currentValue;\r\n  // for (var a in color) {\r\n  //   ret[a] = color[a] * factor;\r\n  // }\r\n  let hsl = rgbToHsl(color[0],color[1],color[2]);\r\n  // console.log(hsl);\r\n  hsl[2]=targetValue/255;\r\n  let ret = hslToRgb(hsl[0],hsl[1],hsl[2]);\r\n\r\n  return ret;\r\n}\r\n\r\n\r\nfunction hslToRgb(h, s, l) {\r\n  var r, g, b;\r\n\r\n  if (s == 0) {\r\n    r = g = b = l; // achromatic\r\n  } else {\r\n    var hue2rgb = function hue2rgb(p, q, t) {\r\n      if (t < 0) t += 1;\r\n      if (t > 1) t -= 1;\r\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\r\n      if (t < 1 / 2) return q;\r\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\r\n      return p;\r\n    }\r\n\r\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n    var p = 2 * l - q;\r\n    r = hue2rgb(p, q, h + 1 / 3);\r\n    g = hue2rgb(p, q, h);\r\n    b = hue2rgb(p, q, h - 1 / 3);\r\n  }\r\n\r\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\r\n}\r\n\r\nfunction rgbToHsl(r, g, b) {\r\n  r /= 255, g /= 255, b /= 255;\r\n  var max = Math.max(r, g, b),\r\n    min = Math.min(r, g, b);\r\n  var h, s, l = (max + min) / 2;\r\n\r\n  if (max == min) {\r\n    h = s = 0; // achromatic\r\n  } else {\r\n    var d = max - min;\r\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n    switch (max) {\r\n      case r:\r\n        h = (g - b) / d + (g < b ? 6 : 0);\r\n        break;\r\n      case g:\r\n        h = (b - r) / d + 2;\r\n        break;\r\n      case b:\r\n        h = (r - g) / d + 4;\r\n        break;\r\n    }\r\n    h /= 6;\r\n  }\r\n\r\n  return [h, s, l];\r\n}\r\n\r\nmodule.exports = panton;\n\n//# sourceURL=webpack://environment/./src/interaction/x28basic/panton.js?");

/***/ }),

/***/ "./src/interaction/x28basic/superInteractor.js":
/*!*****************************************************!*\
  !*** ./src/interaction/x28basic/superInteractor.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar RARROW = String.fromCharCode(199);\r\nvar XMARK = String.fromCharCode(183);\r\nvar panton = __webpack_require__(/*! ./panton */ \"./src/interaction/x28basic/panton.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../../modules/x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar IoView=__webpack_require__(/*! ./IoView.js */ \"./src/interaction/x28basic/IoView.js\");\r\n/**\r\nDefinition of hardware specific translations of hardware events into internal events\r\nthings such as \"when the user press a button\" become \"view the sequencer user interface\"\r\n\r\nA superInteractor defines the main context for the interactors of the specific hardware. A superinteractor is the entry point to any of the other interfaces. For instance, if somebody created a hardware that is designed only for one specific module, the superinteractor would be in charge of routing the compatible module to that hardware device. If the module is supposed to be able to create and route modules (like in this case), a superinteractor defines the user interaction patterns of how the modules are created; and how one switches between interface.\r\n*/\r\nmodule.exports = {};\r\nvar onHandlers = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\n\r\nvar ModuleCreator = __webpack_require__(/*! ./ModuleCreator */ \"./src/interaction/x28basic/ModuleCreator.js\");\r\n\r\n/**\r\n * @constructor\r\n * singleton\r\n * @param {environment} input to pass the environment. Needed to access the modulesMan, for things such as adding modules, jumping to modules, etc.\r\n */\r\nvar SuperInteractorsSingleton = function (environment) {\r\n  /**\r\n  * @constructor\r\n  * Super interactor instance: one per connected ui. hardware\r\n  * X16SuperInteractor a {@link superInteractor} prototype for x16basic {@link HardwareDriver}.\r\n  * @param {x16Hardware}\r\n  * @returns {undefined} no return\r\n  */\r\n  var modules = environment.modules;\r\n  environment.on('+modulesManager', function (man) {\r\n    modules = man;\r\n  });\r\n  // fail();\r\n  //contains the module that is accessible through each button\r\n  var moduleLocations = [];\r\n\r\n  //function to transform a number to module\r\n  function tryGetModuleInLoc(location) {\r\n    if (location < 0) { console.warn(`tryGetModuleInLoc(${location})`); return false };\r\n    var ret = false;\r\n    if (moduleLocations[location]) {\r\n      ret = moduleLocations[location][moduleLocations[location].length - 1];\r\n    }\r\n    return ret;\r\n  }\r\n  function tryGetLocOfModule(module) {\r\n    for (var x in moduleLocations) {\r\n      for (var y in moduleLocations[x]) {\r\n        if (moduleLocations[x][y] === module) {\r\n          //console.log(`get location = ${x}(${y})`);\r\n          return x;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function addModuleToLoc(module, location) {\r\n    if (location < 0) { console.warn(\"loc is\", location); return false };\r\n    if (moduleLocations[location]) {\r\n      var len = moduleLocations[location].push(module);\r\n      //console.log(`module in location ${location},${len-1}`);\r\n    } else {\r\n      moduleLocations[location] = [module];\r\n      //console.log(`module in location ${location},0`);\r\n\r\n    }\r\n  };\r\n  function delocateModule(module) {\r\n    for (var x in moduleLocations) {\r\n      var locy = false;\r\n      for (var y in moduleLocations[x]) {\r\n        if (moduleLocations[x][y] === module) {\r\n          locy = y;\r\n          break;\r\n        }\r\n      }\r\n      if (locy !== false) moduleLocations[x].splice(locy, 1);\r\n      if (moduleLocations[x])\r\n        if (moduleLocations[x].length == 0) {\r\n          delete moduleLocations[x];\r\n        }\r\n    }\r\n  }\r\n  function moveModuleToLoc(module, location) {\r\n    console.log(\"move module\", module.name, \"to\", location);\r\n    delocateModule(module);\r\n    addModuleToLoc(module, location);\r\n  }\r\n  environment.on('-module', function (event) {\r\n\r\n    for (var x in moduleLocations) {\r\n      for (var y in moduleLocations[x]) {\r\n        if (moduleLocations[x][y] === event.module) {\r\n          if (moduleLocations[x].length == 1) {\r\n            moduleLocations[x] = undefined;\r\n          } else {\r\n            moduleLocations[x].splice(y, 1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n  var defaultButtonForNewModule = 0;\r\n  environment.on('+module', function (event) {\r\n    if (tryGetLocOfModule(event.module) === undefined) {\r\n      console.log(\"superinteractor add loc\");\r\n\r\n      if (event.properties.loc){\r\n        defaultButtonForNewModule=event.properties.loc;\r\n      }\r\n\r\n      addModuleToLoc(event.module, defaultButtonForNewModule);\r\n      defaultButtonForNewModule++;\r\n\r\n    } else {\r\n      console.log(\"new module already has loc\");\r\n    }\r\n  });\r\n\r\n  function tryGetModuleInterface(moduleInstance) {\r\n    var ret = false;\r\n    if (moduleInstance) {\r\n      if (moduleInstance._instancedInterfaces) {\r\n        if (moduleInstance._instancedInterfaces.X28) {\r\n          ret = moduleInstance._instancedInterfaces.X28;\r\n        } else {\r\n          if (moduleInstance.interfaces.X28) {\r\n            moduleInstance._instancedInterfaces.X28 = new moduleInstance.interfaces.X28(moduleInstance, environment);\r\n            ret = moduleInstance._instancedInterfaces.X28;\r\n          } else if (moduleInstance.interfaces.X16) {\r\n            moduleInstance._instancedInterfaces.X28 = new moduleInstance.interfaces.X16(moduleInstance, environment);\r\n            ret = moduleInstance._instancedInterfaces.X28;\r\n          } else {\r\n            console.log(moduleInstance.name, \" had no interfaces.X28 property nor interfaces.X16 property\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  this.SuperInteractor = function (myHardware) {\r\n\r\n    var pageOffset = 0;\r\n\r\n    /** @private @var engagedInterface stores the module that is currently engaged, the interaction events are forwarded to the {@link moduleInterface} that is referenced here*/\r\n\r\n    var muteMode = false;\r\n    var deleteMode = false;\r\n    var pageMode = false;\r\n    var inputsMode = false;\r\n    var deleteList = new Set();\r\n    /** @private @var selectedInterface stores the {@link moduleInterface} that will become engaged once the patching button is released / the superInteractor disengaged.\r\n    selectedInterface is also subject to patching\r\n    */\r\n    var selectedModule = false;\r\n    var selectedInterface = false;\r\n    var engageOnRelease = false;\r\n    var selectedModuleLoc = false;\r\n    /**\r\n    keeps the interface that is currently engaged\r\n    */\r\n    var engagedInterface = false;\r\n    var thisInteractor = this;\r\n\r\n    /** store what are the modules over which a button was pressed\r\n    this allows to switch to another module and still detect the\r\n    release in the module where the button was pressed. Furthermore,\r\n    if we are using some sort of expression out of the pressure sensing,\r\n    we can assign it to the module where it was pressed\r\n    @private @var matrixButtonOwners={};\r\n    @private @var selectorButtonOwners={};\r\n    */\r\n    var matrixButtonOwners = {};\r\n    var selectorButtonOwners = {};\r\n\r\n    //for the matrix button pressed event, it indicates if this is the only matrix button that is pressed or not (allows selecting a module's outputs)\r\n    var firstPressedMatrixLoc = false;\r\n    var firstPressedMatrixButton = false;\r\n    onHandlers.call(this);\r\n    var myModuleCreator = new ModuleCreator(myHardware, environment);\r\n    var myIoView=new IoView(myHardware, environment);\r\n\r\n    let enviroVars = {}\r\n    for (var a in environment.vars) {\r\n      enviroVars[a] = {\r\n        enviroVarName: a,\r\n        value: environment.vars[a]\r\n      }\r\n      let thisEnviroVar = enviroVars[a];\r\n      thisEnviroVar.selectFunction = thisEnviroVar.changeFunction = function (thisVar, delta) {\r\n        let envarn = thisEnviroVar.enviroVarName;\r\n        if (delta)\r\n          environment.vars[envarn] += delta;\r\n        thisVar.value = environment.vars[envarn];\r\n        updateLeds();\r\n      }\r\n    }\r\n    var enviroVarConfig = new BlankConfigurator(this, {\r\n      name: \"\",\r\n      vars: enviroVars\r\n    });\r\n    let lCompConfigurator = enviroVarConfig.vars[\"ambt. light\"];\r\n\r\n    this.on('interaction', function (event) {\r\n      if (engagedInterface) {\r\n        try {\r\n          engagedInterface.handle('interaction', event);\r\n        } catch (e) { console.error(e) };\r\n      }\r\n    });\r\n    environment.on('+module', function (evt) {\r\n      if (!(engagedInterface || myModuleCreator.engaged)) {\r\n        updateHardware();\r\n      }\r\n    });\r\n    environment.on('-module', function (evt) {\r\n      if (!(engagedInterface || myModuleCreator.engaged)) {\r\n        updateHardware();\r\n      }\r\n    });\r\n    this.on('matrixButtonPressed', function (event) {\r\n      var location = event.button + pageOffset;\r\n      if (location < 0) return false;\r\n      if (myModuleCreator.engaged) {\r\n        myModuleCreator.matrixButtonPressed(event);\r\n      }else if(engagedInterface) {\r\n\r\n        try {\r\n          engagedInterface.matrixButtonPressed(event);\r\n          matrixButtonOwners[event.data[0]] = engagedInterface;\r\n        } catch (e) { console.error(e) };\r\n\r\n\r\n      } else {\r\n        if (firstPressedMatrixLoc === false) {\r\n          selectedModule = tryGetModuleInLoc(location);\r\n          selectedInterface = tryGetModuleInterface(selectedModule);\r\n          selectedModuleLoc = (selectedModule ? location : false);\r\n          engageOnRelease = true;\r\n          firstPressedMatrixLoc = location;\r\n          firstPressedMatrixButton = event.button;\r\n          updateHardware();\r\n        } else {\r\n\r\n          var modulea = tryGetModuleInLoc(firstPressedMatrixLoc);\r\n          var moduleb = tryGetModuleInLoc(location);\r\n\r\n          if (modulea && moduleb) {\r\n            try {\r\n              var connected = modulea.toggleOutput(moduleb);\r\n              myHardware.sendScreenB((connected ? RARROW : XMARK) + moduleb.name);\r\n            } catch (e) {\r\n              console.error(e);\r\n              myHardware.sendScreenB(\"X\");\r\n              updateLeds();\r\n            }\r\n          } else if (modulea && moduleb === false) {\r\n            moveModuleToLoc(modulea, location);\r\n          }\r\n\r\n        }\r\n        if (!selectedModule) {\r\n          selectedModule = false;\r\n          myModuleCreator.engage(event, location);\r\n        } else {\r\n          if (muteMode) {\r\n            selectedModule.mute = (false == selectedModule.mute);\r\n            myHardware.sendScreenA(selectedModule.mute ? \"MUTED\" : \"Active\");\r\n\r\n          } else if (deleteMode) {\r\n            if (deleteList.has(selectedModule)) {\r\n              deleteList.delete(selectedModule);\r\n              selectedModule.mute = false;\r\n              myHardware.sendScreenA(\"don't delete\");\r\n            } else {\r\n              deleteList.add(selectedModule);\r\n              selectedModule.mute = true;\r\n              myHardware.sendScreenA(\"del on release\");\r\n            }\r\n            selectedModule = false;\r\n            selectedInterface = false;\r\n            selectedModuleLoc = false;\r\n\r\n          } else { }\r\n          updateLeds();\r\n        }\r\n      }\r\n\r\n    });\r\n    this.on('matrixButtonReleased', function (event) {\r\n      var location = event.button + pageOffset;\r\n      if (firstPressedMatrixButton === event.button) {\r\n        firstPressedMatrixLoc = false;\r\n        firstPressedMatrixButton = false;\r\n      }\r\n      // event.button=event.data[0];\r\n      if (matrixButtonOwners[event.data[0]]) {\r\n        try {\r\n          matrixButtonOwners[event.data[0]].matrixButtonReleased(event);\r\n        } catch (e) { console.error(e) };\r\n\r\n        delete matrixButtonOwners[event.data[0]];\r\n      } else { }\r\n    });\r\n    this.on('matrixButtonHold', function (event) {\r\n      //  event.button=event.data[0];\r\n      if (matrixButtonOwners[event.data[0]]) {\r\n        matrixButtonOwners[event.data[0]].matrixButtonHold(event);\r\n      } else { }\r\n    });\r\n    this.on('matrixButtonVelocity', function (event) {\r\n      // console.log(\"VELO\");\r\n      if (matrixButtonOwners[event.data[0]]) {\r\n        matrixButtonOwners[event.data[0]].matrixButtonVelocity(event);\r\n        // console.log(\"YES\",event.data);\r\n      } else {\r\n        // console.log(\"NO\",matrixButtonOwners);\r\n      }\r\n    });\r\n    this.on('bottomButtonPressed', function(event) {\r\n      // console.log(\"BBP\");\r\n      if (engagedInterface) {\r\n        if(typeof engagedInterface.bottomButtonPressed==\"function\")\r\n          engagedInterface.bottomButtonPressed(event);\r\n      }else{\r\n        if(event.data[0]==0){\r\n          pageOffset-=8;\r\n        }else{\r\n          pageOffset+=8;\r\n        }\r\n        if(pageOffset<0) pageOffset=0;\r\n        pageMode=true;\r\n        updateHardware();\r\n        paintSelectButtons();\r\n        pageMode=false;\r\n      }\r\n    });\r\n    this.on('bottomButtonReleased', function(event) {\r\n      if (engagedInterface) {\r\n        engagedInterface.bottomButtonReleased(event);\r\n      }\r\n    });\r\n    this.on('selectorButtonPressed', function (event) {\r\n      if (event.button == 3) {\r\n\r\n        if (engagedInterface) {\r\n          try {\r\n            engagedInterface.disengage(event);\r\n          } catch (e) { console.error(e) };\r\n\r\n          thisInteractor.engage();\r\n          engageOnRelease = false;\r\n        }\r\n      } else if (myModuleCreator.engaged) {\r\n        myModuleCreator.selectorButtonPressed(event);\r\n      } else {\r\n        //  event.button=event.data[0];\r\n        if (engagedInterface) {\r\n          try {\r\n            engagedInterface.selectorButtonPressed(event);\r\n          } catch (e) { console.error(e) };\r\n\r\n          selectorButtonOwners[event.data[0]] = engagedInterface;\r\n        } else {\r\n          if (event.button == 0) {\r\n            // inputsMode = true;\r\n            // updateHardware();\r\n            myIoView.engage(event);\r\n            myIoView.selectModule(selectedModule);\r\n            engagedInterface=myIoView;\r\n          } else if (event.button == 2) {\r\n            deleteList = new Set();\r\n            deleteMode = true;\r\n            updateHardware();\r\n          } else if (event.button == 1) {\r\n            // muteMode=!muteMode;\r\n            muteMode = true;\r\n            // console.log(\"DEL\");\r\n            updateHardware();\r\n          } else {\r\n            pageMode = true;\r\n            if (event.button >= 4) {\r\n              pageOffset = (event.button-4)*8;\r\n            }\r\n            updateHardware();\r\n            paintSelectButtons();\r\n          }\r\n        }\r\n      }\r\n    });\r\n    this.on('selectorButtonReleased', function (event) {\r\n      // event.button=event.data[0]\r\n      if (engagedInterface == enviroVarConfig) {\r\n        if (event.button == 0) {\r\n          enviroVarConfig.disengage(event);\r\n        }\r\n      } else if (deleteMode && event.button == 2) {\r\n        var del=0;\r\n        deleteList.forEach(function (item) {\r\n          del++;\r\n          console.log(\"DEL\", item.name);\r\n          if (modules.removeModule(item)) {\r\n            selectedModule = false;\r\n            selectedInterface = false;\r\n            selectedModuleLoc = false;\r\n          }\r\n        });\r\n        myHardware.sendScreenA(\"removed \"+(del?del:\"none\"));\r\n        deleteMode = false;\r\n      } else if (muteMode || pageMode || inputsMode) {\r\n        if (event.button == 2 || event.button == 1 || event.button == 0) {\r\n\r\n          muteMode = false;\r\n          inputsMode = false;\r\n        } else if (event.button < 8 && event.button > 3) {\r\n          pageMode = false;\r\n        }\r\n        updateHardware();\r\n      } else if (selectorButtonOwners[event.data[0]]) {\r\n        selectorButtonOwners[event.data[0]].selectorButtonReleased(event);\r\n        delete selectorButtonOwners[event.data[0]];\r\n      } else if (event.button == 3) {\r\n        var newCreated = false;\r\n        var create = false;\r\n        if (myModuleCreator.engaged) create = myModuleCreator.disengage();\r\n\r\n        if (create) {\r\n          var defaultProps = {};\r\n          environment.modules.instantiate(create, defaultProps, function (nmod) {\r\n            newCreated = nmod;\r\n            addModuleToLoc(newCreated, myModuleCreator.invokerButton);\r\n          });\r\n        }\r\n\r\n        //opens the just-created module.\r\n        // if (newCreated) {\r\n        //   selectedModule = newCreated;\r\n        //   selectedInterface = tryGetModuleInterface(newCreated);\r\n        // };\r\n\r\n        if (selectedInterface && engageOnRelease) {\r\n          engagedInterface = selectedInterface;\r\n          // console.log(\"engaged\",engagedInterface);\r\n          selectedInterface.engage(event);\r\n        }\r\n        engageOnRelease = true;\r\n\r\n        if (!engagedInterface)\r\n          updateHardware();\r\n      } else if (myModuleCreator.engaged && event.button == 2) {\r\n\r\n        if (myModuleCreator.engaged) {\r\n          console.log(\"cancel creation\");\r\n          myModuleCreator.disengage();\r\n          thisInteractor.engage();\r\n        }\r\n      } else if (myModuleCreator.engaged) {\r\n        myModuleCreator.selectorButtonReleased(event);\r\n      }else if(event.button==0 && myIoView.engaged){\r\n        myIoView.disengage(event);\r\n        engagedInterface=false;\r\n        updateHardware();\r\n      }\r\n    });\r\n    this.on('encoderPressed', function (event) {\r\n      if (engagedInterface) {\r\n        try {\r\n          engagedInterface.encoderPressed(event);\r\n        } catch (e) { console.error(e) };\r\n      } else {\r\n        // selectedModule = false;\r\n        // selectedInterface = false;\r\n        // selectedModuleLoc = false;\r\n        // updateHardware();\r\n      }\r\n    });\r\n    this.on('encoderReleased', function (event) {\r\n      if (!engagedInterface) { } else {\r\n        try {\r\n          engagedInterface.encoderReleased(event);\r\n        } catch (e) { console.error(e) };\r\n\r\n      }\r\n    });\r\n    this.on('encoderScrolled', function (event) {\r\n      if (!engagedInterface) {\r\n        if (selectedInterface) {\r\n          let str = selectedInterface.outsideScroll(event);\r\n          if (str) {\r\n            myHardware.sendScreenB(str);\r\n          }\r\n        } else {\r\n          var cpm=pageMode;\r\n          pageMode=true;\r\n          pageOffset += event.delta * 4;\r\n          if (pageOffset < 0) pageOffset = 0;\r\n          updateHardware();\r\n          paintSelectButtons();\r\n          pageMode=cpm;\r\n        }\r\n      } else {\r\n        try {\r\n          engagedInterface.encoderScrolled(event);\r\n        } catch (e) { console.error(e) };\r\n\r\n      }\r\n    });\r\n    this.engage = function (evt) {\r\n      paintSelectButtons();\r\n      updateHardware();\r\n      engagedInterface = false;\r\n    }\r\n\r\n    function updateHardware() {\r\n      if (muteMode) {\r\n        myHardware.sendScreenA(\"Mute module\");\r\n        myHardware.sendScreenB((selectedModule ? \"\" + selectedModule.name : \"none\") + \"\");\r\n\r\n      } else if (deleteMode) {\r\n        myHardware.sendScreenA(\"Delete module!\");\r\n        myHardware.sendScreenB((selectedModule ? \"\" + selectedModule.name : \"none\") + \"\");\r\n\r\n      } else if (pageMode) {\r\n        myHardware.sendScreenA(\"Set page\");\r\n        myHardware.sendScreenB(\"Page \" + (pageOffset / 16));\r\n      } else if (inputsMode) {\r\n        myHardware.sendScreenA(\"Watching inputs\");\r\n        myHardware.sendScreenB((selectedModule ? \"of \" + selectedModule.name : \"none\") + \"\");\r\n      } else {\r\n        myHardware.sendScreenA(\"Select module\");\r\n        myHardware.sendScreenB((selectedModule ? selectedModule.name : \"none\") + \"\");\r\n      }\r\n      updateLeds();\r\n    }\r\n\r\n    function updateLeds() {\r\n      var outputsBmp = 0;\r\n      var mutedBmp = 0;\r\n      myHardware.clear();\r\n      let lowLight = environment.vars.light;\r\n\r\n      // if (selectedModule && !inputsMode) {\r\n      //   for (var optIt of selectedModule.outputs) {\r\n      //     var loc=tryGetLocOfModule(optIt);\r\n      //     outputsBmp |= (loc!==undefined)? 1<<(loc) : 0;\r\n      //   }\r\n      // }\r\n\r\n      for (let button = 0; button < 16; button++) {\r\n\r\n        var location = button + pageOffset;\r\n        var bmodule = tryGetModuleInLoc(location);\r\n        if (bmodule) {\r\n          var posBmp = 1 << button;\r\n          var color = [0, 0, 127];\r\n\r\n          if (bmodule.color) {\r\n            color = bmodule.color;\r\n          }\r\n\r\n          if (bmodule.mute) {\r\n            color = panton.mixColors(panton.disabled, color, 0.4);\r\n            color = panton.homogenize(color, lowLight / 16);\r\n          } else {\r\n            color = panton.homogenize(color, lowLight);\r\n          }\r\n          if (selectedModule) {\r\n            if (inputsMode) {\r\n              if (bmodule.outputs.has(selectedModule)) {\r\n                color = panton.mixColors(panton.isInput, color, 0.5);\r\n              } else {\r\n                color = panton.mixColors(panton.disabled, color, 0.4);\r\n              }\r\n            } else {\r\n              if (selectedModule.outputs.has(bmodule)) {\r\n                color = panton.mixColors(panton.connected, color, 0.5);\r\n              }\r\n            }\r\n          }\r\n          if (outputsBmp & posBmp) {\r\n            color = panton.mixColors(panton.connected, color, 0.5);\r\n          }\r\n          if (selectedModuleLoc == location) {\r\n            color = panton.homogenize(color, Math.min((lowLight << 2), 0xff));\r\n          }\r\n\r\n\r\n          myHardware.drawColor(posBmp, color);\r\n        }\r\n        // }\r\n      }\r\n\r\n\r\n      // myHardware.draw([outputsBmp,0,0],false);\r\n      // myHardware.drawColor(1<<modules.list.length,[100,255,255]);\r\n\r\n\r\n      // myHardware.drawColor(outputsBmp & mutedBmp,panton.mixColors(panton.disabled,panton.connected));\r\n    }\r\n    var bpaint = {\r\n      patching: 1 << 3,\r\n      events: 1 << 1,\r\n      config: 1 << 2,\r\n      shift: 1,\r\n      // whites:0xf<<4,\r\n      // whites: 1 << (Math.round(pageOffset / 16) + 4)\r\n    }\r\n\r\n    function paintSelectButtons() {\r\n      bpaint.whites = 0x1 << (Math.round(pageOffset / 8) + 4)\r\n      // console.log(bpaint.whites);\r\n      bpaint.result = [\r\n        bpaint.patching | bpaint.events | bpaint.whites,\r\n        bpaint.patching | bpaint.shift | bpaint.whites,\r\n        bpaint.config | bpaint.events | bpaint.shift | bpaint.whites\r\n      ];\r\n      // bpaint.result = [bpaint.events, bpaint.events, bpaint.whites];\r\n      myHardware.drawSelectors(bpaint.result);\r\n    }\r\n\r\n  }\r\n};\r\n\r\nmodule.exports = SuperInteractorsSingleton;\r\n\n\n//# sourceURL=webpack://environment/./src/interaction/x28basic/superInteractor.js?");

/***/ }),

/***/ "./src/interaction/x8basic/index.js":
/*!******************************************!*\
  !*** ./src/interaction/x8basic/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Observable= __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nmodule.exports=function(a,b,c){\r\n\r\n    console.log(\"x8superinteractor singleton\",a,b,c);\r\n    this.SuperInteractor= function(hardware){\r\n        Observable.call(this);\r\n        \r\n        this.on(\"*\",function(evt){\r\n            // hardware.bitmap(0xCC);\r\n            console.log(\"HARDWARE\", hardware);\r\n            try {\r\n                hardware.bitmap(0xCC);\r\n            } catch (e) {\r\n                console.log(\"e\", e);\r\n            }\r\n        });\r\n        \r\n        this.engage=function(a){\r\n            console.log(a);\r\n            a.hardware.bitmap(0xCC);\r\n\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://environment/./src/interaction/x8basic/index.js?");

/***/ }),

/***/ "./src/modules sync recursive ^\\.\\/.*$":
/*!***********************************!*\
  !*** ./src/modules sync ^\.\/.*$ ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./Alteration\": \"./src/modules/Alteration/index.js\",\n\t\"./Alteration/\": \"./src/modules/Alteration/index.js\",\n\t\"./Alteration/InterfaceX16\": \"./src/modules/Alteration/InterfaceX16.js\",\n\t\"./Alteration/InterfaceX16.js\": \"./src/modules/Alteration/InterfaceX16.js\",\n\t\"./Alteration/index\": \"./src/modules/Alteration/index.js\",\n\t\"./Alteration/index.js\": \"./src/modules/Alteration/index.js\",\n\t\"./Arpeggiator\": \"./src/modules/Arpeggiator/index.js\",\n\t\"./Arpeggiator/\": \"./src/modules/Arpeggiator/index.js\",\n\t\"./Arpeggiator/InterfaceX16\": \"./src/modules/Arpeggiator/InterfaceX16.js\",\n\t\"./Arpeggiator/InterfaceX16.js\": \"./src/modules/Arpeggiator/InterfaceX16.js\",\n\t\"./Arpeggiator/Monosequence\": \"./src/modules/Arpeggiator/Monosequence.js\",\n\t\"./Arpeggiator/Monosequence.js\": \"./src/modules/Arpeggiator/Monosequence.js\",\n\t\"./Arpeggiator/index\": \"./src/modules/Arpeggiator/index.js\",\n\t\"./Arpeggiator/index.js\": \"./src/modules/Arpeggiator/index.js\",\n\t\"./Bouncer\": \"./src/modules/Bouncer/index.js\",\n\t\"./Bouncer/\": \"./src/modules/Bouncer/index.js\",\n\t\"./Bouncer/InterfaceX16\": \"./src/modules/Bouncer/InterfaceX16.js\",\n\t\"./Bouncer/InterfaceX16.js\": \"./src/modules/Bouncer/InterfaceX16.js\",\n\t\"./Bouncer/index\": \"./src/modules/Bouncer/index.js\",\n\t\"./Bouncer/index.js\": \"./src/modules/Bouncer/index.js\",\n\t\"./Bus\": \"./src/modules/Bus/index.js\",\n\t\"./Bus/\": \"./src/modules/Bus/index.js\",\n\t\"./Bus/index\": \"./src/modules/Bus/index.js\",\n\t\"./Bus/index.js\": \"./src/modules/Bus/index.js\",\n\t\"./CalculeitorMidi\": \"./src/modules/CalculeitorMidi/index.js\",\n\t\"./CalculeitorMidi/\": \"./src/modules/CalculeitorMidi/index.js\",\n\t\"./CalculeitorMidi/InterfaceX28\": \"./src/modules/CalculeitorMidi/InterfaceX28.js\",\n\t\"./CalculeitorMidi/InterfaceX28.js\": \"./src/modules/CalculeitorMidi/InterfaceX28.js\",\n\t\"./CalculeitorMidi/index\": \"./src/modules/CalculeitorMidi/index.js\",\n\t\"./CalculeitorMidi/index.js\": \"./src/modules/CalculeitorMidi/index.js\",\n\t\"./Chord\": \"./src/modules/Chord/index.js\",\n\t\"./Chord/\": \"./src/modules/Chord/index.js\",\n\t\"./Chord/InterfaceX28\": \"./src/modules/Chord/InterfaceX28.js\",\n\t\"./Chord/InterfaceX28.js\": \"./src/modules/Chord/InterfaceX28.js\",\n\t\"./Chord/index\": \"./src/modules/Chord/index.js\",\n\t\"./Chord/index.js\": \"./src/modules/Chord/index.js\",\n\t\"./ClockGenerator\": \"./src/modules/ClockGenerator/index.js\",\n\t\"./ClockGenerator/\": \"./src/modules/ClockGenerator/index.js\",\n\t\"./ClockGenerator/InterfaceX16\": \"./src/modules/ClockGenerator/InterfaceX16.js\",\n\t\"./ClockGenerator/InterfaceX16.js\": \"./src/modules/ClockGenerator/InterfaceX16.js\",\n\t\"./ClockGenerator/index\": \"./src/modules/ClockGenerator/index.js\",\n\t\"./ClockGenerator/index.js\": \"./src/modules/ClockGenerator/index.js\",\n\t\"./DelayClockBased\": \"./src/modules/DelayClockBased/index.js\",\n\t\"./DelayClockBased/\": \"./src/modules/DelayClockBased/index.js\",\n\t\"./DelayClockBased/InterfaceHttp\": \"./src/modules/DelayClockBased/InterfaceHttp.js\",\n\t\"./DelayClockBased/InterfaceHttp.js\": \"./src/modules/DelayClockBased/InterfaceHttp.js\",\n\t\"./DelayClockBased/InterfaceX16\": \"./src/modules/DelayClockBased/InterfaceX16.js\",\n\t\"./DelayClockBased/InterfaceX16.js\": \"./src/modules/DelayClockBased/InterfaceX16.js\",\n\t\"./DelayClockBased/index\": \"./src/modules/DelayClockBased/index.js\",\n\t\"./DelayClockBased/index.js\": \"./src/modules/DelayClockBased/index.js\",\n\t\"./FixNoteLen\": \"./src/modules/FixNoteLen/index.js\",\n\t\"./FixNoteLen/\": \"./src/modules/FixNoteLen/index.js\",\n\t\"./FixNoteLen/InterfaceX16\": \"./src/modules/FixNoteLen/InterfaceX16.js\",\n\t\"./FixNoteLen/InterfaceX16.js\": \"./src/modules/FixNoteLen/InterfaceX16.js\",\n\t\"./FixNoteLen/index\": \"./src/modules/FixNoteLen/index.js\",\n\t\"./FixNoteLen/index.js\": \"./src/modules/FixNoteLen/index.js\",\n\t\"./GameOfLife\": \"./src/modules/GameOfLife/index.js\",\n\t\"./GameOfLife/\": \"./src/modules/GameOfLife/index.js\",\n\t\"./GameOfLife/InterfaceX16\": \"./src/modules/GameOfLife/InterfaceX16.js\",\n\t\"./GameOfLife/InterfaceX16.js\": \"./src/modules/GameOfLife/InterfaceX16.js\",\n\t\"./GameOfLife/index\": \"./src/modules/GameOfLife/index.js\",\n\t\"./GameOfLife/index.js\": \"./src/modules/GameOfLife/index.js\",\n\t\"./Harmonizer\": \"./src/modules/Harmonizer/index.js\",\n\t\"./Harmonizer/\": \"./src/modules/Harmonizer/index.js\",\n\t\"./Harmonizer/InterfaceX28\": \"./src/modules/Harmonizer/InterfaceX28.js\",\n\t\"./Harmonizer/InterfaceX28.js\": \"./src/modules/Harmonizer/InterfaceX28.js\",\n\t\"./Harmonizer/index\": \"./src/modules/Harmonizer/index.js\",\n\t\"./Harmonizer/index.js\": \"./src/modules/Harmonizer/index.js\",\n\t\"./Harmonizer/old_InterfaceX28\": \"./src/modules/Harmonizer/old_InterfaceX28.js\",\n\t\"./Harmonizer/old_InterfaceX28.js\": \"./src/modules/Harmonizer/old_InterfaceX28.js\",\n\t\"./Harmonizer/scaleNameMaker\": \"./src/modules/Harmonizer/scaleNameMaker.js\",\n\t\"./Harmonizer/scaleNameMaker.js\": \"./src/modules/Harmonizer/scaleNameMaker.js\",\n\t\"./Harmonizer/scaleNames\": \"./src/modules/Harmonizer/scaleNames.js\",\n\t\"./Harmonizer/scaleNames.js\": \"./src/modules/Harmonizer/scaleNames.js\",\n\t\"./Knob\": \"./src/modules/Knob/index.js\",\n\t\"./Knob/\": \"./src/modules/Knob/index.js\",\n\t\"./Knob/InterfaceX28\": \"./src/modules/Knob/InterfaceX28.js\",\n\t\"./Knob/InterfaceX28.js\": \"./src/modules/Knob/InterfaceX28.js\",\n\t\"./Knob/index\": \"./src/modules/Knob/index.js\",\n\t\"./Knob/index.js\": \"./src/modules/Knob/index.js\",\n\t\"./MixxxCtl\": \"./src/modules/MixxxCtl/index.js\",\n\t\"./MixxxCtl/\": \"./src/modules/MixxxCtl/index.js\",\n\t\"./MixxxCtl/InterfaceX16\": \"./src/modules/MixxxCtl/InterfaceX16.js\",\n\t\"./MixxxCtl/InterfaceX16.js\": \"./src/modules/MixxxCtl/InterfaceX16.js\",\n\t\"./MixxxCtl/index\": \"./src/modules/MixxxCtl/index.js\",\n\t\"./MixxxCtl/index.js\": \"./src/modules/MixxxCtl/index.js\",\n\t\"./ModModify\": \"./src/modules/ModModify/index.js\",\n\t\"./ModModify/\": \"./src/modules/ModModify/index.js\",\n\t\"./ModModify/InterfaceX28\": \"./src/modules/ModModify/InterfaceX28.js\",\n\t\"./ModModify/InterfaceX28.js\": \"./src/modules/ModModify/InterfaceX28.js\",\n\t\"./ModModify/index\": \"./src/modules/ModModify/index.js\",\n\t\"./ModModify/index.js\": \"./src/modules/ModModify/index.js\",\n\t\"./MultiTape\": \"./src/modules/MultiTape/index.js\",\n\t\"./MultiTape/\": \"./src/modules/MultiTape/index.js\",\n\t\"./MultiTape/InterfaceX28\": \"./src/modules/MultiTape/InterfaceX28.js\",\n\t\"./MultiTape/InterfaceX28.js\": \"./src/modules/MultiTape/InterfaceX28.js\",\n\t\"./MultiTape/NoteLogger\": \"./src/modules/MultiTape/NoteLogger.js\",\n\t\"./MultiTape/NoteLogger.js\": \"./src/modules/MultiTape/NoteLogger.js\",\n\t\"./MultiTape/NoteOnTracker\": \"./src/modules/MultiTape/NoteOnTracker.js\",\n\t\"./MultiTape/NoteOnTracker.js\": \"./src/modules/MultiTape/NoteOnTracker.js\",\n\t\"./MultiTape/Tape\": \"./src/modules/MultiTape/Tape.js\",\n\t\"./MultiTape/Tape.js\": \"./src/modules/MultiTape/Tape.js\",\n\t\"./MultiTape/TapeCanvas\": \"./src/modules/MultiTape/TapeCanvas.js\",\n\t\"./MultiTape/TapeCanvas.js\": \"./src/modules/MultiTape/TapeCanvas.js\",\n\t\"./MultiTape/index\": \"./src/modules/MultiTape/index.js\",\n\t\"./MultiTape/index.js\": \"./src/modules/MultiTape/index.js\",\n\t\"./MultiTape/recorder\": \"./src/modules/MultiTape/recorder.js\",\n\t\"./MultiTape/recorder.js\": \"./src/modules/MultiTape/recorder.js\",\n\t\"./MultiTape/x28-ArrangementView\": \"./src/modules/MultiTape/x28-ArrangementView.js\",\n\t\"./MultiTape/x28-ArrangementView.js\": \"./src/modules/MultiTape/x28-ArrangementView.js\",\n\t\"./MultiTape/x28-SequenceView\": \"./src/modules/MultiTape/x28-SequenceView.js\",\n\t\"./MultiTape/x28-SequenceView.js\": \"./src/modules/MultiTape/x28-SequenceView.js\",\n\t\"./Narp\": \"./src/modules/Narp/index.js\",\n\t\"./Narp/\": \"./src/modules/Narp/index.js\",\n\t\"./Narp/HttpGui\": \"./src/modules/Narp/HttpGui.js\",\n\t\"./Narp/HttpGui.js\": \"./src/modules/Narp/HttpGui.js\",\n\t\"./Narp/InterfaceX16\": \"./src/modules/Narp/InterfaceX16.js\",\n\t\"./Narp/InterfaceX16.js\": \"./src/modules/Narp/InterfaceX16.js\",\n\t\"./Narp/index\": \"./src/modules/Narp/index.js\",\n\t\"./Narp/index.js\": \"./src/modules/Narp/index.js\",\n\t\"./Noise\": \"./src/modules/Noise/index.js\",\n\t\"./Noise/\": \"./src/modules/Noise/index.js\",\n\t\"./Noise/HttpGui\": \"./src/modules/Noise/HttpGui.js\",\n\t\"./Noise/HttpGui.js\": \"./src/modules/Noise/HttpGui.js\",\n\t\"./Noise/InterfaceX16\": \"./src/modules/Noise/InterfaceX16.js\",\n\t\"./Noise/InterfaceX16.js\": \"./src/modules/Noise/InterfaceX16.js\",\n\t\"./Noise/index\": \"./src/modules/Noise/index.js\",\n\t\"./Noise/index.js\": \"./src/modules/Noise/index.js\",\n\t\"./NoteSustainer\": \"./src/modules/NoteSustainer/index.js\",\n\t\"./NoteSustainer/\": \"./src/modules/NoteSustainer/index.js\",\n\t\"./NoteSustainer/InterfaceX16\": \"./src/modules/NoteSustainer/InterfaceX16.js\",\n\t\"./NoteSustainer/InterfaceX16.js\": \"./src/modules/NoteSustainer/InterfaceX16.js\",\n\t\"./NoteSustainer/index\": \"./src/modules/NoteSustainer/index.js\",\n\t\"./NoteSustainer/index.js\": \"./src/modules/NoteSustainer/index.js\",\n\t\"./Operator\": \"./src/modules/Operator/index.js\",\n\t\"./Operator/\": \"./src/modules/Operator/index.js\",\n\t\"./Operator/InterfaceX16\": \"./src/modules/Operator/InterfaceX16.js\",\n\t\"./Operator/InterfaceX16.js\": \"./src/modules/Operator/InterfaceX16.js\",\n\t\"./Operator/index\": \"./src/modules/Operator/index.js\",\n\t\"./Operator/index.js\": \"./src/modules/Operator/index.js\",\n\t\"./OscTest\": \"./src/modules/OscTest/index.js\",\n\t\"./OscTest/\": \"./src/modules/OscTest/index.js\",\n\t\"./OscTest/InterfaceX16\": \"./src/modules/OscTest/InterfaceX16.js\",\n\t\"./OscTest/InterfaceX16.js\": \"./src/modules/OscTest/InterfaceX16.js\",\n\t\"./OscTest/index\": \"./src/modules/OscTest/index.js\",\n\t\"./OscTest/index.js\": \"./src/modules/OscTest/index.js\",\n\t\"./PianoRoll\": \"./src/modules/PianoRoll/index.js\",\n\t\"./PianoRoll/\": \"./src/modules/PianoRoll/index.js\",\n\t\"./PianoRoll/InterfaceX28\": \"./src/modules/PianoRoll/InterfaceX28.js\",\n\t\"./PianoRoll/InterfaceX28.js\": \"./src/modules/PianoRoll/InterfaceX28.js\",\n\t\"./PianoRoll/TapeMem\": \"./src/modules/PianoRoll/TapeMem.js\",\n\t\"./PianoRoll/TapeMem.js\": \"./src/modules/PianoRoll/TapeMem.js\",\n\t\"./PianoRoll/index\": \"./src/modules/PianoRoll/index.js\",\n\t\"./PianoRoll/index.js\": \"./src/modules/PianoRoll/index.js\",\n\t\"./PresetKit\": \"./src/modules/PresetKit/index.js\",\n\t\"./PresetKit/\": \"./src/modules/PresetKit/index.js\",\n\t\"./PresetKit/InterfaceHttp\": \"./src/modules/PresetKit/InterfaceHttp.js\",\n\t\"./PresetKit/InterfaceHttp.js\": \"./src/modules/PresetKit/InterfaceHttp.js\",\n\t\"./PresetKit/InterfaceX16\": \"./src/modules/PresetKit/InterfaceX16.js\",\n\t\"./PresetKit/InterfaceX16.js\": \"./src/modules/PresetKit/InterfaceX16.js\",\n\t\"./PresetKit/index\": \"./src/modules/PresetKit/index.js\",\n\t\"./PresetKit/index.js\": \"./src/modules/PresetKit/index.js\",\n\t\"./RouteSequencer\": \"./src/modules/RouteSequencer/index.js\",\n\t\"./RouteSequencer/\": \"./src/modules/RouteSequencer/index.js\",\n\t\"./RouteSequencer/InterfaceHttp\": \"./src/modules/RouteSequencer/InterfaceHttp.js\",\n\t\"./RouteSequencer/InterfaceHttp.js\": \"./src/modules/RouteSequencer/InterfaceHttp.js\",\n\t\"./RouteSequencer/InterfaceX16\": \"./src/modules/RouteSequencer/InterfaceX16.js\",\n\t\"./RouteSequencer/InterfaceX16.js\": \"./src/modules/RouteSequencer/InterfaceX16.js\",\n\t\"./RouteSequencer/index\": \"./src/modules/RouteSequencer/index.js\",\n\t\"./RouteSequencer/index.js\": \"./src/modules/RouteSequencer/index.js\",\n\t\"./Sequencer\": \"./src/modules/Sequencer/index.js\",\n\t\"./Sequencer/\": \"./src/modules/Sequencer/index.js\",\n\t\"./Sequencer/EventPattern\": \"./src/modules/Sequencer/EventPattern.js\",\n\t\"./Sequencer/EventPattern.js\": \"./src/modules/Sequencer/EventPattern.js\",\n\t\"./Sequencer/InterfaceHttp\": \"./src/modules/Sequencer/InterfaceHttp.js\",\n\t\"./Sequencer/InterfaceHttp.js\": \"./src/modules/Sequencer/InterfaceHttp.js\",\n\t\"./Sequencer/InterfaceX16\": \"./src/modules/Sequencer/InterfaceX16.js\",\n\t\"./Sequencer/InterfaceX16.js\": \"./src/modules/Sequencer/InterfaceX16.js\",\n\t\"./Sequencer/index\": \"./src/modules/Sequencer/index.js\",\n\t\"./Sequencer/index.js\": \"./src/modules/Sequencer/index.js\",\n\t\"./Sequencer/sequencerGuts\": \"./src/modules/Sequencer/sequencerGuts/index.js\",\n\t\"./Sequencer/sequencerGuts/\": \"./src/modules/Sequencer/sequencerGuts/index.js\",\n\t\"./Sequencer/sequencerGuts/NoteLenManager\": \"./src/modules/Sequencer/sequencerGuts/NoteLenManager.js\",\n\t\"./Sequencer/sequencerGuts/NoteLenManager.js\": \"./src/modules/Sequencer/sequencerGuts/NoteLenManager.js\",\n\t\"./Sequencer/sequencerGuts/NoteLengthner\": \"./src/modules/Sequencer/sequencerGuts/NoteLengthner.js\",\n\t\"./Sequencer/sequencerGuts/NoteLengthner.js\": \"./src/modules/Sequencer/sequencerGuts/NoteLengthner.js\",\n\t\"./Sequencer/sequencerGuts/PatchMem\": \"./src/modules/Sequencer/sequencerGuts/PatchMem.js\",\n\t\"./Sequencer/sequencerGuts/PatchMem.js\": \"./src/modules/Sequencer/sequencerGuts/PatchMem.js\",\n\t\"./Sequencer/sequencerGuts/index\": \"./src/modules/Sequencer/sequencerGuts/index.js\",\n\t\"./Sequencer/sequencerGuts/index.js\": \"./src/modules/Sequencer/sequencerGuts/index.js\",\n\t\"./Sequencer/sequencerGuts/record\": \"./src/modules/Sequencer/sequencerGuts/record.js\",\n\t\"./Sequencer/sequencerGuts/record.js\": \"./src/modules/Sequencer/sequencerGuts/record.js\",\n\t\"./moduleUtils/Note\": \"./src/modules/moduleUtils/Note.js\",\n\t\"./moduleUtils/Note.js\": \"./src/modules/moduleUtils/Note.js\",\n\t\"./moduleUtils/NoteOnTracker\": \"./src/modules/moduleUtils/NoteOnTracker.js\",\n\t\"./moduleUtils/NoteOnTracker.js\": \"./src/modules/moduleUtils/NoteOnTracker.js\",\n\t\"./x16utils/BlankConfigurator\": \"./src/modules/x16utils/BlankConfigurator.js\",\n\t\"./x16utils/BlankConfigurator.js\": \"./src/modules/x16utils/BlankConfigurator.js\",\n\t\"./x16utils/EventConfigurator\": \"./src/modules/x16utils/EventConfigurator.js\",\n\t\"./x16utils/EventConfigurator.js\": \"./src/modules/x16utils/EventConfigurator.js\",\n\t\"./x16utils/RecordMenu\": \"./src/modules/x16utils/RecordMenu.js\",\n\t\"./x16utils/RecordMenu.js\": \"./src/modules/x16utils/RecordMenu.js\",\n\t\"./x28utils/RecordMenu\": \"./src/modules/x28utils/RecordMenu.js\",\n\t\"./x28utils/RecordMenu.js\": \"./src/modules/x28utils/RecordMenu.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/modules sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack://environment/./src/modules_sync_^\\.\\/.*$?");

/***/ }),

/***/ "./src/modules/Alteration/InterfaceX16.js":
/*!************************************************!*\
  !*** ./src/modules/Alteration/InterfaceX16.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\n\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule,environment) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"duration (micro)\": controlledModule.settings.delayMicro,\r\n    }\r\n  });\r\n  configurators.global.vars['duration (micro)'].changeFunction = function (thisVar, delta) {\r\n    thisVar.value += delta;\r\n    passiveUpdateHardware();\r\n  }\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n\r\n  var editMode = false;\r\n  var selectedAlteration = 0;\r\n\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  });\r\n\r\n  var baseNote = 36;\r\n  var engagedHardwares = new Set();\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      if (editMode) {\r\n        selectedAlteration = event.button;\r\n        updateLeds(event.hardware);\r\n      } else {\r\n        controlledModule.uiTrigger(event.button + baseNote);\r\n      }\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    if (engagedConfigurator) { } else {\r\n      updateHardware(event.hardware);\r\n    }\r\n    controlledModule.uiTriggerOff(event.button + baseNote);\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.button == 0) {\r\n        editMode = editMode == false;\r\n      } else if (event.button == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      } else if (event.button >= 8) {\r\n        lastEngagedConfigurator = engagedConfigurator = configurators.record;\r\n      }\r\n    }\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (editMode) {\r\n        controlledModule.alterations[selectedAlteration % 12] += event.delta;\r\n        updateScreen(event.hardware);\r\n      } else {\r\n        if (lastEngagedConfigurator) {\r\n          lastEngagedConfigurator.encoderScrolled(event)\r\n        }\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n\r\n  \r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  configurators.record.autoEngageWindow();\r\n  \r\n  var RARROW = String.fromCharCode(126);\r\n  var updateScreen = function (hardware) {\r\n    if (editMode) {\r\n      hardware.sendScreenA(\"edit alteration\");\r\n      hardware.sendScreenB((selectedAlteration % 12) + RARROW + controlledModule.alterations[selectedAlteration % 12]);\r\n    } else {\r\n      hardware.sendScreenA(controlledModule.name);\r\n    }\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    updateScreen(hardware);\r\n    updateLeds(hardware);\r\n  }\r\n  var passiveUpdateHardware = function () {\r\n    engagedHardwares.forEach(function (hardware) {\r\n      updateLeds(hardware);\r\n    })\r\n  }\r\n  var updateLeds = function (hardware) {\r\n    // stepsBmp = makeAnimationBitmap({x:2,y:2},animf);\r\n\r\n\r\n    var altMaps = [];\r\n    var n = 0;\r\n    for (var alt of controlledModule.alterations) {\r\n      if (alt < -1) {\r\n        altMaps[0] |= 1 << n;\r\n      } else if (alt < 0) {\r\n        altMaps[1] |= 1 << n;\r\n      } else if (alt == 0) {\r\n        altMaps[2] |= 1 << n;\r\n      } else if (alt > 0) {\r\n        altMaps[3] |= 1 << n;\r\n      } else if (alt < 1) {\r\n        altMaps[4] |= 1 << n;\r\n      }\r\n      n++;\r\n    }\r\n    var c = 0;\r\n    var colors = [[0, 0, 0], [60, 60, 60], [120, 120, 120], [180, 180, 0], [240, 240, 0]];\r\n    for (var map of altMaps) {\r\n      map |= map << 12;\r\n      // map|=0xFFFF;\r\n      hardware.drawColor([map, map >> 8], colors[c]);\r\n      c++;\r\n    }\r\n    if (editMode) {\r\n      var selectBmp = 1 << selectedAlteration;\r\n      var selectValue = controlledModule.alterations[selectedAlteration % 12];\r\n      var m = selectValue * 32;\r\n      var selectColor = [127, 127 + m, 255];\r\n      if (!selectColor) selectColor = colors[0]\r\n      selectBmp |= selectBmp << 12;\r\n      selectBmp &= 0xFFFF;\r\n      hardware.drawColor([selectBmp, selectBmp >> 8], selectColor);\r\n    } else {\r\n    }\r\n\r\n  }\r\n  // setInterval(function(){\r\n  //   engagedHardwares.forEach(function(hardware){\r\n  //     updateLeds(hardware);\r\n  //   })\r\n  // }, 700);\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Alteration/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/Alteration/index.js":
/*!*****************************************!*\
  !*** ./src/modules/Alteration/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/Alteration/InterfaceX16.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n @constructor\r\n the instance of the of the module, ment to be instantiated multiple times.\r\n require to moduleBase.call\r\n */\r\n\r\n\r\nvar Alteration = function (properties) {\r\n  var self = this;\r\n  var myBitmap = 0;\r\n  var settings = this.settings = {\r\n    delayMicro: {\r\n      value: 0,\r\n    },\r\n    // feedback:{\r\n    //   value:0,\r\n    //   valueNames:['no','yes'],\r\n    // },\r\n  }\r\n  let clock = this.clock = {\r\n    subSteps: 1,\r\n    subStep: 0,\r\n    step: 0\r\n  }\r\n            // ___---___---______---___---___---___\r\n  this.alterations=[ 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0];\r\n  var noteOnTracker = new NoteOnTracker(this);\r\n\r\n  \r\n  this.baseName = \"Alteration\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n\r\n  var recMessages = {\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] }),\r\n    trigger: new EventMessage({ value: [headers.triggerOn, 36, -1] }),\r\n  }\r\n  this.recordRate = function () {\r\n    recMessages.rate.value[2] = settings.delayMicro.value;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      var event = evt.eventMessage;\r\n      event.value.shift();\r\n    }\r\n    //backpropagate rec messages\r\n  }\r\n  this.uiTrigger=function(num){\r\n    var uiMessage = recMessages.trigger.clone();\r\n    uiMessage.value[1]=num;\r\n    var generatedMessage=uiMessage.clone();\r\n    transformEventMessage(generatedMessage)\r\n    // console.log(\"UITR\", generatedMessage);\r\n    console.log(\"On\", num);\r\n\r\n    //for recording\r\n    noteOnTracker.add(uiMessage, [\"REC\",num]);\r\n    self.recordOutput(uiMessage);\r\n    //for output\r\n    noteOnTracker.add(generatedMessage, [\"UI\", num]);\r\n    self.output(generatedMessage);\r\n  }\r\n  this.uiTriggerOff=function(num){\r\n    console.log(\"OFF\",num);\r\n    noteOnTracker.ifNoteOff([\"UI\", num], function (noteOff) {\r\n      console.log(\"OFF\",noteOff);\r\n      self.output(noteOff);\r\n    });\r\n    noteOnTracker.ifNoteOff([\"REC\", num], function (noteOff) {\r\n      console.log(\"OFF\",noteOff);\r\n      let nnoff = noteOff.clone();\r\n      nnoff.value[0] = headers.triggerOff;\r\n      self.recordOutput(nnoff);\r\n    });\r\n  }\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      \r\n    } else if (evt.eventMessage.value[0] == headers.changeRate) {\r\n      clock.subSteps = evt.eventMessage.value[2] / (evt.eventMessage.value[1] || 1);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      var gradeNumber=evt.eventMessage.value[1];\r\n      var timbrNum=evt.eventMessage.value[2];\r\n      transformEventMessage(evt.eventMessage);\r\n      noteOnTracker.add(evt.eventMessage, [\"EX\", gradeNumber, timbrNum]);\r\n      self.output(evt.eventMessage);\r\n\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      var timbrNum=evt.eventMessage.value[2];\r\n      var gradeNumber=evt.eventMessage.value[1];\r\n      noteOnTracker.ifNoteOff([\"EX\", gradeNumber, timbrNum], function (noteOff) {\r\n        self.output(noteOff);\r\n      });\r\n    }\r\n  }\r\n  var numberTransformFunction=function(input){\r\n    var base=Math.floor(input/12)*12;\r\n    var wrIn = input%12;\r\n    var grade = self.alterations[wrIn] + wrIn;\r\n    console.log(input,base,grade);\r\n    return base+grade;\r\n  }\r\n  var transformEventMessage=function(eventMessage){\r\n    eventMessage.value[1]=numberTransformFunction(eventMessage.value[1]);\r\n  }\r\n  this.getBitmap16 = function () {\r\n    return myBitmap;\r\n  }\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noff) {\r\n  //     thisInstance.output(noff, true);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n\r\n  this.handleStepsChange = function () {\r\n    self.handle('~module', { steps: runningNotes.length });\r\n  }\r\n\r\n};\r\n\r\nAlteration.color = [160, 200, 20];\r\nmodule.exports = Alteration;\n\n//# sourceURL=webpack://environment/./src/modules/Alteration/index.js?");

/***/ }),

/***/ "./src/modules/Arpeggiator/InterfaceX16.js":
/*!*************************************************!*\
  !*** ./src/modules/Arpeggiator/InterfaceX16.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule) {\r\n\r\n  base.call(this);\r\n  var sequence = controlledModule.monosequence;\r\n  var view = { step: 0 }\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"clear\": controlledModule.settings.reset,\r\n      \"step ratio\": {\r\n        value: controlledModule.clock.subSteps,\r\n      },\r\n      \"sequence length\": sequence.length,\r\n    }\r\n  });\r\n  configurators.global.vars[\"step ratio\"].changeFunction = function (thisVar, delta) {\r\n    thisVar.value = controlledModule.clock.subSteps\r\n    if (delta > 0) {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value *= 2;\r\n      } else {\r\n        thisVar.value++\r\n      }\r\n    } else {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value /= 2;\r\n      } else {\r\n        thisVar.value--;\r\n      }\r\n    }\r\n    controlledModule.clock.subSteps = thisVar.value;\r\n    controlledModule.recordStepDivision();\r\n  };\r\n\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = 0;\r\n\r\n  var engagedHardwares = new Set();\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      sequence.toggleStep(event.button + view.step);\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    if (engagedConfigurator) { } else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      } else if (event.data[0] > 3) {\r\n        view.step = (event.data[0] - 4) * 16;\r\n        updateLeds(event.hardware);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n  var updateLeds = function (hardware) {\r\n    if (engagedConfigurator) return;\r\n    stepsBmp = (sequence.getBitmap() >> (view.step)) & 0xFFFF;\r\n    // console.log(sequence.playhead.value);\r\n    var playheadBmp = 0;\r\n\r\n    if (sequence.playhead.value >= view.step && sequence.playhead.value < view.step + 16) {\r\n      playheadBmp = (0x1 << Math.abs(sequence.playhead.value - view.step)) & 0xFFFF\r\n    }\r\n    hardware.draw([stepsBmp | playheadBmp, playheadBmp, stepsBmp | playheadBmp]);\r\n  }\r\n  var passiveUpdateLeds = function () {\r\n    // console.log(\"PUL\");\r\n    engagedHardwares.forEach(function (hardware) {\r\n      updateLeds(hardware);\r\n    })\r\n  }\r\n  sequence.on('step', passiveUpdateLeds);\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Arpeggiator/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/Arpeggiator/Monosequence.js":
/*!*************************************************!*\
  !*** ./src/modules/Arpeggiator/Monosequence.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\npattern can be \"user defined\", up, up/dn, dn, random, etc.\r\nif it's user defined, the sequencer is enabled allowing to program the arp steps to sequence\r\nthe problem with user defined sequencer is that it has a limit of four grades due to the size of the ui matrix\r\nbut with the \"standard\" ones, all the grades are reached\r\nthe user defined sequencer also ensures a time metric\r\nthe arpeggiator length in a user defined arpeggiator sequence is provided by the position of the last programmed step.\r\n*/\r\nvar Observable = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\n\r\nmodule.exports = function (controlledModule) {\r\n  var self = this;\r\n  Observable.call(this);\r\n  var pattern = this.pattern = [];\r\n  var playhead = this.playhead = { value: 0 }\r\n  var length = this.length = { value: 4 }\r\n  this.setStep = function (step, data = 1) {\r\n    pattern[step] = data;\r\n    self.handle('~sequence');\r\n    // console.log(pattern);\r\n  }\r\n  this.clearStep = function (step) {\r\n    if (pattern[step]) {\r\n      delete pattern[step];\r\n    }\r\n    self.handle('~sequence');\r\n  }\r\n  this.toggleStep = function (step, data = 1) {\r\n    if (pattern[step]) {\r\n      self.clearStep(step);\r\n    } else {\r\n      self.setStep(step, data);\r\n    }\r\n  }\r\n  this.getStep = function (step) {\r\n    return (pattern[step] ? pattern[step] : false);\r\n  }\r\n  this.getCurrentStep = function () {\r\n    return self.getStep(playhead.value);\r\n  }\r\n  this.getBitmap = function () {\r\n    var ret = 0;\r\n    for (var a in pattern) {\r\n      if (pattern[a]) {\r\n        ret |= 1 << a;\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n  this.playStep = function (cb) {\r\n    self.playhead.value++;\r\n    self.playhead.value %= self.length.value;\r\n    var st = self.getStep(self.playhead.value)\r\n    if (st) {\r\n      cb(st);\r\n    }\r\n    self.handle('step');\r\n  }\r\n\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Arpeggiator/Monosequence.js?");

/***/ }),

/***/ "./src/modules/Arpeggiator/index.js":
/*!******************************************!*\
  !*** ./src/modules/Arpeggiator/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/Arpeggiator/InterfaceX16.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\nvar Monosequence = __webpack_require__(/*! ./Monosequence */ \"./src/modules/Arpeggiator/Monosequence.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar Arpeggiator = function (properties) {\r\n\r\n  var self = this;\r\n  var myBitmap = 0;\r\n  var settings = this.settings = {\r\n    duration: { value: false },\r\n    'force length': { value: 0 }, //when >0, this should modify how the sequence is played so that it's length is always a factor of the forced length\r\n    //this effectively converts the arpeggiator in a fast pattern maker that doesn't drift away easily\r\n    mode: {\r\n      value: 0,\r\n      valueNames: ['as played', 'up', 'down', 'random']\r\n    },\r\n    pattern: {\r\n      value: 0,\r\n      valueNames: ['straight', 'polymeter 3%8', 'polymeter 3%16', 'polyrhythm 8/3', 'polyrhythm 16/3'],\r\n    },\r\n    reset: { value: false }//this allows to clear the notes in the arpeggiator in case there is a hanging note.\r\n  }\r\n\r\n  let monosequence = this.monosequence = new Monosequence();\r\n\r\n  monosequence.setStep(0, 1);\r\n  monosequence.setStep(1, 1);\r\n  monosequence.setStep(2, 1);\r\n  monosequence.setStep(3, 1);\r\n\r\n  let clock = this.clock = {\r\n    subSteps: 1,\r\n    subStep: 0,\r\n    step: 0\r\n  }\r\n  let noteOnTracker = new NoteOnTracker(this);\r\n\r\n  let runningNotes = [];\r\n  let runningNotesSorted = [];\r\n\r\n\r\n  function eachRunningNote(cb) {\r\n    for (var index in runningNotes) {\r\n      var rnot = runningNotes[index];\r\n      cb.call(rnot, index, rnot);\r\n    }\r\n  }\r\n  this.baseName = \"Arpeggiator\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n\r\n  var memory = [];\r\n  var recMessages = {\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] })\r\n  }\r\n  this.recordStepDivision = function () {\r\n    recMessages.rate.value[2] = self.clock.subSteps * 12;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      //shold for instance the arpeggiator proxy the recorder behind? it is possible to make this module send his recoding notes upward.\r\n      evt.eventMessage.value.shift();\r\n      self.messageReceived(evt);\r\n    }\r\n  }\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n\r\n      var clockBase = evt.eventMessage.value[1];\r\n      var clockMicroStep = evt.eventMessage.value[2];\r\n\r\n      if ((clockMicroStep / clock.subSteps) % clockBase == 0) {\r\n        clock.subStep++;\r\n        if (clock.subStep >= clock.subSteps) {\r\n\r\n          clock.subStep = 0;\r\n\r\n          \r\n          noteOnTracker.empty(function (noff) {\r\n            self.output(noff, true);\r\n          });\r\n          \r\n          monosequence.playStep(function (step) {\r\n            if (step) {\r\n              clock.step++;\r\n              arpOperation();\r\n            }\r\n          })\r\n\r\n          self.handle('step');\r\n        }\r\n      }\r\n\r\n\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      // this.setFixedStep(evt.eventMessage.value[2]%16);\r\n      addNote(evt.eventMessage.clone());\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      // this.clearFixedStep(evt.eventMessage.value[2]%16);\r\n      removeNote(evt.eventMessage.clone());\r\n    } else if (evt.eventMessage.value[0] == headers.changeRate) {\r\n      // console.log(\"CHANGERATEHEAER\",evt.eventMessage.value);\r\n      clock.subSteps = evt.eventMessage.value[2] / (evt.eventMessage.value[1] || 1);\r\n    }\r\n  }\r\n\r\n  this.getBitmap16 = function () {\r\n    return myBitmap;\r\n  }\r\n  this.onRemove = function () {\r\n    noteOnTracker.empty(function (noff) {\r\n      self.output(noff, true);\r\n    });\r\n    return true;\r\n  }\r\n\r\n  this.handleStepsChange = function () {\r\n    self.handle('~module', { steps: runningNotes.length });\r\n  }\r\n\r\n  function arpOperation() {\r\n    if (settings.reset.value) {\r\n      runningNotes.splice(0);\r\n      noteOnTracker.empty(function (noff) {\r\n        self.output(noff, true);\r\n      });\r\n      settings.reset.value = false;\r\n    }\r\n    if (runningNotes.length) {\r\n      arpTrigger(clock.step % runningNotes.length);\r\n    }\r\n  }\r\n\r\n  function arpTrigger(num) {\r\n    var outNote = runningNotes[num];\r\n    noteOnTracker.add(outNote);\r\n    self.output(outNote);\r\n  }\r\n\r\n  function addNote(eventMessage) {\r\n    self.handleStepsChange();\r\n    runningNotes.push(eventMessage);\r\n  }\r\n\r\n  function removeNote(eventMessage) {\r\n    self.handleStepsChange();\r\n    // var noteWasRemoved=false;\r\n\r\n    for (var index = runningNotes.length - 1; index >= 0; index--) {\r\n      var rnote = runningNotes[index];\r\n      // console.log(\"?\",rnote.value);\r\n      if (eventMessage.compareValuesTo(rnote, [1, 2])) {\r\n        // noteWasRemoved = true;\r\n        runningNotes.splice(index, 1);\r\n      }\r\n    }\r\n    // if(!noteWasRemoved) console.warn(\"note was not found to remove\",eventMessage.value);\r\n    // console.log(runningNotes.length);\r\n  }\r\n};\r\n\r\nArpeggiator.color = [210, 0, 233];\r\nmodule.exports = Arpeggiator;\n\n//# sourceURL=webpack://environment/./src/modules/Arpeggiator/index.js?");

/***/ }),

/***/ "./src/modules/Bouncer/InterfaceX16.js":
/*!*********************************************!*\
  !*** ./src/modules/Bouncer/InterfaceX16.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\n\r\nmodule.exports = function(controlledModule,environment) {\r\n  base.call(this);\r\n  var configurators = {};\r\n\r\n  var lastEngagedConfigurator=false;\r\n  var engagedConfigurator = false;\r\n  var engagedHardwares = new Set();\r\n  var lazyQueue=new environment.utils.LazyQueue();\r\n\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  });\r\n\r\n  var bitmap=0;\r\n  controlledModule.on('received', function(evMes) {\r\n    var newBitmap=1<<(evMes.value[2]%16);\r\n    bitmap|=newBitmap\r\n    updateLeds();\r\n    var TFunc=function(newBitmap){\r\n      this.do=function(){\r\n        lazyQueue.enq(function(){\r\n          bitmap&=~(newBitmap);\r\n          updateLeds();\r\n        });\r\n      }\r\n    }\r\n    setTimeout(new TFunc(newBitmap).do,300);\r\n  });\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 1) {\r\n      }else if (event.data[0] == 2) {\r\n        // engagedConfigurator = configurators.time;\r\n        // configurators.time.engage(event);\r\n      }else if (event.button >= 8) {\r\n        lastEngagedConfigurator = engagedConfigurator = configurators.record;\r\n      }\r\n      lastEngagedConfigurator = engagedConfigurator;\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 1) {\r\n      if (engagedConfigurator) {\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator=false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n\r\n  configurators.record.autoEngageWindow();\r\n  var updateHardware = function(hardware) {\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateScreen = function(hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    // hardware.sendScreenB(\"n:\"+currentStep);\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    if (!engagedConfigurator){\r\n      var updateFn=function(hardware){\r\n        hardware.draw([bitmap,0,bitmap]);\r\n      }\r\n      if(hardware){\r\n        updateFn(hardware);\r\n      }else{\r\n        for (let hardware of engagedHardwares) {\r\n          updateFn(hardware);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Bouncer/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/Bouncer/index.js":
/*!**************************************!*\
  !*** ./src/modules/Bouncer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n\r\nvar InterfaceX16 = false;//require('./InterfaceX16');\r\n\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n\r\n*/\r\nvar headers = EventMessage.headers;\r\n\r\n\r\nvar instancesCount = 0;\r\nvar getName = function() {\r\n  this.name = this.baseName + \" \" + instancesCount;\r\n  instancesCount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar Bouncer = function(properties,environment) {\r\n  this.preventBus=true;\r\n  //maybe the operator should allow layering of many operation layers, also adding timing operations\r\n\r\n  var self = this;\r\n\r\n\r\n  this.baseName = \"Bouncer\";\r\n\r\n  var baseEventMessage=this.baseEventMessage=new EventMessage({value:[0,0,0,0]});\r\n  getName.call(this);\r\n\r\n  if (properties.name) this.name = properties.name;\r\n\r\n  var noteOnTracker = new NoteOnTracker(this);\r\n\r\n  this.interfaces.X16 =  InterfaceX16;\r\n  this.bounce = function (eventMessage) {\r\n    self.outputs.forEach(function (tModule) {\r\n      var recordEventMessage = eventMessage.clone();\r\n      recordEventMessage.value.unshift(headers.record);\r\n      tModule.recordingReceived({ eventMessage: recordEventMessage, origin: self });\r\n    });\r\n  }\r\n\r\n  this.messageReceived = function(evt) {\r\n    // var eventMessage=evt.eventMessage;\r\n    self.handle('received',evt.eventMessage);\r\n    // var recordEventMessage=eventMessage.clone();\r\n    // recordEventMessage.value.unshift(headers.record);\r\n    self.bounce(evt.eventMessage);\r\n  }\r\n\r\n  // this.onRemove = function() {\r\n  //   this.interfaces=false;\r\n  //   noteOnTracker.empty(function(noteOff){\r\n  //     self.output(noteOff);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n}\r\nBouncer.color = [255, 0, 255];\r\nmodule.exports = Bouncer;\n\n//# sourceURL=webpack://environment/./src/modules/Bouncer/index.js?");

/***/ }),

/***/ "./src/modules/Bus/index.js":
/*!**********************************!*\
  !*** ./src/modules/Bus/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar instanced = 0;\r\nvar name = function() {\r\n  this.name = this.baseName + \" \" + instanced;\r\n  instanced++;\r\n}\r\n\r\nvar Bus = function(properties,environment) {\r\n  this.baseName = \"bus\";\r\n  var self = this;\r\n  name.call(this);\r\n  this.interactor = {\r\n    type: \"interactor\",\r\n    compatibilityTags: []\r\n  }\r\n\r\n  this.messageReceived = function(evt) {\r\n    this.output(evt.eventMessage);\r\n  }\r\n  this.preventBus = true;\r\n  this.preventRecord=true;\r\n  if (properties.name) this.name = properties.name\r\n  environment.on('+module', function(evt) {\r\n    var module = evt.module;\r\n    if (!module.preventBus) {\r\n      if (module.baseName !== \"bus\") {\r\n        self.addOutput(module);\r\n      }\r\n    }\r\n  });\r\n};\r\nBus.color = [110, 120, 130];\r\nmodule.exports=Bus;\n\n//# sourceURL=webpack://environment/./src/modules/Bus/index.js?");

/***/ }),

/***/ "./src/modules/CalculeitorMidi/InterfaceX28.js":
/*!*****************************************************!*\
  !*** ./src/modules/CalculeitorMidi/InterfaceX28.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar panton = __webpack_require__(/*! ../../interaction/x28basic/panton */ \"./src/interaction/x28basic/panton.js\");\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule) {\r\n\r\n  /*\r\n  what if this module disengaged the controllermode and did set the calculeitor in a pad performance mode, \r\n  so that the user can perform with lower latency midi output, and the same performance gets sent to this module\r\n  */\r\n  base.call(this);\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    if (controlledModule.outputHardwares.has(event.hardware)) {\r\n      controlledModule.outputHardwares.delete(event.hardware)\r\n    } else {\r\n      controlledModule.outputHardwares.add(event.hardware)\r\n    }\r\n    updateLeds(event.hardware);\r\n  };\r\n\r\n  var dimColor = [\r\n    Math.floor(controlledModule.color[0] / 3),\r\n    Math.floor(controlledModule.color[1] / 3),\r\n    Math.floor(controlledModule.color[2] / 3),\r\n  ];\r\n  var hiColor = [\r\n    Math.floor(controlledModule.color[0] / 3),\r\n    Math.floor(controlledModule.color[1] / 3),\r\n    Math.floor(controlledModule.color[2] / 2),\r\n  ];\r\n\r\n  this.engage = function (event) {\r\n    event.hardware.definePresetColour(\"active\", hiColor);\r\n    event.hardware.definePresetColour(\"dim\", dimColor);\r\n    updateHardware(event.hardware);\r\n  };\r\n\r\n  var updateHardware = function (hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n\r\n  // controlledModule.on(\"midiOut\", function () {\r\n  //   controlledModule.outputHardwares.forEach(updateLeds);\r\n  // });\r\n\r\n  var count=0xDA;\r\n\r\n  var updateLeds = function (hardware) {\r\n\r\n    var yes = 0b0110100110010110;\r\n    var no = 0b1001011001101001;\r\n    var center = 0b0000011001100000;\r\n\r\n    hardware.clear();\r\n    if (controlledModule.outputHardwares.has(hardware)) {\r\n      hardware.paintPresetColour(\"active\", yes);\r\n      // hardware.paintPresetColour(\"dimblue\", center & (count % 0xFF) << 5);\r\n      count++;\r\n    } else {\r\n      hardware.paintPresetColour(\"dim\", no);\r\n    }\r\n\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/CalculeitorMidi/InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/CalculeitorMidi/index.js":
/*!**********************************************!*\
  !*** ./src/modules/CalculeitorMidi/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX28 = __webpack_require__(/*! ./InterfaceX28 */ \"./src/modules/CalculeitorMidi/InterfaceX28.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n @constructor\r\n the instance of the of the module, ment to be instantiated multiple times.\r\n require to moduleBase.call\r\n */\r\n\r\n\r\nvar CalculeitorMidi = function (properties) {\r\n  this.preventBus = true;\r\n  this.baseName = \"CalculeitorMidi\";\r\n  this.color = CalculeitorMidi.color;\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n  var defaultMessage = new EventMessage({\r\n    value: [0, 36, 0, 90]\r\n  });\r\n\r\n\r\n  var outputHardwares = this.outputHardwares = new Set();\r\n\r\n  this.interfaces.X16 = InterfaceX28;\r\n\r\n  var noteOnTracker = {}\r\n\r\n  function sendMidi(midiOut){\r\n    self.handle(\"midiOut\");\r\n    outputHardwares.forEach(function(hardware){\r\n      // console.log(\"HW\",hardware);\r\n      hardware.sendMidi(midiOut);\r\n    });\r\n  }\r\n\r\n  this.messageReceived = function (evt) {\r\n    if (self.mute) return;\r\n    evt.eventMessage.underImpose(defaultMessage);\r\n    var midiOut = EventMessage.toMidi(evt.eventMessage);\r\n    if (midiOut)\r\n      sendMidi(midiOut);\r\n    else\r\n      console.warn(\"midiout is \", midiOut);\r\n  }\r\n\r\n\r\n};\r\n\r\nCalculeitorMidi.color = [120, 100, 130];\r\nmodule.exports = CalculeitorMidi;\n\n//# sourceURL=webpack://environment/./src/modules/CalculeitorMidi/index.js?");

/***/ }),

/***/ "./src/modules/Chord/InterfaceX28.js":
/*!*******************************************!*\
  !*** ./src/modules/Chord/InterfaceX28.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar panton = __webpack_require__(/*! ../../interaction/x28basic/panton */ \"./src/interaction/x28basic/panton.js\");\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"offset\": controlledModule.offset,\r\n      \"modify\": controlledModule.remapIndex,\r\n    }\r\n  });\r\n\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var engagedHardwares = new Set();\r\n  configurators.global.vars.offset.changeFunction = function (thisVar, delta) {\r\n    thisVar.value += delta;\r\n    if (thisVar.value > 0) thisVar.value = 0;\r\n    if (thisVar.value < -15) thisVar.value = -15\r\n    passiveUpdateHardware();\r\n  }\r\n  this.matrixButtonPressed = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      controlledModule.bitmap ^= 1 << event.button;\r\n      // console.log(controlledModule.bitmap.toString(2));\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    if (engagedConfigurator) { } else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  var dimColor = [\r\n    Math.floor(controlledModule.color[0] / 3),\r\n    Math.floor(controlledModule.color[1] / 3),\r\n    Math.floor(controlledModule.color[2] / 3),\r\n  ];\r\n  var hiColor = [\r\n    Math.floor(controlledModule.color[0] / 3),\r\n    Math.floor(controlledModule.color[1] / 3),\r\n    Math.floor(controlledModule.color[2] / 2),\r\n  ];\r\n  this.engage = function (event) {\r\n\r\n    event.hardware.definePresetColour(\"active\", hiColor);\r\n    event.hardware.definePresetColour(\"dim\",dimColor);\r\n\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n  var passiveUpdateHardware = function () {\r\n    engagedHardwares.forEach(function (hardware) {\r\n      updateLeds(hardware);\r\n    })\r\n  }\r\n  var animf = 0;\r\n  var updateLeds = function (hardware) {\r\n    // controlledModule.bitmap = makeAnimationBitmap({x:2,y:2},animf);\r\n    var centerBitmap = 1 << -controlledModule.offset.value;\r\n    // hardware.draw([0, controlledModule.bitmap, controlledModule.bitmap]);\r\n    // hardware.drawColor(centerBitmap, [(t ? 127 : 60), (t ? 60 : 0), (t ? 60 : 0)]);\r\n    hardware.clear();\r\n\r\n    hardware.paintPresetColour(\"dim\", controlledModule.bitmap);\r\n    var ov = centerBitmap & controlledModule.bitmap;\r\n    if (ov) {\r\n      hardware.paintPresetColour(\"active\", ov);\r\n    } else {\r\n      hardware.paintPresetColour(\"dimblue\", centerBitmap);\r\n    }\r\n\r\n    // var t = centerBitmap & controlledModule.bitmap;\r\n    // animf++;\r\n    // if (animf > 8) animf = 0;\r\n  }\r\n  // setInterval(function(){\r\n  //   engagedHardwares.forEach(function(hardware){\r\n  //     updateLeds(hardware);\r\n  //   })\r\n  // }, 700);\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Chord/InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/Chord/index.js":
/*!************************************!*\
  !*** ./src/modules/Chord/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX28 = __webpack_require__(/*! ./InterfaceX28 */ \"./src/modules/Chord/InterfaceX28.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n @constructor\r\n the instance of the of the module, ment to be instantiated multiple times.\r\n require to moduleBase.call\r\n */\r\n\r\n\r\nvar Chord = function (properties) {\r\n  var thisInstance = this;\r\n  this.preventBus=true;\r\n  this.baseName = \"Chord\";\r\n  this.color=Chord.color;\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n  this.interfaces.X16 = InterfaceX28;\r\n\r\n  var noteOnTracker={}\r\n\r\n  this.bitmap=0;\r\n  this.offset={value:-8}\r\n  this.remapIndex={\r\n    value:1,\r\n    valueNames:[\"none\",\"note\",\"chan\"],\r\n  }\r\n\r\n  function eachChordGrade(cb){\r\n    for(var b=0; b<16; b++){\r\n      if(self.bitmap & 1<<b){\r\n        cb(b + self.offset.value);\r\n      }\r\n    }\r\n  }\r\n\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      var incomingNote=evt.eventMessage.value[1];\r\n      var incomingTimbr=evt.eventMessage.value[2];\r\n      var incomingValue=evt.eventMessage.value[self.remapIndex.value];\r\n      eachChordGrade(function(num){\r\n        var newMes=evt.eventMessage.clone();\r\n        if (!noteOnTracker[incomingNote, incomingTimbr]) noteOnTracker[incomingNote, incomingTimbr]=[];\r\n        noteOnTracker[incomingNote,incomingTimbr].push(newMes);\r\n        newMes.value[self.remapIndex.value]=incomingValue+num;\r\n        self.output(newMes);\r\n      });\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      var incomingNote=evt.eventMessage.value[1];\r\n      var incomingTimbr=evt.eventMessage.value[2];\r\n      if(noteOnTracker[incomingNote, incomingTimbr]){\r\n        for (var trackedNoteOn of noteOnTracker[incomingNote, incomingTimbr]){\r\n          trackedNoteOn.value[0]=EventMessage.headers.triggerOff;\r\n          self.output(trackedNoteOn);\r\n        }\r\n        delete noteOnTracker[incomingNote, incomingTimbr];\r\n      }\r\n      // console.log(noteOnTracker);\r\n    }\r\n  }\r\n\r\n  this.getBitmap16 = function () {\r\n    return myBitmap;\r\n  }\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noff) {\r\n  //     thisInstance.output(noff, true);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n\r\n  this.handleStepsChange = function () {\r\n    self.handle('~module', { steps: runningNotes.length });\r\n  }\r\n\r\n};\r\n\r\nChord.color = [210, 0, 233];\r\nmodule.exports = Chord;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Chord/index.js?");

/***/ }),

/***/ "./src/modules/ClockGenerator/InterfaceX16.js":
/*!****************************************************!*\
  !*** ./src/modules/ClockGenerator/InterfaceX16.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar RARROW = String.fromCharCode(199);\r\nvar LARROW = String.fromCharCode(200);\r\n\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nmodule.exports = function (controlledModule) {\r\n  // environment.interactionMan.interfaces.x16basic.interactorBase.call(this, controlledModule);\r\n  var engagedHardwares = new Set();\r\n  var playHeadBmp;\r\n  var microStepsBmp;\r\n  // var shiftPressed=false;\r\n  var mode = \"bpm\";\r\n  base.call(this);\r\n  // controlledModule.on('microstep',function(event){\r\n  // });\r\n  //microStep event happens too often, instead I am setting an interval to updte the leds\r\n\r\n  // setInterval(function() {\r\n  //   playHeadBmp = 1 << controlledModule.step.value;\r\n  //   microStepsBmp = ~(0xffff << controlledModule.step.microSteps);\r\n  //   for (let hardware of engagedHardwares) {\r\n  //     updateLeds(hardware);\r\n  //   }\r\n  // }, 20);\r\n  this.matrixButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.matrixButtonReleased = function (event) { };\r\n  this.matrixButtonHold = function (event) { };\r\n  var drifting = 0;\r\n  this.selectorButtonPressed = function (event) {\r\n    drifting = 0;\r\n    if (event.button == 0) mode = \"bpm\";\r\n    if (event.button == 1) mode = \"drift\";\r\n    // if (event.button == 2) mode = \"swing\";\r\n    event.hardware.sendScreenB(mode);\r\n    var ex = 0x1 << 3;\r\n    event.hardware.drawSelectors([1 << event.button | ex, 1 << event.button | ex, 1 << event.button]);\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    // if (event.button == 1 && mode==\"drift\") {\r\n    //   mode = bpm;\r\n    //   drifting = 0;\r\n    //   controlledModule.metro.drift(drifting);\r\n    //   event.hardware.sendScreenA(\"\");\r\n    // }\r\n  };\r\n  var bpm = 120;\r\n  this.encoderScrolled = function (event) {\r\n    if (mode == \"drift\") {\r\n      drifting += event.delta;\r\n      controlledModule.metro.drift(drifting);\r\n      var string = \"\";\r\n      if (drifting > 0) {\r\n        string = \"Drift\";\r\n        for (var a = 0; a < Math.abs(drifting); a++) {\r\n          string += RARROW;\r\n        }\r\n      } else if (drifting < 0) {\r\n        for (var a = 0; a < Math.abs(drifting); a++) {\r\n          string += LARROW;\r\n        }\r\n        string += \"Drift\";\r\n      } else {\r\n        string = \"Drift\";\r\n      }\r\n      event.hardware.sendScreenA(string);\r\n    } else if (mode == \"bpm\") {\r\n      bpm += event.delta;\r\n      controlledModule.metro.bpm(bpm * 4);\r\n      event.hardware.sendScreenA(\"BPM: \" + bpm + \"\");\r\n    } /*else if (mode == \"swing\") {\r\n      controlledModule.swing += event.delta;\r\n      event.hardware.sendScreenA(\"Swing: \" + controlledModule.swing + \"\");\r\n    }*/\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n    event.hardware.sendScreenB(\"bpm  drift\");\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    hardware.sendScreenA(\"Clock Generator\");\r\n    updateLeds(hardware);\r\n  }\r\n  var updateLeds = function (hardware) {\r\n    hardware.draw([\r\n      playHeadBmp,\r\n      playHeadBmp | microStepsBmp,\r\n      playHeadBmp | microStepsBmp\r\n    ]);\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/ClockGenerator/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/ClockGenerator/index.js":
/*!*********************************************!*\
  !*** ./src/modules/ClockGenerator/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar hrtime = __webpack_require__(/*! browser-process-hrtime */ \"./node_modules/browser-process-hrtime/index.js\");\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/ClockGenerator/InterfaceX16.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers=EventMessage.headers;\r\nvar instanced = 0;\r\n\r\nif(typeof process.hrtime!==\"function\"){\r\n  console.log(\"shim process.hrtime\");\r\n  process.hrtime=hrtime;\r\n}\r\n\r\nvar name = function() {\r\n  this.name = this.baseName + \" \" + instanced;\r\n  instanced++;\r\n}\r\nvar ClockGenerator = function(properties={bpm:60}) {\r\n  var thisInstance = this;\r\n  var myInterval = false;\r\n  this.preventBus = true;\r\n\r\n  var myEventMessage = new EventMessage({\r\n    value: [headers.clockTick, 12 /*ck per step*/ , 0 /* step number*/ ]\r\n  });\r\n\r\n  var step = this.step = {\r\n    value: 0,\r\n    microSteps: 12\r\n  }\r\n\r\n  this.baseName = \"clockGenerator\";\r\n  name.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  this.interfaces.X16 =  InterfaceX16;\r\n\r\n  function tickFunction() {\r\n      step.value++;\r\n      step.value %= step.microSteps;\r\n      myEventMessage.value[1] = step.microSteps;\r\n      myEventMessage.value[2] = step.value;\r\n      thisInstance.output(myEventMessage);\r\n  }\r\n\r\n  var metro=new MetronomePrototype();\r\n  metro.onTick(tickFunction);\r\n  this.metro=metro;\r\n\r\n\r\n  if(properties.interval) metro.interval(properties.interval);\r\n  if(properties.bpm) metro.bpm(properties.bpm * 4);\r\n\r\n}\r\n\r\nvar microStepDivide=12;\r\n\r\nfunction MetronomePrototype(props={}) {\r\n\r\n  var interval=60;\r\n\r\n  var microInterval=interval/microStepDivide;\r\n\r\n  var currentStep=0;\r\n  var currentMicroStep=0;\r\n\r\n  this.clockMode=\"absolute\";\r\n  if(props.mode)this.clockMode=props.mode;\r\n\r\n  var tMetro=this;\r\n  var myIndex=0;\r\n  //vars for anti drifting\r\n  var absoluteMicroInterval=0;\r\n  var absoluteMicroDrift=0;\r\n  var timeAnchor=0;\r\n  var microIterations=0;\r\n\r\n  var forcedDrift=0;\r\n\r\n\r\n  this.swing = 0;\r\n  \r\n  function _onTick(){};\r\n  this.onTick=function(fn){\r\n    _onTick=fn;\r\n  }\r\n  function tick(){\r\n    _onTick();\r\n    // console.log(\"ti\");\r\n    //todo: optionally send an absolute step message?.\r\n  }\r\n  function microTick(){\r\n    currentMicroStep%=microStepDivide;\r\n    tick();\r\n    currentMicroStep++;\r\n  };\r\n  function stm(){\r\n    var hrtime=process.hrtime();\r\n    var now=(hrtime[1]/1000000)+(hrtime[0]*1000);\r\n    //anti drifting funcs\r\n    microIterations++;\r\n    var elapsed=now-timeAnchor;\r\n    var nextInterval=(microIterations*microInterval)-elapsed;\r\n\r\n    //add user defined drift\r\n    nextInterval+=forcedDrift;\r\n\r\n    setTimeout(stm,nextInterval-absoluteMicroDrift);\r\n    absoluteMicroInterval=(elapsed/microIterations);\r\n    absoluteMicroDrift=microInterval-absoluteMicroInterval;\r\n    // console.log(\"tick n \"+currentMicroStep\r\n    // +\"\\n  Tartget:\"+microInterval\r\n    // +\"\\n  Interval:\"+absoluteMicroInterval\r\n    // +\"\\n  drift:\"+absoluteMicroDrift\r\n    // +\"\\n  nextinterval:\"+nextInterval);\r\n    // operation functions\r\n    microTick();\r\n    // currentMicroStep++;\r\n    // currentMicroStep%=microStepDivide;\r\n  }\r\n  function resetTimeAnchor(){\r\n    var hrtime=process.hrtime();\r\n    timeAnchor=(hrtime[1]/1000000)+(hrtime[0]*1000);\r\n    microIterations=0;\r\n  }\r\n  function start(){\r\n    // timeAnchor=new Date();\r\n    resetTimeAnchor();\r\n    stm();\r\n  }\r\n  this.drift=function(ms){\r\n    forcedDrift+=ms;\r\n  }\r\n  start();\r\n  this.interval=function(val){\r\n    if(val){\r\n      interval=val;\r\n      microInterval=interval/microStepDivide;\r\n      resetTimeAnchor();\r\n    }\r\n    return interval;\r\n  }\r\n  this.bpm=function(val){\r\n    if(val){\r\n      //60,000 / BPM = interval\r\n      //bp/k=1/interval\r\n      //bp=1/interval*k\r\n      interval=60000/(val);\r\n      microInterval=interval/microStepDivide;\r\n      // console.log(\"cal\",interval);\r\n      resetTimeAnchor();\r\n      return val;\r\n    }else{\r\n      return Math.floor((1/interval)*60000);\r\n    }\r\n  }\r\n}\r\nClockGenerator.color = [60, 100, 100];\r\nmodule.exports = ClockGenerator;\n\n//# sourceURL=webpack://environment/./src/modules/ClockGenerator/index.js?");

/***/ }),

/***/ "./src/modules/DelayClockBased/InterfaceHttp.js":
/*!******************************************************!*\
  !*** ./src/modules/DelayClockBased/InterfaceHttp.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Observable = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nmodule.exports = function (controlledModule, environment) {\r\n    var self = this;\r\n    Observable.call(this);\r\n    var bitmapCache = 0;\r\n\r\n    \r\n\r\n    var mySequenceInterval = false;\r\n    var baseEngage = this.engage;\r\n    this.engage = function (callback) {\r\n        baseEngage(callback);\r\n        mySequenceInterval = setInterval(function () {\r\n            controlledModule.handle('~module', { \r\n                steps: controlledModule.memory.size \r\n            });\r\n        }, 200);\r\n    }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/DelayClockBased/InterfaceHttp.js?");

/***/ }),

/***/ "./src/modules/DelayClockBased/InterfaceX16.js":
/*!*****************************************************!*\
  !*** ./src/modules/DelayClockBased/InterfaceX16.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar RARROW = String.fromCharCode(199);\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"delay (micro)\": controlledModule.settings.delayMicro,\r\n      \"f.back opearator\": controlledModule.settings.feedback,\r\n      \"send ck. (!)\":  controlledModule.settings.sendClock,\r\n    }\r\n  });\r\n\r\n  configurators.global.vars['delay (micro)'].changeFunction = function (thisVar, delta) {\r\n    thisVar.value += delta;\r\n    stepsBmp = numbers[thisVar.value] || 0b111;\r\n    passiveUpdateHardware();\r\n  }\r\n  configurators.global.vars['delay (micro)'].nameFunction = function (thisVar) {\r\n    let ms = controlledModule.clock.microSteps;\r\n    return thisVar.value+\" (\"+Math.round(100*thisVar.value/ms)/100+\"*\"+ms+\")\";\r\n  }\r\n  configurators.global.vars['f.back opearator'].nameFunction = function (thisVar) {\r\n    if (thisVar.value == 0) {\r\n      return \"no feedback\"\r\n    } else {\r\n      return \"e[3]-\" + thisVar.value + \"; e[3]>0\"\r\n    }\r\n  }\r\n  configurators.global.vars['f.back opearator'].changeFunction = function (thisVar, delta) {\r\n    thisVar.value += -delta;\r\n    if (thisVar.value < 0) thisVar.value = 128;\r\n    if (thisVar.value > 128) thisVar.value = 0;\r\n  }\r\n\r\n\r\n\r\n  this.outsideScroll = function (event) {\r\n    configurators.global.vars[\"delay (micro)\"].changeFunction(\r\n      configurators.global.vars[\"delay (micro)\"],\r\n      event.delta);\r\n    return configurators.global.vars[\"delay (micro)\"].nameFunction(\r\n      configurators.global.vars[\"delay (micro)\"]);\r\n  }\r\n\r\n\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = 0b0111100110010111;\r\n\r\n  var numbers = [\r\n    0b100101010100100,\r\n    0b100011001001110,\r\n    0b1110110000101110,\r\n    0b1110010010001110,\r\n    0b1010111010001000,\r\n    0b1110011010001110,\r\n    0b1110001011101110,\r\n    0b1110100001000100,\r\n    0b1110111010101110,\r\n    0b1110101011101000,\r\n    0b101101110110101,\r\n    0b101010101010101,\r\n    0b1101101101011111,\r\n    0b1111010110011111,\r\n  ]\r\n\r\n  var engagedHardwares = new Set();\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      stepsBmp ^= 1 << event.button;\r\n      console.log(stepsBmp.toString(2));\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    if (engagedConfigurator) { } else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n  var passiveUpdateHardware = function () {\r\n    engagedHardwares.forEach(function (hardware) {\r\n      updateLeds(hardware);\r\n    })\r\n  }\r\n  var animf = 0;\r\n  var updateLeds = function (hardware) {\r\n    // stepsBmp = makeAnimationBitmap({x:2,y:2},animf);\r\n\r\n    hardware.draw([0, stepsBmp, stepsBmp]);\r\n    animf++;\r\n    if (animf > 8) animf = 0;\r\n  }\r\n  // setInterval(function(){\r\n  //   engagedHardwares.forEach(function(hardware){\r\n  //     updateLeds(hardware);\r\n  //   })\r\n  // }, 700);\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/DelayClockBased/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/DelayClockBased/index.js":
/*!**********************************************!*\
  !*** ./src/modules/DelayClockBased/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * \r\n * \r\n * ideas:\r\n * add a \"feedback\" option. this involves the addition of an operator that modifies the feedback signal\r\n*/\r\n\r\n\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/DelayClockBased/InterfaceX16.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar DelayClockBased = function (properties) {\r\n\r\n  var thisInstance = this;\r\n  var myBitmap = 0;\r\n  var settings = this.settings = {\r\n    delayMicro: {\r\n      value: 0,\r\n    },\r\n    feedback: {\r\n      value: 0,\r\n    },\r\n    sendClock: {\r\n      value: false,\r\n    }\r\n  }\r\n  let clock = this.clock = {\r\n    microsteps: 12,\r\n    subSteps: 1,\r\n    subStep: 0,\r\n    step: 0\r\n  }\r\n\r\n  this.baseName = \"DelayClockBased\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n  this.interfaces.Http = __webpack_require__(/*! ./InterfaceHttp */ \"./src/modules/DelayClockBased/InterfaceHttp.js\");\r\n  var memory = this.memory = new Set();\r\n  var recMessages = {\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] })\r\n  }\r\n\r\n\r\n  var handleStepsChange = function () {\r\n    self.handle('~module', { steps: memory.size });\r\n  }\r\n\r\n\r\n  this.recordRate = function () {\r\n    recMessages.rate.value[2] = settings.delayMicro.value;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      var event = evt.eventMessage;\r\n      event.value.shift();\r\n      memory.add(event);\r\n      // handleStepsChange();\r\n    }\r\n  }\r\n\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      //microsteps are not taken into consideration by anything more than the user interface.\r\n      clock.microSteps = evt.eventMessage.value[1];\r\n      // var changed = false;\r\n      memory.forEach(function (evt) {\r\n        if (!evt.wait) evt.wait = settings.delayMicro.value;\r\n        evt.wait--;\r\n        if (evt.wait <= 0) {\r\n          self.output(evt);\r\n          if (settings.feedback.value) {\r\n            if (evt.value[3] == -1) evt.value[3] = 100;\r\n            if (evt.value[3] > 0) {\r\n              evt.value[3] = Math.max(0, evt.value[3] - settings.feedback.value);\r\n            } else {\r\n              memory.delete(evt);\r\n              // changed = true;\r\n            }\r\n          } else {\r\n            memory.delete(evt);\r\n            // changed = true;\r\n          }\r\n        }\r\n      })\r\n      // if (changed) handleStepsChange();\r\n      if (settings.sendClock.value)\r\n        memory.add(evt.eventMessage);\r\n\r\n    } else if (evt.eventMessage.value[0] == headers.changeRate) {\r\n      clock.subSteps = evt.eventMessage.value[2] / (evt.eventMessage.value[1] || 1);\r\n    } else {\r\n      memory.add(evt.eventMessage);\r\n      // handleStepsChange();\r\n    }\r\n  }\r\n\r\n  this.getBitmap16 = function () {\r\n    return myBitmap;\r\n  }\r\n\r\n  this.onRemove = function () {\r\n    memory.forEach(function (evt) {\r\n      memory.delete(evt);\r\n    });\r\n    return true;\r\n  }\r\n};\r\n\r\nDelayClockBased.color = [210, 0, 233];\r\nmodule.exports = DelayClockBased;\n\n//# sourceURL=webpack://environment/./src/modules/DelayClockBased/index.js?");

/***/ }),

/***/ "./src/modules/FixNoteLen/InterfaceX16.js":
/*!************************************************!*\
  !*** ./src/modules/FixNoteLen/InterfaceX16.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"duration (micro)\": controlledModule.settings.delayMicro,\r\n    }\r\n  });\r\n  configurators.global.vars['duration (micro)'].changeFunction=function(thisVar, delta) {\r\n    thisVar.value += delta;\r\n    stepsBmp = numbers[thisVar.value] || 0b111;\r\n    passiveUpdateHardware();\r\n  }\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.global;\r\n  var stepsBmp = 0b0111100110010111;\r\n\r\n  var numbers=[\r\n    0b100101010100100,\r\n    0b100011001001110,\r\n    0b1110110000101110,\r\n    0b1110010010001110,\r\n    0b1010111010001000,\r\n    0b1110011010001110,\r\n    0b1110001011101110,\r\n    0b1110100001000100,\r\n    0b1110111010101110,\r\n    0b1110101011101000,\r\n    0b101101110110101,\r\n    0b101010101010101,\r\n    0b1101101101011111,\r\n    0b1111010110011111,\r\n    0b1011111110011001,\r\n    0b1111011110010111,\r\n    0b1111001111111111,\r\n    0b1101100110011001,\r\n    0b1111111110111111,\r\n    0b1111111110011001,\r\n    0b1111111011011111,\r\n    0b1011101010011011,\r\n    0b1111101001011111,\r\n    0b1111111010011111,\r\n    0b1111111010011011,\r\n    0b1111011010011111,\r\n    0b1111011011011111,\r\n    0b1111101010011011,\r\n    0b1111111011011111,\r\n    0b1111111010011011,\r\n    0b1111111111101111,\r\n    0b1011101110101011,\r\n    0b1111101101101111,\r\n    0b1111111110101111,\r\n    0b1111111110101011\r\n  ]\r\n\r\n  var engagedHardwares = new Set();\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      stepsBmp^=1<<event.button;\r\n      console.log(stepsBmp.toString(2));\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    if (engagedConfigurator) { } else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.outsideScroll = function(event) {\r\n    controlledModule.settings.delayMicro.value += event.delta;\r\n    var ret = \"NoteLength:\"+controlledModule.settings.delayMicro.value;\r\n    stepsBmp = numbers[controlledModule.settings.delayMicro.value] || 0b111;\r\n    passiveUpdateHardware();\r\n    return (ret);\r\n  }\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n  var passiveUpdateHardware=function(){\r\n    engagedHardwares.forEach(function (hardware) {\r\n      updateLeds(hardware);\r\n    })\r\n  }\r\n  var animf=0;\r\n  var updateLeds = function (hardware) {\r\n    // stepsBmp = makeAnimationBitmap({x:2,y:2},animf);\r\n\r\n    hardware.draw([0, stepsBmp, stepsBmp]);\r\n    animf++;\r\n    if(animf>8) animf=0;\r\n  }\r\n  // setInterval(function(){\r\n  //   engagedHardwares.forEach(function(hardware){\r\n  //     updateLeds(hardware);\r\n  //   })\r\n  // }, 700);\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/FixNoteLen/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/FixNoteLen/index.js":
/*!*****************************************!*\
  !*** ./src/modules/FixNoteLen/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/FixNoteLen/InterfaceX16.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n @constructor\r\n the instance of the of the module, ment to be instantiated multiple times.\r\n require to moduleBase.call\r\n */\r\n\r\n\r\nvar FixNoteLen = function (properties) {\r\n  var thisInstance = this;\r\n  var myBitmap = 0;\r\n  var settings = this.settings = {\r\n    delayMicro: {\r\n      value: 0,\r\n    },\r\n    // feedback:{\r\n    //   value:0,\r\n    //   valueNames:['no','yes'],\r\n    // },\r\n  }\r\n  let clock = this.clock = {\r\n    subSteps: 1,\r\n    subStep: 0,\r\n    step: 0\r\n  }\r\n\r\n  \r\n  this.baseName = \"FixNoteLen\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n\r\n  var memory = new Set();\r\n  var recMessages = {\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] })\r\n  }\r\n  this.recordRate = function () {\r\n    recMessages.rate.value[2] = settings.delayMicro.value;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      var event = evt.eventMessage;\r\n      event.value.shift();\r\n      memory.add(event);\r\n    }\r\n    //backpropagate rec messages\r\n  }\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      memory.forEach(function (evt) {\r\n        if (!evt.wait) evt.wait = settings.delayMicro.value;\r\n        evt.wait--;\r\n        if (evt.wait <= 0) {\r\n          evt.value[0] = headers.triggerOff;\r\n          console.log(\"opt\", evt.value);\r\n          self.output(evt);\r\n          memory.delete(evt);\r\n        }\r\n      })\r\n    } else if (evt.eventMessage.value[0] == headers.changeRate) {\r\n      clock.subSteps = evt.eventMessage.value[2] / (evt.eventMessage.value[1] || 1);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      if (settings.delayMicro.value > 0) {\r\n        memory.add(evt.eventMessage);\r\n        self.output(evt.eventMessage);\r\n      }\r\n    }\r\n  }\r\n\r\n  this.getBitmap16 = function () {\r\n    return myBitmap;\r\n  }\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noff) {\r\n  //     thisInstance.output(noff, true);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n\r\n  this.handleStepsChange = function () {\r\n    self.handle('~module', { steps: runningNotes.length });\r\n  }\r\n\r\n};\r\n\r\nFixNoteLen.color = [210, 0, 233];\r\nmodule.exports = FixNoteLen;\n\n//# sourceURL=webpack://environment/./src/modules/FixNoteLen/index.js?");

/***/ }),

/***/ "./src/modules/GameOfLife/InterfaceX16.js":
/*!************************************************!*\
  !*** ./src/modules/GameOfLife/InterfaceX16.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n\r\nvar base=__webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\n\r\n//instance section\r\nmodule.exports = function(controlledModule) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.event = new EventConfigurator(this, {\r\n    baseEvent: controlledModule.baseEventMessage\r\n  });\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"step div\": {\r\n        value: controlledModule.clock.subSteps,\r\n        changeFunction:function(thisVar,delta){\r\n          thisVar.value+=delta;\r\n          if(thisVar.value<-4){\r\n            thisVar.value-=delta;\r\n          }else if(thisVar.value<1){\r\n            controlledModule.clock.subSteps=Math.pow(2,thisVar.value);//go by 12 divisible numbers: Math.floor( Math.pow(2,-1)/(1/12) )/12\r\n          }else{\r\n            controlledModule.clock.subSteps=thisVar.value;\r\n          }\r\n          console.log(controlledModule.clock);\r\n        },\r\n        nameFunction:function(thisVar){\r\n          return \"to \"+controlledModule.clock.subSteps;\r\n        }\r\n      },\r\n      \"duration\": controlledModule.settings.duration\r\n    }\r\n  });\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = 0;\r\n\r\n  function hasEvent(button) {\r\n    return 0 != (controlledModule.getBitmap16() & (1 << button));\r\n  }\r\n  var engagedHardwares = new Set();\r\n  controlledModule.on('step', function() {\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  });\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      controlledModule.toggleStep(event.button);\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    if (engagedConfigurator) {} else {\r\n      // controlledModule.clearStep(event.button);\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function(event) {};\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 1) {\r\n        engagedConfigurator = configurators.event;\r\n        configurators.event.engage(event);\r\n      }\r\n      if (event.data[0] == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 1) {\r\n      if (engagedConfigurator == configurators.event) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator = false;\r\n        configurators.event.disengage({\r\n          hardware: hardware\r\n        });\r\n      }\r\n    }if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function(hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    stepsBmp = controlledModule.getBitmap16();\r\n    hardware.draw([0, stepsBmp, stepsBmp]);\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/GameOfLife/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/GameOfLife/index.js":
/*!*****************************************!*\
  !*** ./src/modules/GameOfLife/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/GameOfLife/InterfaceX16.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar GameOfLife = function (properties) {\r\n  var noteOnTracker = new NoteOnTracker(this);\r\n  var thisInstance = this;\r\n  var myBitmap = 0;\r\n  var settings = this.settings = {\r\n    duration: { value: false }\r\n  }\r\n  var clock = this.clock = {\r\n    subSteps: 4,\r\n    subStep: 0\r\n  }\r\n  this.baseName = \"game of life\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n  var baseEventMessage = this.baseEventMessage = new EventMessage({\r\n    value: [headers.triggerOn, -1, -1, -1]\r\n  });\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n\r\n  var cells = [\r\n    [0, 0, 0, 0],\r\n    [0, 0, 0, 0],\r\n    [0, 0, 0, 0],\r\n    [0, 0, 0, 0]\r\n  ];\r\n  var fixedCells = 0;\r\n  var setStep = this.setStep = function (square) {\r\n    while (square < 0) square += 16;\r\n    // console.log(\"st\",square);\r\n    myBitmap |= 1 << square;\r\n    cells[Math.floor(square / 4)][square % 4] = 1;\r\n  }\r\n  var clearStep = this.clearStep = function (square) {\r\n    myBitmap &= ~(1 << square);\r\n    cells[Math.floor(square / 4)][square % 4] = 0;\r\n  }\r\n\r\n  var toggleStep = this.toggleStep = function (square) {\r\n    var x = Math.floor(square / 4);\r\n    var y = square % 4;\r\n    // console.log(x,y);\r\n    if (cells[x][y] == 1) {\r\n\r\n      clearStep(square);\r\n    } else {\r\n\r\n      setStep(square);\r\n    }\r\n    return myBitmap;\r\n  }\r\n\r\n  var setFixedStep = this.setFixedStep = function (square) {\r\n    fixedCells |= 1 << square;\r\n    setStep(square);\r\n  }\r\n  var clearFixedStep = this.clearFixedStep = function (square) {\r\n    fixedCells &= ~(1 << square);\r\n    clearStep(square);\r\n  }\r\n  var toggleFixedStep = this.toggleFixedStep = function (square) {\r\n    var x = Math.floor(square / 4);\r\n    var y = square % 4;\r\n    if (cells[x][y]) {\r\n      clearFixedStep(square);\r\n    } else {\r\n      setFixedStep(square);\r\n    }\r\n    return myBitmap;\r\n  }\r\n\r\n  this.cellOutput = function (x, y, val) {\r\n    if (self.mute) return;\r\n    if (val) {\r\n      var outMessage = new EventMessage.from(baseEventMessage);\r\n      outMessage.value[1] = baseEventMessage.value[1] + (x * 4 + y);\r\n      noteOnTracker.add(outMessage, [x, y]);\r\n      // console.log(\"ON\",outMessage.value);\r\n      thisInstance.output(outMessage);\r\n    } else {\r\n\r\n    }\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      evt.eventMessage.value.shift();\r\n      thisInstance.messageReceived(evt);\r\n    }\r\n  }\r\n  this.messageReceived = function (evt) {\r\n    //to achieve microsteps divisions\r\n\r\n    var eventMessage = evt.eventMessage;\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      var microStep = eventMessage.value[2];\r\n      var microSteps = eventMessage.value[1];\r\n      if (clock.subSteps < 1) {\r\n        microSteps *= clock.subSteps;\r\n        console.log(\"MCL\", microStep % microSteps);\r\n      }\r\n      if (microStep % microSteps == 0) {\r\n        clock.subStep++;\r\n        if (clock.subStep >= clock.subSteps) {\r\n          clock.subStep = 0;\r\n          if (settings.duration.value) {\r\n            noteOnTracker.empty(function (noff) {\r\n              // console.log(\"OFF\",noff.value);\r\n              thisInstance.output(noff, true);\r\n            });\r\n            cellOperation();\r\n          } else {\r\n            cellOperation();\r\n            noteOnTracker.empty(function (noff) {\r\n              // console.log(\"OFF\",noff.value);\r\n              thisInstance.output(noff, true);\r\n            });\r\n          }\r\n          this.handle('step');\r\n        }\r\n      }\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      // this.setFixedStep(evt.eventMessage.value[2]%16);\r\n      this.setStep(evt.eventMessage.value[1] % 16);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      // this.clearFixedStep(evt.eventMessage.value[2]%16);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff + 1) {\r\n      // this.setStep(evt.eventMessage.value[2]%16);\r\n    }\r\n  }\r\n\r\n  this.getBitmap16 = function () {\r\n    return myBitmap;\r\n  }\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noff) {\r\n  //     thisInstance.output(noff, true);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n\r\n  function cellOperation() {\r\n    // console.log(\"step\");\r\n    for (var x in cells) {\r\n      for (var y in cells[x]) {\r\n        var neighbours = 0;\r\n        x = parseFloat(x);\r\n        y = parseFloat(y);\r\n        var left = x - 1;\r\n        if (left == -1) left = 3;\r\n        var right = x + 1;\r\n        if (right == 4) right = 0;\r\n        var top = y - 1;\r\n        if (top == -1) top = 3;\r\n        var bott = y + 1;\r\n        if (bott == 4) bott = 0;\r\n\r\n        // console.log(\"x\"+x,\"y\"+y,\"left\"+left,\"right\"+right,\"top\"+top,\"bott\"+bott);\r\n\r\n        neighbours += cells[left][top];\r\n        neighbours += cells[left][y];\r\n        neighbours += cells[left][bott];\r\n\r\n        neighbours += cells[x][top];\r\n        // neighbours+=cells[x][y];\r\n        neighbours += cells[x][bott];\r\n\r\n        neighbours += cells[right][top];\r\n        neighbours += cells[right][y];\r\n        neighbours += cells[right][bott];\r\n\r\n        var linearCord = (x * 4 + y);\r\n\r\n        // if(fixedCells &(1<<linearCord)){\r\n        //   cells[x][y]=1;\r\n        //   myBitmap|=1<<linearCord;\r\n        // }else{\r\n        if (neighbours < 2 || neighbours > 3) {\r\n          myBitmap &= ~(1 << linearCord);\r\n        } else if (neighbours == 3) {\r\n          myBitmap |= 1 << linearCord;\r\n        }\r\n        // }\r\n      }\r\n    }\r\n    // myBitmap|=fixedCells;\r\n    for (var a = 0; a < 16; a++) {\r\n      var x = Math.floor(a / 4);\r\n      var y = a % 4;\r\n      var set = myBitmap >> a & 1;\r\n      cells[x][y] = set;\r\n      thisInstance.cellOutput(x, y, set > 0);\r\n    }\r\n  }\r\n};\r\n\r\nGameOfLife.color = [255, 0, 233];\r\nmodule.exports = GameOfLife;\n\n//# sourceURL=webpack://environment/./src/modules/GameOfLife/index.js?");

/***/ }),

/***/ "./src/modules/Harmonizer/InterfaceX28.js":
/*!************************************************!*\
  !*** ./src/modules/Harmonizer/InterfaceX28.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\nvar scaleNames = __webpack_require__(/*! ./scaleNames.js */ \"./src/modules/Harmonizer/scaleNames.js\");\r\n\r\n/**\r\nTODO: interfaces should be extended by the environment, instead of being required on each module,\r\nin the same way how modules are extended.\r\n*/\r\nvar base = __webpack_require__(/*! ../../interaction/x28basic/interactorBase.js */ \"./src/interaction/x28basic/interactorBase.js\");\r\n\r\n/**\r\ndefinition of a harmonizer interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function (controlledModule, environment) {\r\n  base.call(this);\r\n\r\n  var self = this;\r\n  var thisInterface = this;\r\n  var fingerMap = 0x0000;\r\n  var scaleSelectionMap = controlledModule.currentScale;\r\n  var compressedScaleMaps = undefined;\r\n  var scaleIntervalsMap;\r\n  var noteHiglightMap = 0;\r\n  var performMode = true;\r\n  var currentScale = 0;\r\n  var copyingScale = false;\r\n  var engaged = false;\r\n\r\n  var shiftScrollingMode=false;\r\n  //configurators setup\r\n\r\n\r\n  var configurators = {};\r\n\r\n  var keyboardRoot = {\r\n    value: 0,\r\n    changeFunction: function (thisVar, delta, event) {\r\n      var hin = event.hardware.instanceNumber;\r\n      if (hardwareLocals[hin]) {\r\n        hardwareLocals[hin].keyboardRoot += delta;\r\n        thisVar.value = hardwareLocals[hin].keyboardRoot;\r\n      }\r\n    }\r\n\r\n  };\r\n\r\n  var keyboardChan = {\r\n    value: 0,\r\n    changeFunction: function (thisVar, delta, event) {\r\n      var hin = event.hardware.instanceNumber;\r\n      if (hardwareLocals[hin]) {\r\n        hardwareLocals[hin].keyboardChan += delta;\r\n        thisVar.value = hardwareLocals[hin].keyboardChan;\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  var hardwareLocals = {}\r\n\r\n\r\n\r\n\r\n  configurators.event = new EventConfigurator(this, {\r\n    baseEvent: controlledModule.defaultNote,\r\n    extraVariables: {\r\n      \"keyboard base\": keyboardRoot,\r\n      \"keyboard chan\": keyboardChan\r\n    },\r\n    name: \"Msg & Perform\",\r\n    valueNames: [\"func\", \"set chan\", \"root n\", \"velo\"]\r\n  });\r\n\r\n  configurators.global = new BlankConfigurator(this, {\r\n    vars: {\r\n      \"expand mode\": {\r\n        value:controlledModule.mapMode,\r\n        changeFunction:function(thisVar,delta){\r\n          thisVar.value=thisVar.value==false;\r\n          controlledModule.mapMode=thisVar.value;\r\n        }\r\n      },\r\n      \"transpose input\": {\r\n        value:controlledModule.transpose.input,\r\n        changeFunction:function(thisVar,delta){\r\n          if(shiftScrollingMode) delta*=12;\r\n          thisVar.value+=delta;\r\n          controlledModule.transpose.input=thisVar.value;\r\n        }\r\n      },\r\n      \"transpose output\": {\r\n        value:controlledModule.transpose.output,\r\n        changeFunction:function(thisVar,delta){\r\n          if(shiftScrollingMode) delta*=12;\r\n          thisVar.value+=delta;\r\n          controlledModule.transpose.output=thisVar.value;\r\n        }\r\n      },\r\n      \"(unfinished)\": {//comp. transpose\r\n        value:false,\r\n        changeFunction:function(thisVar,delta){\r\n          // if(shiftScrollingMode) delta*=12;\r\n          //\r\n          // var oldInput=controlledModule.transpose.input;\r\n          // var oldOutput=controlledModule.transpose.output;\r\n          //\r\n          // controlledModule.transpose.input=0;\r\n          // controlledModule.transpose.output=0;\r\n          // //inputTransformNumber already uses transpose values;\r\n          // controlledModule.transpose.output = controlledModule.inputTransformNumber((oldOutput - oldInput) - delta);\r\n          //\r\n          // controlledModule.transpose.input=oldInput-delta;\r\n          //\r\n          // if(isNaN(controlledModule.transpose.output)){\r\n          //   console.warn(\"controlledModule.transpose.output is NaN, forcing it to 0\");\r\n          //   controlledModule.transpose.output=0;\r\n          // }\r\n        },\r\n        nameFunction:function(){\r\n          return \"in:\"+controlledModule.transpose.input+\" out:\"+controlledModule.transpose.output;\r\n        }\r\n      },\r\n    }\r\n  });\r\n\r\n\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  })\r\n\r\n  var engagedHardwares = new Set();\r\n  controlledModule.on('noteplayed', function (evt) {\r\n\r\n    // console.log(controlledModule.defaultNote.testvar);\r\n    // console.log(configurators.event.baseEvent);\r\n    var relativeNote = (evt.triggeredNote - controlledModule.defaultNote.note()) % 12;\r\n    // console.log(relativeNote);\r\n    var newH = noteHiglightMap |= 4097 << relativeNote;\r\n\r\n    setTimeout(function () {\r\n      noteHiglightMap &= ~newH;\r\n    }, 300);\r\n    passiveUpdateLeds();\r\n  });\r\n  controlledModule.on('chordchange', function () {\r\n    for (let hardware of engagedHardwares) {\r\n      updateHardware(hardware);\r\n    }\r\n  });\r\n  var selectScaleMap = function (num) {\r\n    if ((currentScale == 1 && num == 1) || (currentScale == 4 && num == 4) || (currentScale == 2 && num == 2) || (currentScale == 8 && num == 8)) {\r\n      currentScale = 0;\r\n    } else {\r\n      currentScale = num;\r\n    };\r\n    if (performMode)\r\n      controlledModule.uiScaleChange(currentScale);\r\n    scaleIntervalsMap = controlledModule.getScaleMap(currentScale);\r\n    for(var hin in hardwareLocals){\r\n      hardwareLocals[hin].compressedScaleMaps = undefined;\r\n    }\r\n  }\r\n  var updateScaleMap = function (newScaleMap) {\r\n    scaleIntervalsMap = newScaleMap;\r\n    controlledModule.newScaleMap(currentScale, newScaleMap);\r\n    for(var hin in hardwareLocals){\r\n      hardwareLocals[hin].compressedScaleMaps = undefined;\r\n    }\r\n  }\r\n\r\n  controlledModule.on('messagesend', function (ev) {\r\n  });\r\n\r\n  //interaction with hardware\r\n\r\n\r\n\r\n  this.engage = function (event) {\r\n    var hardware = event.hardware;\r\n    var hin = event.hardware.instanceNumber;\r\n\r\n    if (!hardwareLocals[hin]) hardwareLocals[hin] = {\r\n      keyboardRoot: 0,\r\n      keyboardChan: 0,\r\n      engagedConfigurator: false,\r\n      lastEngagedConfigurator: configurators.event,\r\n    }\r\n\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n    updateLeds(hardware);\r\n\r\n    // self.on('interaction', function (a, b, c) {\r\n    //   console.log(\"H\", a, b, c);\r\n    // })\r\n\r\n\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n\r\n    // self.off('interaction');\r\n  }\r\n\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    // console.log(event.data);\r\n    var hardware = event.hardware;\r\n    var hin = event.hardware.instanceNumber;\r\n\r\n    var button = event.data[0];\r\n    var eventFingerMap = event.data[2];\r\n    // console.log(eventFingerMap);\r\n    if (hardwareLocals[hin].engagedConfigurator === false) {\r\n      if (performMode) {\r\n        var triggerKey = event.data[0] + hardwareLocals[hin].keyboardRoot;\r\n        controlledModule.uiTriggerOn(triggerKey, new EventMessage({\r\n          value: [-1, triggerKey, hardwareLocals[hin].keyboardChan]\r\n        }));\r\n      } else {\r\n        var grade = event.data[0] % 12;\r\n        updateScaleMap(scaleIntervalsMap ^ (1 << grade));\r\n        updateHardware(hardware);\r\n      }\r\n    } else {\r\n      hardwareLocals[hin].engagedConfigurator.matrixButtonPressed(event);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    var hin = hardware.instanceNumber;\r\n    if (hardwareLocals[hin].engagedConfigurator === false) {\r\n      controlledModule.uiTriggerOff(event.data[0] + hardwareLocals[hin].keyboardRoot, hardwareLocals[hin].keyboardChan);\r\n      updateLeds(hardware);\r\n\r\n    } else {\r\n      hardwareLocals[hin].engagedConfigurator.matrixButtonReleased(event);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n\r\n    var hin = event.hardware.instanceNumber;\r\n    if (hardwareLocals[hin].engagedConfigurator) {\r\n      hardwareLocals[hin].engagedConfigurator.selectorButtonPressed(event);\r\n    }\r\n\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 1) {\r\n      hardwareLocals[hin].engagedConfigurator = configurators.event;\r\n      configurators.event.engage(event);\r\n    } else if (event.data[0] == 2) {\r\n      if (performMode) {\r\n        hardwareLocals[hin].engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      } else {\r\n        copyingScale = currentScale;\r\n        event.hardware.sendScreenA('copy scale to...');\r\n        event.hardware.sendScreenB('(release)');\r\n      }\r\n    } else if (event.data[0] == 0) {\r\n      performMode = !performMode;\r\n      updateHardware(hardware);\r\n    } else if (event.button >= 8) {\r\n      configurators.record.engage(event);\r\n    } else if (event.button >= 4) {\r\n      scaleSelectionMap ^= 1 << (event.data[0] - 4);\r\n      selectScaleMap(scaleSelectionMap);\r\n      // updateHardware(hardware);\r\n    }\r\n\r\n    hardwareLocals[hin].lastEngagedConfigurator = hardwareLocals[hin].engagedConfigurator;\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n\r\n    var hin = event.hardware.instanceNumber;\r\n    if (hardwareLocals[hin].engagedConfigurator) {\r\n      hardwareLocals[hin].engagedConfigurator.disengage(event);\r\n      hardwareLocals[hin].engagedConfigurator=false;\r\n    }\r\n    if (event.data[0] == 1) {\r\n      hardwareLocals[hin].engagedConfigurator = false;\r\n      configurators.event.disengage(event);\r\n    } else if (event.data[0] == 2) {\r\n      if (copyingScale !== false) {\r\n        updateScaleMap(controlledModule.getScaleMap(copyingScale));\r\n        updateHardware(hardware);\r\n        copyingScale = false;\r\n      } else {\r\n        hardwareLocals[hin].engagedConfigurator = false;\r\n\r\n      }\r\n    } else if (event.data[0] == 3) {\r\n\r\n    } else if (event.button >= 8) {\r\n      configurators.record.disengage(event);\r\n      hardwareLocals[hin].engagedConfigurator = false;\r\n    } else if (event.button >= 4) {\r\n      // scaleSelectionMap &= ~(1<<(event.data[0]-4));\r\n      // selectScaleMap(scaleSelectionMap);\r\n      // updateHardware(hardware);\r\n    }\r\n    updateHardware(hardware);\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n\r\n    var hin = event.hardware.instanceNumber;\r\n    var hardware = event.hardware;\r\n    if (hardwareLocals[hin].lastEngagedConfigurator) {\r\n      hardwareLocals[hin].lastEngagedConfigurator.encoderScrolled(event);\r\n      if (hardwareLocals[hin].lastEngagedConfigurator == configurators.event) {\r\n        hardwareLocals[hin].compressedScaleMaps = undefined;\r\n        updateLeds(event.hardware);\r\n      }\r\n    }\r\n    updateLeds(hardware);\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n\r\n  configurators.record.autoEngageWindow();\r\n\r\n  var passiveUpdateLeds = function () {\r\n\r\n    for (var hardware of engagedHardwares) {\r\n      var hin = hardware.instanceNumber;\r\n      if (!hardwareLocals[hin].engagedConfigurator)\r\n      updateLeds(hardware);\r\n    }\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    currentScale = controlledModule.currentScale;\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateLeds = function (hardware) {\r\n    var selScaleMap = (scaleSelectionMap & 0xf);\r\n    // hardware.paintColorFromLedN(0,[0,0,0],0,false);\r\n    hardware.paintColorFromLedN(selScaleMap << 4, [255, 127, 0], 0, false);\r\n\r\n    var hin = hardware.instanceNumber;\r\n    if (performMode) {\r\n      if (hardwareLocals[hin].compressedScaleMaps === undefined) {\r\n        hardwareLocals[hin].compressedScaleMaps = controlledModule.getCompMaps(currentScale, hardwareLocals[hin].keyboardRoot);\r\n      }\r\n\r\n      hardware.draw([\r\n        hardwareLocals[hin].compressedScaleMaps.roots,\r\n        hardwareLocals[hin].compressedScaleMaps.roots,\r\n        hardwareLocals[hin].compressedScaleMaps.semitones[1]\r\n      ]);\r\n\r\n    } else {\r\n      if (scaleIntervalsMap === undefined) {\r\n        scaleIntervalsMap = controlledModule.getScaleMap(currentScale);\r\n      }\r\n\r\n      var SNN = scaleIntervalsMap;\r\n\r\n      SNN |= SNN << 12;\r\n\r\n      hardware.draw([SNN | noteHiglightMap, noteHiglightMap, 0x5AB5 | noteHiglightMap | SNN]);\r\n    }\r\n  }\r\n  var updateScreen = function (hardware, upleds = true, upscreen = true) {\r\n\r\n    var hin = hardware.instanceNumber;\r\n    var screenAString = \"\";\r\n    var screenBString = \"\";\r\n    if (performMode) {\r\n      if (!hardwareLocals[hin].engagedConfigurator) screenAString += \"Perform \"\r\n    } else {\r\n      if (!hardwareLocals[hin].engagedConfigurator) screenAString += \"Edit \";\r\n    }\r\n    if (controlledModule.scaleArray[currentScale]) {\r\n      var currentScaleName = scaleNames.scaleToName[scaleIntervalsMap];\r\n      if (currentScaleName) {\r\n        screenAString = currentScaleName + \"-\" + screenAString;\r\n      } else {\r\n        screenAString += \"chord \" + currentScale + \": \" + controlledModule.scaleArray[currentScale].length;\r\n      }\r\n    } else {\r\n      screenAString += \"chord \" + currentScale + \": empty\";\r\n    }\r\n    if (upscreen)\r\n      hardware.sendScreenA(screenAString);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Harmonizer/InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/Harmonizer/index.js":
/*!*****************************************!*\
  !*** ./src/modules/Harmonizer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar Note = __webpack_require__(/*! ../moduleUtils/Note */ \"./src/modules/moduleUtils/Note.js\");\r\nvar scaleNames = __webpack_require__(/*! ./scaleNames.js */ \"./src/modules/Harmonizer/scaleNames.js\");\r\nvar headers = EventMessage.headers;\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n\r\nvar InterfaceX28 = __webpack_require__(/*! ./InterfaceX28 */ \"./src/modules/Harmonizer/InterfaceX28.js\");\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n*/\r\n\r\nvar instanced = 0;\r\nvar baseName = \"harmonizer\";\r\nvar name = function () {\r\n  this.name = baseName + \" \" + instanced;\r\n  instanced++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar Harmonizer = function (properties, environment) {\r\n  if (properties.name) {\r\n    this.name = properties.name;\r\n  } else {\r\n    name.call(this);\r\n  };\r\n  this.preventBus = true;\r\n\r\n  var self = this;\r\n  this.recordingUi = true;\r\n  this.currentScale = 0;\r\n  var noteOnTracker = new NoteOnTracker(this);\r\n  this.mapMode = true;\r\n  var transpose = this.transpose = {input:0,output:36};\r\n  // this.baseNote={value:0};\r\n\r\n  this.defaultNote = new Note();\r\n  // this.defaultNote.testvar=\"hi\";\r\n  this.defaultNote.note(0);\r\n\r\n  var scaleMap = {};\r\n  //keep track of triggered notes\r\n  this.scaleArray = {};\r\n\r\n  function defaultState() {\r\n    var c = 0;\r\n    for (let scale in scaleNames.nameToScale) {\r\n      self.newScaleMap(c, scaleNames.nameToScale[scale]);\r\n      if (c++ > 15) break;\r\n    }\r\n  }\r\n\r\n\r\n  this.uiScaleChange = function (scalen) {\r\n    self.currentScale = scalen;\r\n    self.handle('chordchange');\r\n    if (self.recordingUi) {\r\n      self.recordOutput(new EventMessage({\r\n        value: [\r\n          headers.changePreset, scalen\r\n        ]\r\n      }));\r\n    }\r\n  }\r\n\r\n  this.uiTriggerOn = function (gradeNumber, underImpose = false) {\r\n    if (self.mute) return;\r\n    var transformedNumber = inputTransformNumber(gradeNumber);\r\n    if (transformedNumber !== false) {\r\n      var newEvent = new Note(self.defaultNote);\r\n      newEvent.note(transformedNumber);\r\n      if (underImpose) newEvent.underImpose(underImpose);\r\n      if (self.recordingUi) {\r\n        var uiGeneratedEvent = new Note();\r\n        uiGeneratedEvent.note(gradeNumber);\r\n        uiGeneratedEvent.timbre(-1);\r\n        uiGeneratedEvent.velo(-1);\r\n\r\n        if (underImpose) {\r\n          uiGeneratedEvent.underImpose(underImpose);\r\n        }\r\n        noteOnTracker.add(uiGeneratedEvent, [\"REC\", gradeNumber]);\r\n        self.recordOutput(uiGeneratedEvent);\r\n      }\r\n      applyDefaultNote(newEvent);\r\n\r\n      self.output(newEvent);\r\n      noteOnTracker.add(newEvent, [\"UI\", gradeNumber]);\r\n      self.handle('noteplayed', {\r\n        triggeredGrade: gradeNumber,\r\n        triggeredNote: newEvent.value[1]\r\n      });\r\n    }\r\n  }\r\n\r\n  this.uiTriggerOff = function (gradeNumber) {\r\n    noteOnTracker.ifNoteOff([\"UI\", gradeNumber], function (noteOff) {\r\n      self.output(noteOff);\r\n    });\r\n    noteOnTracker.ifNoteOff([\"REC\", gradeNumber], function (noteOff) {\r\n      let nnoff = noteOff.clone();\r\n      nnoff.value[0] = headers.triggerOff;\r\n      self.recordOutput(nnoff);\r\n    });\r\n  }\r\n  function applyDefaultNote(event) {\r\n    // console.log(\"APP\",event.value);\r\n    var keepNote = self.defaultNote.note();\r\n    self.defaultNote.note(-1);\r\n    event.superImpose(self.defaultNote);\r\n    self.defaultNote.note(keepNote);\r\n    event.value[1] += keepNote;\r\n    // console.log(\" --\", event.value);\r\n  }\r\n  this.triggerOn = function (gradeNumber, underImpose = false) {\r\n    if (self.mute) return;\r\n    var transformedNumber = inputTransformNumber(gradeNumber);\r\n    if (transformedNumber !== false) {\r\n      var newEvent = new Note(self.defaultNote);\r\n      newEvent.note(transformedNumber);\r\n      if (underImpose) newEvent.underImpose(underImpose);\r\n\r\n      applyDefaultNote(newEvent);\r\n\r\n      //underimpose.value, should't be index 2 actually?\r\n      noteOnTracker.add(newEvent, [\"EX\", gradeNumber, underImpose.value[2]]);\r\n      self.output(newEvent);\r\n      self.handle('noteplayed', {\r\n        triggeredGrade: gradeNumber,\r\n        triggeredNote: newEvent.value[1]\r\n      });\r\n    }\r\n  }\r\n\r\n  this.triggerOff = function (gradeNumber, underImpose) {\r\n    noteOnTracker.ifNoteOff([\"EX\", gradeNumber, underImpose.value[2]], function (noteOff) {\r\n      self.output(noteOff);\r\n    });\r\n  }\r\n\r\n  var inputTransformNumber = this.inputTransformNumber = function (inputNumber) {\r\n    var ret;\r\n    inputNumber+=transpose.input;\r\n    if (self.scaleArray[self.currentScale]) {\r\n      var scaleLength = self.scaleArray[self.currentScale].length;\r\n      if (self.mapMode == true) {\r\n        var octave = Math.floor(inputNumber / scaleLength);\r\n        var noteWraped = self.scaleArray[self.currentScale][inputNumber % scaleLength];\r\n        ret = noteWraped + (12 * octave);\r\n      } else {\r\n        // console.log(\"FLOORMODE\");\r\n        var nearestGrade = 0;\r\n        var octave = Math.floor(inputNumber / 12);\r\n        var noteWraped = inputNumber % 12;\r\n        //scaleArray is always in increasing order\r\n        for (var a in self.scaleArray[self.currentScale]) {\r\n          if (self.scaleArray[self.currentScale][a] <= noteWraped) {\r\n            nearestGrade = self.scaleArray[self.currentScale][a];\r\n            // console.log(\"NEARE\",nearestGrade);\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        ret = nearestGrade + (12 * octave);\r\n      }\r\n      ret+=transpose.output;\r\n      return ret;// + self.defaultNote.note();\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n  this.messageReceived = function (event) {\r\n    var eventMessage = event.eventMessage\r\n    if (!self.mute)\r\n      if (eventMessage.value[0] == headers.triggerOff || eventMessage.value[3] == 0) {\r\n        self.triggerOff(eventMessage.value[1], eventMessage);\r\n      } else {\r\n        this.handle('receive', eventMessage);\r\n        if (eventMessage.value[0] == headers.changePreset) {\r\n          self.currentScale = eventMessage.value[1];\r\n          // console.log(\"change preset\", self.currentScale);\r\n          self.handle('chordchange');\r\n        } else if (eventMessage.value[0] == 1) {\r\n          // console.log(\"TRIGGERON\");\r\n          self.triggerOn(eventMessage.value[1], eventMessage);\r\n        } else {\r\n          // console.log(\"wasted event\",eventMessage,(eventMessage.value[0]|0xf)+\"=!\"+0);\r\n        }\r\n      }\r\n  }\r\n  this.newScaleMap = function (identifier, to) {\r\n    // console.log(\"scale map update \"+identifier);\r\n    scaleMap[identifier] = to;\r\n    self.scaleArray[identifier] = [];\r\n    var count = 0;\r\n    for (var a = 0; a < 12; a++) {\r\n      if ((scaleMap[identifier] >> a) & 1) {\r\n        self.scaleArray[identifier].push(a);\r\n      }\r\n    }\r\n    self.handle('chordchange');\r\n  }\r\n  this.getScaleMap = function (identifier) {\r\n    return scaleMap[identifier] || 0x00;\r\n  }\r\n  this.getScaleName = function (identifier) {\r\n    return scaleNames.scaleToName[self.getScaleMap(identifier)] || \"unknown scale\";\r\n  }\r\n\r\n  this.getCompMaps = function (identifier, shift = 0) {\r\n    var ret = {\r\n      roots: 1,\r\n      semitones: [0, 0, 0, 0]\r\n    }\r\n    var scaleLength = self.scaleArray[identifier].length;\r\n    var wrapShift = (scaleLength - shift % scaleLength) % scaleLength;\r\n\r\n    ret.roots = ret.roots << wrapShift;\r\n\r\n    for (let a = 0; a < 16; a += scaleLength) {\r\n      ret.roots |= ret.roots << a;\r\n    }\r\n\r\n    let lastNote = 0;\r\n    for (let n in self.scaleArray[identifier]) {\r\n      let itm = self.scaleArray[identifier][n];\r\n      let interval = itm - lastNote;\r\n      if (ret.semitones[interval] !== undefined) {\r\n        ret.semitones[interval] |= (1 << scaleLength) << (n);\r\n      }\r\n      lastNote = itm;\r\n    }\r\n\r\n    for (var b in ret.semitones) {\r\n      ret.semitones[b] = ret.semitones[b] << wrapShift;\r\n      ret.semitones[b] |= (ret.semitones[b]) >> scaleLength;\r\n      ret.semitones[b] |= (ret.semitones[b]) >> scaleLength;\r\n      for (let a = 0; a < 16; a += scaleLength) {\r\n        ret.semitones[b] |= ret.semitones[b] << a;\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  this.interfaces.X28 = InterfaceX28;\r\n\r\n  defaultState();\r\n\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noteOff) {\r\n  //     self.output(noteOff);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n}\r\n\r\nHarmonizer.color = [255, 255, 127];\r\nmodule.exports = Harmonizer;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Harmonizer/index.js?");

/***/ }),

/***/ "./src/modules/Harmonizer/old_InterfaceX28.js":
/*!****************************************************!*\
  !*** ./src/modules/Harmonizer/old_InterfaceX28.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\nvar scaleNames = __webpack_require__(/*! ./scaleNames.js */ \"./src/modules/Harmonizer/scaleNames.js\");\r\n\r\n/**\r\nTODO: interfaces should be extended by the environment, instead of being required on each module,\r\nin the same way how modules are extended.\r\n*/\r\nvar base = __webpack_require__(/*! ../../interaction/x28basic/interactorBase.js */ \"./src/interaction/x28basic/interactorBase.js\");\r\n\r\n/**\r\ndefinition of a harmonizer interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function (controlledModule, environment) {\r\n  base.call(this);\r\n\r\n  var self = this;\r\n  var thisInterface = this;\r\n  var fingerMap = 0x0000;\r\n  var scaleSelectionMap = controlledModule.currentScale;\r\n  var compressedScaleMaps = undefined;\r\n  var scaleIntervalsMap;\r\n  var noteHiglightMap = 0;\r\n  var performMode = true;\r\n  var currentScale = 0;\r\n  var copyingScale = false;\r\n  var engaged = false;\r\n  //configurators setup\r\n  var engagedConfigurator = false;\r\n  var configurators = {};\r\n\r\n  var keyboardRoot = {\r\n    value: 0,\r\n    changeFunction: function (thisVar, delta, event) {\r\n      var hin = event.hardware.instanceNumber;\r\n      if (hardwareLocals[hin]) {\r\n        hardwareLocals[hin].keyboardRoot += delta;\r\n        thisVar.value = hardwareLocals[hin].keyboardRoot;\r\n      }\r\n    }\r\n\r\n  };\r\n\r\n  var keyboardChan = {\r\n    value: 0,\r\n    changeFunction: function (thisVar, delta, event) {\r\n      var hin = event.hardware.instanceNumber;\r\n      if (hardwareLocals[hin]) {\r\n        hardwareLocals[hin].keyboardChan += delta;\r\n        thisVar.value = hardwareLocals[hin].keyboardChan;\r\n      }\r\n    }\r\n  };\r\n\r\n  var hardwareLocals = {}\r\n\r\n\r\n\r\n\r\n  configurators.event = new EventConfigurator(this, {\r\n    baseEvent: controlledModule.defaultNote,\r\n    extraVariables: {\r\n      \"keyboard base\": keyboardRoot,\r\n      \"keyboard chan\": keyboardChan\r\n    },\r\n    name: \"Msg & Perform\",\r\n    valueNames: [\"func\", \"set chan\", \"root n\", \"velo\"]\r\n  });\r\n  // configurators.event.addextraVariables();\r\n  var lastEngagedConfigurator = configurators.event;\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  })\r\n\r\n\r\n  //interaction with controlledModule\r\n  var currentStep = controlledModule.currentStep;\r\n  var loopLength = controlledModule.loopLength;\r\n  var engagedHardwares = new Set();\r\n  controlledModule.on('noteplayed', function (evt) {\r\n\r\n    // console.log(controlledModule.defaultNote.testvar);\r\n    // console.log(configurators.event.baseEvent);\r\n    var relativeNote = (evt.triggeredNote - controlledModule.defaultNote.note()) % 12;\r\n    // console.log(relativeNote);\r\n    var newH = noteHiglightMap |= 4097 << relativeNote;\r\n\r\n    setTimeout(function () {\r\n      noteHiglightMap &= ~newH;\r\n    }, 300);\r\n    passiveUpdateLeds();\r\n  });\r\n  controlledModule.on('chordchange', function () {\r\n    for (let hardware of engagedHardwares) {\r\n      updateHardware(hardware);\r\n    }\r\n  });\r\n  var selectScaleMap = function (num) {\r\n    if ((currentScale == 1 && num == 1) || (currentScale == 4 && num == 4) || (currentScale == 2 && num == 2) || (currentScale == 8 && num == 8)) {\r\n      currentScale = 0;\r\n    } else {\r\n      currentScale = num;\r\n    };\r\n    if (performMode)\r\n      controlledModule.uiScaleChange(currentScale);\r\n    scaleIntervalsMap = controlledModule.getScaleMap(currentScale);\r\n    for(var hin in hardwareLocals){\r\n      hardwareLocals[hin].compressedScaleMaps = undefined;\r\n    }\r\n  }\r\n  var updateScaleMap = function (newScaleMap) {\r\n    scaleIntervalsMap = newScaleMap;\r\n    controlledModule.newScaleMap(currentScale, newScaleMap);\r\n    for(var hin in hardwareLocals){\r\n      hardwareLocals[hin].compressedScaleMaps = undefined;\r\n    }\r\n  }\r\n\r\n  controlledModule.on('messagesend', function (ev) {\r\n  });\r\n\r\n  //interaction with hardware\r\n\r\n\r\n\r\n  this.engage = function (event) {\r\n    var hardware = event.hardware;\r\n    var hin = event.hardware.instanceNumber;\r\n\r\n    if (!hardwareLocals[hin]) hardwareLocals[hin] = { keyboardRoot: 0, keyboardChan: 0 }\r\n\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n    updateLeds(hardware);\r\n\r\n    // self.on('interaction', function (a, b, c) {\r\n    //   console.log(\"H\", a, b, c);\r\n    // })\r\n\r\n\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n\r\n    // self.off('interaction');\r\n  }\r\n\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    // console.log(event.data);\r\n    var hardware = event.hardware;\r\n    var hin = event.hardware.instanceNumber;\r\n\r\n    var button = event.data[0];\r\n    var eventFingerMap = event.data[2];\r\n    // console.log(eventFingerMap);\r\n    if (engagedConfigurator === false) {\r\n      if (performMode) {\r\n        var triggerKey = event.data[0] + hardwareLocals[hin].keyboardRoot;\r\n        controlledModule.uiTriggerOn(triggerKey, new EventMessage({\r\n          value: [-1, triggerKey, hardwareLocals[hin].keyboardChan]\r\n        }));\r\n      } else {\r\n        var grade = event.data[0] % 12;\r\n        updateScaleMap(scaleIntervalsMap ^ (1 << grade));\r\n        updateHardware(hardware);\r\n      }\r\n    } else {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    var hin = hardware.instanceNumber;\r\n    if (engagedConfigurator === false) {\r\n      controlledModule.uiTriggerOff(event.data[0] + hardwareLocals[hin].keyboardRoot, hardwareLocals[hin].keyboardChan);\r\n      updateLeds(hardware);\r\n\r\n    } else {\r\n      engagedConfigurator.matrixButtonReleased(event);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      var hardware = event.hardware;\r\n      if (event.data[0] == 1) {\r\n        engagedConfigurator = configurators.event;\r\n        lastEngagedConfigurator = configurators.event;\r\n        configurators.event.engage(event);\r\n      } else if (event.data[0] == 2) {\r\n        if (performMode) {\r\n          engagedConfigurator = configurators.record;\r\n          lastEngagedConfigurator = configurators.record;\r\n          configurators.record.engage(event);\r\n        } else {\r\n          copyingScale = currentScale;\r\n          event.hardware.sendScreenA('copy scale to...');\r\n          event.hardware.sendScreenB('(release)');\r\n        }\r\n      } else if (event.data[0] == 0) {\r\n        performMode = !performMode;\r\n        updateHardware(hardware);\r\n      } else if (event.button >= 8) {\r\n        configurators.record.engage(event);\r\n      } else if (event.button >= 4) {\r\n        scaleSelectionMap ^= 1 << (event.data[0] - 4);\r\n        selectScaleMap(scaleSelectionMap);\r\n        // updateHardware(hardware);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonReleased(event);\r\n    }\r\n    if (event.data[0] == 1) {\r\n      engagedConfigurator = false;\r\n      configurators.event.disengage(event);\r\n    } else if (event.data[0] == 2) {\r\n      if (copyingScale !== false) {\r\n        updateScaleMap(controlledModule.getScaleMap(copyingScale));\r\n        updateHardware(hardware);\r\n        copyingScale = false;\r\n      } else {\r\n        engagedConfigurator = false;\r\n        configurators.record.disengage(event);\r\n      }\r\n    } else if (event.data[0] == 3) {\r\n\r\n    } else if (event.button >= 8) {\r\n      configurators.record.disengage(event);\r\n      engagedConfigurator = false;\r\n    } else if (event.button >= 4) {\r\n      // scaleSelectionMap &= ~(1<<(event.data[0]-4));\r\n      // selectScaleMap(scaleSelectionMap);\r\n      // updateHardware(hardware);\r\n    }\r\n    updateHardware(hardware);\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n\r\n    var hardware = event.hardware;\r\n    var hin=event.hardware.instanceNumber;\r\n    if (lastEngagedConfigurator) {\r\n      lastEngagedConfigurator.encoderScrolled(event);\r\n      if (lastEngagedConfigurator == configurators.event) {\r\n        hardwareLocals[hin].compressedScaleMaps = undefined;\r\n        updateLeds(event.hardware);\r\n      }\r\n    }\r\n    updateLeds(hardware);\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n\r\n  configurators.record.autoEngageWindow();\r\n\r\n  var passiveUpdateLeds = function () {\r\n    if (!engagedConfigurator)\r\n      for (var hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    currentScale = controlledModule.currentScale;\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateLeds = function (hardware) {\r\n    var selScaleMap = (scaleSelectionMap & 0xf);\r\n    // hardware.paintColorFromLedN(0,[0,0,0],0,false);\r\n    hardware.paintColorFromLedN(selScaleMap << 4, [255, 127, 0], 0, false);\r\n    \r\n    var hin = hardware.instanceNumber;\r\n    if (performMode) {\r\n      if (hardwareLocals[hin].compressedScaleMaps === undefined) {\r\n        hardwareLocals[hin].compressedScaleMaps = controlledModule.getCompMaps(currentScale, hardwareLocals[hin].keyboardRoot);\r\n      }\r\n\r\n      hardware.draw([\r\n        hardwareLocals[hin].compressedScaleMaps.roots, \r\n        hardwareLocals[hin].compressedScaleMaps.roots, \r\n        hardwareLocals[hin].compressedScaleMaps.semitones[1]\r\n      ]);\r\n\r\n    } else {\r\n      if (scaleIntervalsMap === undefined) {\r\n        scaleIntervalsMap = controlledModule.getScaleMap(currentScale);\r\n      }\r\n\r\n      var SNN = scaleIntervalsMap;\r\n\r\n      SNN |= SNN << 12;\r\n\r\n      hardware.draw([SNN | noteHiglightMap, noteHiglightMap, 0x5AB5 | noteHiglightMap | SNN]);\r\n    }\r\n  }\r\n  var updateScreen = function (hardware, upleds = true, upscreen = true) {\r\n\r\n    var screenAString = \"\";\r\n    var screenBString = \"\";\r\n    if (performMode) {\r\n      if (!engagedConfigurator) screenAString += \"Perform \"\r\n    } else {\r\n      if (!engagedConfigurator) screenAString += \"Edit \";\r\n    }\r\n    if (controlledModule.scaleArray[currentScale]) {\r\n      var currentScaleName = scaleNames.scaleToName[scaleIntervalsMap];\r\n      if (currentScaleName) {\r\n        screenAString = currentScaleName + \"-\" + screenAString;\r\n      } else {\r\n        screenAString += \"chord \" + currentScale + \": \" + controlledModule.scaleArray[currentScale].length;\r\n      }\r\n    } else {\r\n      screenAString += \"chord \" + currentScale + \": empty\";\r\n    }\r\n    if (upscreen)\r\n      hardware.sendScreenA(screenAString);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Harmonizer/old_InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/Harmonizer/scaleNameMaker.js":
/*!**************************************************!*\
  !*** ./src/modules/Harmonizer/scaleNameMaker.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {var fs=__webpack_require__(/*! fs */ \"fs\");\r\nvar path=__webpack_require__(/*! path */ \"path\");\r\n\r\nvar nameToScale={};\r\nvar scaleToName=[];\r\nvar gradeNames=['DO','DO#','RE','RE#','MI','FA','FA#','SOL','SOL#','LA','LA#','SI'];\r\ngradeNames=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];\r\nvar structures={\r\n  // \"maj*\":\"C; E; G;\",\r\n  // \"maj1*\":\"C; D; G; Bb;\",\r\n  // \"maj6*\":\"C; E; G; A;\",\r\n  // \"maj7*\":\"C; E; G; B;\",\r\n  // \"maj9*\":\"C; D; G; Bb; D;\",\r\n  // \"min*\":\"C; D#/Eb; G;\",\r\n  // \"min6*\":\"C; D#/Eb; G; A;\",\r\n  // \"min7*\":\"C; D#/Eb; G; Bb;\",\r\n  // \"min9*\":\"C; D#/Eb; G; Bb; D;\",\r\n  // \"dim*\":\"C; D#/Eb; F#/Gb\",\r\n  // \"dim*\":\"C; D#/Eb; F#/Gb\",\r\n  // \"aug*\":\"C; E; G#/Ab;\",\r\n  // \"sus4*\":\"C; F; G;\",\r\n  \"melodic minor\":\"C; D; D#/Eb; F; G; A; B; C;\",\r\n  \"ionian\":\"C; D; E; F; G; A; B; C;\",\r\n  \"harmonic minor\":\"C; D; D#/Eb; F; G; G#/Ab; B; C;\",\r\n  \"natural minor\":\"C; D; D#/Eb; F; G; G#/Ab; A#/Bb; C;\",\r\n  \"dorian\":\"C; D; D#/Eb; F; G; A; A#/Bb; C;\",\r\n  \"phrygian\":\"C; C#/Db; D#/Eb; F; G; G#/Ab; A#/Bb; C;\",\r\n  \"lydian\":\"C; D; E; F#/Gb; G; A; B; C;\",\r\n  \"mixolydian\":\"C; D; E; F; G; A; A#/Bb; C;\",\r\n  \"aeolian\":\"C; D; D#/Eb; F; G; G#/Ab; A#/Bb; C;\",\r\n  \"locrian\":\"C; C#/Db; D#/Eb; F; F#/Gb; G#/Ab; A#/Bb; C;\",\r\n  \"blues\":\"C; D#/Eb; F; F#/Gb; G; A#/Bb; C;\",\r\n  \"diminished ha-wh\":\"C; C#/Db; D#/Eb; E; F#/Gb; G; A; A#/Bb; C;\",\r\n  \"diminished wh-ha\":\"C; D; D#/Eb; F; F#/Gb; G#/Ab; A; B; C;\",\r\n  \"whole tone\":\"C; D; E; F#/Gb; G#/Ab; A#/Bb; C;\",\r\n  \"major pentatonic\":\"C; D; E; G; A; C;\",\r\n  \"minor pentatonic\":\"C; D#/Eb; F; G; A#/Bb; C;\",\r\n  \"augmented\":\"C; D#/Eb; E; G; G#/Ab; B; C;\",\r\n  \"leading whole tone\":\"C; D; E; F#/Gb; G#/Ab; A#/Bb; B; C;\",\r\n  \"double harmonic\":\"C; C#/Db; E; F; G; G#/Ab; B; C;\",\r\n  \"overtone\":\"C; D; E; F#/Gb; G; A; A#/Bb; C;\",\r\n  \"six tone symmetrical\":\"C; C#/Db; E; F; G#/Ab; A; C;\",\r\n  \"altered\":\"C; C#/Db; D#/Eb; E; F#/Gb; G#/Ab; A#/Bb; C;\",\r\n  \"altered bb7\":\"C; C#/Db; D#/Eb; E; F#/Gb; G#/Ab; A; C;\",\r\n  \"enigmatic\":\"C; C#/Db; E; F#/Gb; G#/Ab; A#/Bb; B; C;\",\r\n  \"dorian b2\":\"C; C#/Db; D#/Eb; F; F#/Gb; G#/Ab; A; B;\",\r\n  \"augmented lydian\":\"C; D; E; F#/Gb; G#/Ab; A; B; C;\",\r\n  \"lydian b7\":\"C; D; E; F#/Gb; G; A; A#/Bb; C;\",\r\n  \"mixolydian b6\":\"C; D; E; F; G; G#/Ab; A#/Bb; C;\",\r\n  \"locrian 2\":\"C; D; D#/Eb; F; F#/Gb; G#/Ab; A#/Bb; C;\",\r\n  \"locrian 6\":\"C; C#/Db; D#/Eb; F; F#/Gb; A; A#/Bb; C;\",\r\n  \"augmented ionian\":\"C; D; E; F; G#/Ab; A; B; C;\",\r\n  \"dorian #4\":\"C; D; D#/Eb; F#/Gb; G; A; A#/Bb; C;\",\r\n  \"major phrygian\":\"C; C#/Db; E; F; G; G#/Ab; A#/Bb; C;\",\r\n  \"lydian #9\":\"C; D#/Eb; E; F#/Gb; G; A; B; C;\",\r\n  \"diminished lydian\":\"C; D; D#/Eb; F#/Gb; G; A; B; C;\",\r\n  \"minor lydian\":\"C; D; E; F#/Gb; G; G#/Ab; A#/Bb; C;\",\r\n  \"arabian\":\"C; D; E; F; F#/Gb; G#/Ab; A#/Bb; C;\",\r\n  \"balinese\":\"C; C#/Db; D#/Eb; F#/Gb; G#/Ab; C;\",\r\n  \"byzantine\":\"C; C#/Db; E; F; G; G#/Ab; B; C;\",\r\n  \"chinese\":\"C; E; F#/Gb; G; B; C;\",\r\n  \"mongolian\":\"C; D; E; G; A; C;\",\r\n  \"egyptian\":\"C; D; F; G; A#/Bb; C;\",\r\n  \"eight tone spanish\":\"C; C#/Db; D#/Eb; E; F; F#/Gb; G#/Ab; A#/Bb; C;\",\r\n  \"hindu\":\"C; D; E; F; G; G#/Ab; A#/Bb; C;\",\r\n  \"hirajoshi\":\"C; D; D#/Eb; G; G#/Ab; C;\",\r\n  \"hungarian major\":\"C; D#/Eb; E; F#/Gb; G; A; A#/Bb; C;\",\r\n  \"hungarian minor gipsy\":\"C; D; D#/Eb; F#/Gb; G; G#/Ab; B; C;\",\r\n  \"ichikosucho\":\"C; D; E; F; F#/Gb; G; A; B; C;\",\r\n  \"kumoi\":\"C; D; D#/Eb; G; A; C;\",\r\n  \"mohammedan\":\"C; D; D#/Eb; F; G; G#/Ab; B; C;\",\r\n  \"neopolitan\":\"C; C#/Db; D#/Eb; F; G; G#/Ab; B; C;\",\r\n  \"neopolitan major\":\"C; C#/Db; D#/Eb; F; G; A; B; C;\",\r\n  \"neopolitan minor\":\"C; C#/Db; D#/Eb; F; G; G#/Ab; A#/Bb; C;\",\r\n  \"pelog\":\"C; C#/Db; D#/Eb; G; G#/Ab; C;\",\r\n  \"persian\":\"C; C#/Db; E; F; F#/Gb; G#/Ab; B; C;\",\r\n  \"prometheus\":\"C; D; E; F#/Gb; A; A#/Bb; C;\",\r\n  \"prometheus neopolitan\":\"C; C#/Db; E; F#/Gb; A; A#/Bb; C;\",\r\n  \"purvi theta\":\"C; C#/Db; E; F#/Gb; G; G#/Ab; B; C;\",\r\n  \"todi theta\":\"C; C#/Db; D#/Eb; F#/Gb; G; G#/Ab; B; C;\",\r\n  \"chromatic\":\"C;C#;D;D#;E;F;F#;G;G#;A;A#;B;\",\r\n  \"octave\":\"C\",\r\n}\r\n//transform each scale's text to a byte, and store it in the arrays\r\nfor(var n in structures){\r\n  var scaleString=structures[n];\r\n  var scaleTitle=n;\r\n\r\n\r\n  var scaleStructure=scaleString.split(/\\; */g);\r\n  // console.log(scaleStructure);\r\n  var gradesByte=0;\r\n  for(var a of scaleStructure){\r\n    a=a.replace(/\\/.*/,\"\");\r\n    gradesByte|=1<<gradeNames.indexOf(a);\r\n    // console.log(a);\r\n  }\r\n  gradesByte&=0xFFF;\r\n  scaleToName[gradesByte]=scaleTitle;\r\n  nameToScale[scaleTitle]=gradesByte;\r\n  // console.log(gradesByte.toString(2));\r\n}\r\n\r\nvar shiftedScalesArray=[];\r\n//search for all unnammed possible scales, and search for a scale that would fit\r\nfor(var n = 0; n<scaleToName.length; n++){\r\n  if(!scaleToName[n]){\r\n    var scaleTitle=false;\r\n    // console.log(\"fill \"+n);\r\n    for(var shift=0; shift<12; shift++){\r\n      for(var scaleNumber in scaleToName){\r\n        var shiftedScale=scaleNumber<<shift\r\n        shiftedScale|=shiftedScale>>12;\r\n        shiftedScale|=shiftedScale<<12;\r\n        shiftedScale&=0xFFF;\r\n        // console.log(\"shifted\"+shiftedScale.toString(2));\r\n        if(shiftedScale==n){\r\n          scaleTitle=gradeNames[shift]+\" \"+scaleToName[scaleNumber];\r\n          console.log(n.toString(2)+\" = \"+scaleToName[scaleNumber]+\"<<\"+shift+\"\"+scaleTitle);\r\n          shiftedScalesArray[n]=scaleTitle;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nfor(var n in shiftedScalesArray){\r\n  scaleToName[n]=shiftedScalesArray[n];\r\n}\r\n\r\n\r\nfs.writeFile(path.join(__dirname,'/scaleNames.js'),\r\n\"var nameToScale=\"+JSON.stringify(nameToScale, null)+\r\n\";var scaleToName=\"+JSON.stringify(scaleToName, null)+\r\n\";module.exports={scaleToName:scaleToName,nameToScale:nameToScale}\"\r\n, 'utf8'\r\n, console.log);\r\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack://environment/./src/modules/Harmonizer/scaleNameMaker.js?");

/***/ }),

/***/ "./src/modules/Harmonizer/scaleNames.js":
/*!**********************************************!*\
  !*** ./src/modules/Harmonizer/scaleNames.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nameToScale={\"melodic minor\":2733,\"ionian\":2741,\"harmonic minor\":2477,\"natural minor\":1453,\"dorian\":1709,\"phrygian\":1451,\"lydian\":2773,\"mixolydian\":1717,\"aeolian\":1453,\"locrian\":1387,\"blues\":1257,\"diminished ha-wh\":1755,\"diminished wh-ha\":2925,\"whole tone\":1365,\"major pentatonic\":661,\"minor pentatonic\":1193,\"augmented\":2457,\"leading whole tone\":3413,\"double harmonic\":2483,\"overtone\":1749,\"six tone symmetrical\":819,\"altered\":1371,\"altered bb7\":859,\"enigmatic\":3411,\"dorian b2\":2923,\"augmented lydian\":2901,\"lydian b7\":1749,\"mixolydian b6\":1461,\"locrian 2\":1389,\"locrian 6\":1643,\"augmented ionian\":2869,\"dorian #4\":1741,\"major phrygian\":1459,\"lydian #9\":2777,\"diminished lydian\":2765,\"minor lydian\":1493,\"arabian\":1397,\"balinese\":331,\"byzantine\":2483,\"chinese\":2257,\"mongolian\":661,\"egyptian\":1189,\"eight tone spanish\":1403,\"hindu\":1461,\"hirajoshi\":397,\"hungarian major\":1753,\"hungarian minor gipsy\":2509,\"ichikosucho\":2805,\"kumoi\":653,\"mohammedan\":2477,\"neopolitan\":2475,\"neopolitan major\":2731,\"neopolitan minor\":1451,\"pelog\":395,\"persian\":2419,\"prometheus\":1621,\"prometheus neopolitan\":1619,\"purvi theta\":2515,\"todi theta\":2507,\"chromatic\":4095,\"octave\":1};var scaleToName=[null,\"octave\",\"C# octave\",null,\"D octave\",null,null,null,\"D# octave\",null,null,null,null,null,null,null,\"E octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F# octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G# octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"balinese\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F pelog\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"pelog\",null,\"hirajoshi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F hirajoshi\",null,\"F kumoi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"kumoi\",null,null,null,null,null,null,null,\"mongolian\",\"C# balinese\",null,null,null,null,\"D# prometheus neopolitan\",null,\"A blues\",null,null,null,null,null,null,null,\"G egyptian\",null,null,null,null,null,\"D# prometheus\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F# balinese\",\"F# pelog\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A hungarian major\",null,null,null,null,null,null,null,null,null,null,null,\"F# todi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"C# pelog\",null,null,null,\"A chinese\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"six tone symmetrical\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F# hirajoshi\",null,null,null,\"F# kumoi\",null,null,null,null,null,null,null,null,null,null,null,null,\"C# neopolitan\",null,null,null,\"altered bb7\",null,null,null,null,null,null,null,null,null,\"G# prometheus neopolitan\",null,\"F# hungarian minor gipsy\",null,null,null,\"F# diminished lydian\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G# persian\",null,null,null,\"G# byzantine\",null,\"G# purvi theta\",null,null,null,null,null,null,null,\"D blues\",null,\"C# purvi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G# enigmatic\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# hirajoshi\",null,null,null,null,null,\"D# kumoi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# kumoi\",null,\"egyptian\",null,\"G blues\",null,\"minor pentatonic\",null,null,null,null,null,null,null,\"E balinese\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F# prometheus neopolitan\",null,null,null,null,null,null,null,null,null,null,null,null,null,\"F# purvi theta\",null,\"blues\",null,null,null,null,null,null,null,null,null,null,null,\"F# enigmatic\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"C# kumoi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# egyptian\",\"A# minor pentatonic\",null,\"D balinese\",null,null,null,null,null,null,null,null,null,\"E prometheus neopolitan\",null,null,null,\"A# blues\",null,null,\"E enigmatic\",null,null,null,null,null,null,null,null,null,null,null,null,\"G# egyptian\",null,null,null,null,\"D enigmatic\",null,null,null,null,null,\"whole tone\",\"E prometheus\",\"G# arabian\",null,\"F# prometheus\",null,\"altered\",null,\"A# arabian\",null,null,null,null,null,null,null,\"G# prometheus\",null,null,null,null,null,\"locrian\",null,\"locrian 2\",null,null,null,null,null,\"F neopolitan\",null,\"arabian\",null,null,null,null,null,\"eight tone spanish\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G balinese\",null,\"G pelog\",null,null,null,null,null,null,null,null,\"A# prometheus\",null,null,null,null,null,\"C# diminished lydian\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"neopolitan minor\",null,\"aeolian\",null,\"G# ichikosucho\",null,null,null,\"major phrygian\",null,\"hindu\",\"A# hungarian major\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G neopolitan\",\"G todi theta\",null,null,null,null,null,null,\"minor lydian\",null,null,null,null,null,\"G dorian b2\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"C# ichikosucho\",null,\"D eight tone spanish\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A balinese\",null,null,\"D pelog\",null,null,null,null,\"A pelog\",null,null,\"A# chinese\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"prometheus neopolitan\",null,\"prometheus\",null,null,null,null,null,\"F# hungarian major\",null,null,null,null,null,null,null,null,null,null,\"A# augmented\",null,null,null,null,\"locrian 6\",null,\"D# diminished lydian\",null,null,null,null,null,\"A# hungarian minor gipsy\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G hirajoshi\",null,null,null,null,null,null,null,\"G kumoi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# melodic minor\",null,\"dorian\",\"D neopolitan\",\"A eight tone spanish\",null,null,null,\"A# diminished lydian\",null,\"mixolydian\",\"A# lydian #9\",null,null,null,null,\"E dorian b2\",null,\"A# ichikosucho\",null,null,null,null,null,null,null,null,null,null,null,null,\"A prometheus neopolitan\",\"D# hungarian major\",null,\"dorian #4\",\"G hungarian minor gipsy\",null,null,null,null,null,null,\"lydian b7\",\"G diminished lydian\",\"C# dorian b2\",null,\"hungarian major\",null,\"diminished ha-wh\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A persian\",null,null,null,null,null,null,\"A neopolitan\",\"A byzantine\",null,null,\"A todi theta\",\"A purvi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"D# blues\",null,null,null,\"D purvi theta\",null,null,null,null,null,null,\"A# leading whole tone\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A dorian b2\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A enigmatic\",null,null,\"D# ichikosucho\",null,null,null,null,null,null,null,\"E eight tone spanish\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"B octave\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"B balinese\",null,null,null,null,null,null,null,null,null,null,null,\"E pelog\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"B pelog\",\"B hirajoshi\",null,null,null,null,null,null,null,null,null,null,\"chinese\",\"E kumoi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"B kumoi\",null,null,null,\"B mongolian\",null,null,\"D prometheus neopolitan\",\"G# blues\",null,null,null,\"F# egyptian\",null,null,\"D prometheus\",null,null,null,null,null,null,null,null,null,null,null,null,\"F balinese\",null,null,null,null,null,null,null,null,null,null,\"G# hungarian major\",null,null,null,null,null,\"persian\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"augmented\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"neopolitan\",null,\"mohammedan\",null,null,null,null,\"G prometheus neopolitan\",\"byzantine\",null,\"F diminished lydian\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"todi theta\",null,\"hungarian minor gipsy\",\"G purvi theta\",null,null,null,\"C# blues\",\"purvi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G enigmatic\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A hirajoshi\",null,null,\"D kumoi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A kumoi\",\"B egyptian\",\"F# blues\",\"B minor pentatonic\",null,null,null,\"D# balinese\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F prometheus neopolitan\",null,null,null,null,null,null,\"F purvi theta\",\"B blues\",null,null,null,null,null,\"F enigmatic\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A egyptian\",null,null,null,null,null,null,null,null,null,\"D# enigmatic\",null,null,null,null,null,null,null,null,\"C# enigmatic\",null,null,\"B whole tone\",\"neopolitan major\",\"F prometheus\",\"melodic minor\",\"A arabian\",null,null,null,\"G prometheus\",null,null,\"ionian\",\"B locrian 2\",null,null,\"E neopolitan\",\"B arabian\",null,null,\"B eight tone spanish\",null,null,null,null,null,null,null,null,null,null,null,null,\"A prometheus\",null,null,\"diminished lydian\",null,null,null,null,null,null,null,\"lydian\",\"B aeolian\",\"G ichikosucho\",null,\"lydian #9\",\"B hindu\",null,null,null,null,null,null,null,null,null,null,null,\"F# neopolitan\",null,null,null,\"B minor lydian\",null,null,\"F# dorian b2\",null,null,null,null,null,null,null,\"ichikosucho\",\"C# eight tone spanish\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G# balinese\",null,null,null,\"G# pelog\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"B prometheus neopolitan\",\"B prometheus\",null,null,\"F hungarian major\",null,null,null,null,null,null,null,\"augmented ionian\",\"D diminished lydian\",null,null,\"A hungarian minor gipsy\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"augmented lydian\",\"B dorian\",\"G# eight tone spanish\",null,\"A diminished lydian\",\"B mixolydian\",null,null,\"D# dorian b2\",\"A ichikosucho\",null,null,null,null,null,null,\"D hungarian major\",\"B dorian #4\",null,null,null,\"B lydian b7\",\"dorian b2\",\"B hungarian major\",\"diminished wh-ha\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G# neopolitan\",null,\"G# todi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,\"A leading whole tone\",null,null,null,null,null,null,null,null,null,null,null,\"G# dorian b2\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"D ichikosucho\",null,null,null,\"D# eight tone spanish\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# balinese\",null,null,null,null,null,\"D# pelog\",null,null,null,null,null,null,null,null,null,\"A# pelog\",null,null,null,null,null,\"B chinese\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"C# prometheus neopolitan\",null,null,null,\"C# prometheus\",null,null,null,null,null,null,null,null,null,null,null,\"G hungarian major\",null,null,\"B persian\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"B augmented\",null,null,null,null,null,null,null,null,\"B neopolitan\",\"B mohammedan\",null,null,\"B byzantine\",\"E diminished lydian\",null,null,null,null,null,null,null,null,null,null,\"B todi theta\",\"B hungarian minor gipsy\",null,null,\"B purvi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G# hirajoshi\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"G# kumoi\",\"F blues\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"E purvi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"enigmatic\",null,\"leading whole tone\",\"B melodic minor\",null,null,null,\"B ionian\",null,\"D# neopolitan\",null,\"A# eight tone spanish\",null,null,null,null,null,null,null,\"B diminished lydian\",null,null,null,\"B lydian\",\"F# ichikosucho\",\"B lydian #9\",null,null,null,null,null,null,null,null,null,\"F dorian b2\",null,null,null,\"B ichikosucho\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# prometheus neopolitan\",null,\"E hungarian major\",null,null,null,\"B augmented ionian\",null,\"G# hungarian minor gipsy\",null,null,null,null,null,null,null,null,null,null,null,null,null,\"B augmented lydian\",\"G eight tone spanish\",\"G# diminished lydian\",null,\"D dorian b2\",null,null,null,\"C# hungarian major\",null,null,\"B dorian b2\",\"B diminished wh-ha\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# persian\",null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# neopolitan\",null,\"A# byzantine\",null,null,null,null,null,\"A# todi theta\",null,\"A# purvi theta\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"E blues\",null,null,null,null,null,null,null,\"D# purvi theta\",null,null,null,null,null,null,null,null,null,null,null,null,\"B enigmatic\",\"B leading whole tone\",null,null,null,null,null,null,null,null,null,null,\"F ichikosucho\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F# eight tone spanish\",null,null,null,null,\"A# dorian b2\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"A# enigmatic\",null,null,null,null,null,\"E ichikosucho\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"F eight tone spanish\",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\"chromatic\"];module.exports={scaleToName:scaleToName,nameToScale:nameToScale}\n\n//# sourceURL=webpack://environment/./src/modules/Harmonizer/scaleNames.js?");

/***/ }),

/***/ "./src/modules/Knob/InterfaceX28.js":
/*!******************************************!*\
  !*** ./src/modules/Knob/InterfaceX28.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n// var RecordMenu = require('../x28utils/RecordMenu.js');\r\n\r\nmodule.exports = function (controlledModule, environment) {\r\n  base.call(this);\r\n  var currentStep = 0;\r\n  var configurators = {};\r\n\r\n  var value=0;\r\n  this.outsideScroll = function (event) {\r\n    let delta = event.delta;\r\n    value+=delta;\r\n    return (value);\r\n  }\r\n\r\n\r\n  var OpSetter = function (varn) {\r\n    var self = this;\r\n    this.value = 0;\r\n    this.op = 0;\r\n    var opChangeFunction = function (thisVar, delta) {\r\n      console.log(self.value);\r\n      self.op += delta;\r\n      if (self.op >= controlledModule.availOps) {\r\n        self.op = 0;\r\n      } else if (self.op < 0) {\r\n        self.op = controlledModule.availOps - 1;\r\n      }\r\n      controlledModule.opMap[varn] = self.op;\r\n      controlledModule.handle('~');\r\n    }\r\n    var valChangeFunction = function (thisVar, delta) {\r\n      console.log(self.value);\r\n      self.value += delta;\r\n      controlledModule.baseEventMessage.value[varn] = self.value;\r\n      controlledModule.handle('~');\r\n    }\r\n    var nameFunction = function (thisVar) {\r\n      if (!self.op) return \"nothing\"\r\n      return controlledModule.opNames[self.op] + \"\" + controlledModule.baseEventMessage.value[varn];\r\n    }\r\n    this.valu = function () {\r\n      return {\r\n        // value:0,\r\n        nameFunction: nameFunction,\r\n        changeFunction: valChangeFunction\r\n      }\r\n    }\r\n    this.operator = function () {\r\n      return {\r\n        // value:0,\r\n        nameFunction: nameFunction,\r\n        changeFunction: opChangeFunction\r\n      }\r\n    }\r\n  }\r\n\r\n  var lastEngagedConfigurator = false;\r\n  var engagedConfigurator = false;\r\n\r\n  var engagedHardwares = new Set();\r\n  \r\n  this.matrixButtonPressed = function (event) {\r\n    \r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    }\r\n  };\r\n\r\n  this.matrixButtonReleased = function (event) {\r\n  };\r\n\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n    event.hardware.draw([0, 0, 0]);\r\n\r\n    engagedConfigurator = configurators.ops;\r\n    configurators.ops.engage(event);\r\n\r\n    // configurators.record.redraw(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateScreen = function (hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    // hardware.sendScreenB(\"n:\"+currentStep);\r\n  }\r\n  var updateLeds = function (hardware) {\r\n\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Knob/InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/Knob/index.js":
/*!***********************************!*\
  !*** ./src/modules/Knob/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n\r\nvar InterfaceX28 = __webpack_require__(/*! ./InterfaceX28 */ \"./src/modules/Knob/InterfaceX28.js\");\r\n\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n\r\n*/\r\nvar headers = EventMessage.headers;\r\nvar instancesCount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + instancesCount;\r\n  instancesCount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar Knob = function (properties) {\r\n\r\n  //maybe the Knob should allow layering of many operation layers, also adding timing operations\r\n\r\n  var self = this;\r\n  this.preventBus = true;\r\n  this.baseName = \"Knob\";\r\n\r\n  testGetName.call(this);\r\n\r\n  if (properties.name) this.name = properties.name;\r\n\r\n  this.interfaces.X28 = InterfaceX28;\r\n  \r\n  this.triggerOperationChange = function () {\r\n    // operationEventMessage.update();\r\n    // self.recordOutput(operationEventMessage);\r\n  }\r\n  \r\n  this.messageReceived = function (evt) {\r\n\r\n  }\r\n\r\n  this.onRemove = function () {\r\n    return true;\r\n  }\r\n}\r\n\r\nKnob.color = [255, 0, 255];\r\nmodule.exports = Knob\n\n//# sourceURL=webpack://environment/./src/modules/Knob/index.js?");

/***/ }),

/***/ "./src/modules/MixxxCtl/InterfaceX16.js":
/*!**********************************************!*\
  !*** ./src/modules/MixxxCtl/InterfaceX16.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\n\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function(controlledModule,environment) {\r\n  base.call(this);\r\n  var currentStep = 0;\r\n  var configurators = {};\r\n  configurators.event = new EventConfigurator(this, {\r\n    baseEvent: controlledModule.baseEventMessage\r\n  });\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  });\r\n  configurators.time = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"step ratio\": {\r\n        value:controlledModule.stepDivision.value,\r\n      },\r\n      \"mode\": {\r\n        value: \"toggle\",\r\n        changeFunction: function(thisVar, delta) {\r\n          if (thisVar.value == \"momentary\") {\r\n            thisVar.value = \"toggle\"\r\n          } else {\r\n            thisVar.value = \"momentary\"\r\n          }\r\n        },\r\n        disengageFunction: function(thisVar) {\r\n          if (thisVar.value == \"momentary\") {\r\n            controlledModule.clearAll();\r\n          }\r\n        }\r\n      },\r\n      \"note duration\": controlledModule.noteDuration,\r\n      \"probability\":controlledModule.probability,\r\n    }\r\n  });\r\n  configurators.time.vars[\"step ratio\"].changeFunction = function(thisVar, delta) {\r\n\r\n    thisVar.value=controlledModule.stepDivision.value\r\n\r\n    if (delta > 0) {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value *= 2;\r\n      } else {\r\n        thisVar.value++\r\n      }\r\n    } else {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value /= 2;\r\n      } else {\r\n        thisVar.value--;\r\n      }\r\n    }\r\n    controlledModule.stepDivision.value=thisVar.value;\r\n    controlledModule.recordStepDivision();\r\n  };\r\n\r\n  configurators.time.vars[\"note duration\"].changeFunction = function(thisVar, delta) {\r\n    delta /= 12;\r\n    thisVar.value += delta;\r\n  };\r\n  configurators.time.vars[\"note duration\"].nameFunction = function(thisVar) {\r\n    return (Math.floor(thisVar.value * 100) / 100) + \" steps\";\r\n  };\r\n\r\n  \r\n  this.outsideScroll = function (event) {\r\n    configurators.time.vars[\"step ratio\"].changeFunction(\r\n      configurators.time.vars[\"step ratio\"],\r\n      event.delta);\r\n    return (\"steps:\"+configurators.time.vars[\"step ratio\"].value);\r\n  }\r\n\r\n  var playMode = configurators.time.vars[\"mode\"];\r\n\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = 0;\r\n\r\n  function hasEvent(button) {\r\n    return 0 != (controlledModule.getBitmap16() & (1 << button));\r\n  }\r\n  var engagedHardwares = new Set();\r\n  controlledModule.on('step', function(step) {\r\n    // console.log(\"STPP\");\r\n    currentStep = step;\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  });\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      if (playMode.value == \"momentary\") {\r\n        controlledModule.setStep(event.button,true);\r\n      } else {\r\n        controlledModule.toggleStep(event.button,true);\r\n      }\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    if (engagedConfigurator) {} else {\r\n      if (playMode.value == \"momentary\") {\r\n        controlledModule.clearStep(event.button,true);\r\n      } else {}\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else if (event.data[0] == 1) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.event;\r\n    }else if (event.data[0] == 2) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.time;\r\n    }else if (event.button >= 8) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.record;\r\n    }\r\n    if(engagedConfigurator){\r\n      engagedConfigurator.engage(event);\r\n      lastEngagedConfigurator = engagedConfigurator;\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator){\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator = false;\r\n      updateHardware(hardware);\r\n    }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  configurators.record.autoEngageWindow();\r\n  var updateHardware = function(hardware) {\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateScreen = function(hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    // hardware.sendScreenB(\"n:\"+currentStep);\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    let bmp = controlledModule.getBitmaps16();\r\n    hardware.draw([bmp.header | bmp.steps, bmp.header, bmp.header | bmp.steps]);\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/MixxxCtl/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/MixxxCtl/index.js":
/*!***************************************!*\
  !*** ./src/modules/MixxxCtl/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar Observable=__webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/MixxxCtl/InterfaceX16.js\");\r\n// var InterfaceHttp = require('./HttpGui');\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n\r\n*/\r\nvar actuatorTypes={\r\n  Base:function(props){\r\n    Observable.call(this);\r\n    this.name=\"unnamed\";\r\n    this.act=function(){};\r\n    this.release=function(){};\r\n    for(var a in props){\r\n      self[a]=props[a];\r\n    }\r\n\r\n  },\r\n  Toggle:function(props){\r\n    var self=this;\r\n    this.steps=1;\r\n    this.active=0;\r\n    this.value=0;\r\n    buttonTypes.Base.call(this,props);\r\n\r\n    this.act=function(delta = 1){\r\n      self.active+=delta;\r\n      self.active%=self.steps;\r\n      self.handle(\"active\",self);\r\n      self.handle(\"active-\"+self.active,self);\r\n      return self.active;\r\n    }\r\n    return this;\r\n  },\r\n  Momentary:function(props){\r\n    var self=this;\r\n    this.active=0;\r\n    this.value=0;\r\n    buttonTypes.Base.call(this,props);\r\n\r\n    this.act=function(active = 1){\r\n      self.active=active;\r\n      self.handle(\"act\",self);\r\n      self.handle(\"act-\"+self.active,self);\r\n      return self.active;\r\n    }\r\n    this.release=function(){\r\n      self.active=0;\r\n      self.handle(\"release\");\r\n      return self.active;\r\n    }\r\n    return this;\r\n  }\r\n}\r\nvar instancesCount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + instancesCount;\r\n  instancesCount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar MixxxCtl = function (properties, environment) {\r\n  var self = this;\r\n  var myBitmap = this.bitmap = 0;\r\n  var a=actuatorTypes;\r\n  var h=EventMessage.headers;\r\n  this.decks = [\r\n    {\r\n      playrate: a.Toggle({steps:0xFF}),\r\n      play: a.Toggle(),\r\n      cue1: a.Toggle(),\r\n      cue2: a.Toggle(),\r\n      cue3: a.Toggle(),\r\n      cue4: a.Toggle(),\r\n    },\r\n  ];\r\n\r\n  userAction=function(actuator){\r\n    self.output(new EventMessage({\r\n      value:[actuator.head,actuator.number,actuator.deck]\r\n    }) );\r\n  }\r\n\r\n  for(var deckn in decks){\r\n    var deck=deckn;\r\n    for(var button of deck){\r\n      button.on\r\n      button.deck=deckn;\r\n      button.on(\"act\", userAction);\r\n      button.on(\"release\", userAction);\r\n    }\r\n  }\r\n\r\n\r\n  this.messageReceived = function (evt) {\r\n  }\r\n  this.getBitmaps16 = function () {\r\n    return {\r\n      steps: myBitmap,\r\n      header: headerBmp & myBitmap\r\n    };\r\n  }\r\n\r\n}\r\n\r\nMixxxCtl.color = [100, 80, 190];\r\nmodule.exports = MixxxCtl\r\n\n\n//# sourceURL=webpack://environment/./src/modules/MixxxCtl/index.js?");

/***/ }),

/***/ "./src/modules/ModModify/InterfaceX28.js":
/*!***********************************************!*\
  !*** ./src/modules/ModModify/InterfaceX28.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar panton = __webpack_require__(/*! ../../interaction/x28basic/panton */ \"./src/interaction/x28basic/panton.js\");\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"modify\": controlledModule.remapIndex,\r\n    }\r\n  });\r\n\r\n  function HardwareLocals(hw){\r\n    this.hardware=hw;\r\n    this.currentOperatorModificationIndex=1;\r\n    this.selectedButton=0;\r\n    this.engagedConfigurator=false;\r\n    this.lastEngagedConfigurator=false;\r\n    this.shiftPressed=false;\r\n    this.engaged=false;\r\n  }\r\n  var hardwareLocals = [];\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    var hin = event.hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin];\r\n\r\n    if (thlocs.engagedConfigurator) {\r\n      thlocs.engagedConfigurator.matrixButtonPressed(event);\r\n    } else if(thlocs.shiftPressed){\r\n      controlledModule.toggleModifierMute(event.button);\r\n    }else{\r\n      thlocs.selectedButton=event.button;\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    var hin = event.hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin];\r\n\r\n    if (thlocs.engagedConfigurator) { } else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hin = event.hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin];\r\n\r\n    var hardware = event.hardware;\r\n    if (thlocs.engagedConfigurator) {\r\n      thlocs.engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 2) {\r\n        thlocs.engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      }else if(event.button==0){\r\n        thlocs.shiftPressed=true;\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hin = event.hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin];\r\n\r\n    var hardware = event.hardware;\r\n    thlocs.lastEngagedConfigurator=false;\r\n    if (event.data[0] == 2) {\r\n      if (thlocs.engagedConfigurator == configurators.global) {\r\n        thlocs.lastEngagedConfigurator = thlocs.engagedConfigurator;\r\n        thlocs.engagedConfigurator.disengage(event);\r\n        thlocs.engagedConfigurator = false;\r\n        updateHardware(event.hardware);\r\n      }\r\n    }else if(event.button==0){\r\n      thlocs.shiftPressed=false;\r\n    }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    var hin = event.hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin];\r\n\r\n    if (thlocs.engagedConfigurator) {\r\n      thlocs.engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (thlocs.lastEngagedConfigurator) {\r\n        thlocs.lastEngagedConfigurator.encoderScrolled(event)\r\n      }else{\r\n        var modindex=1;\r\n        if(thlocs.shiftPressed){\r\n          modindex=0;\r\n        }\r\n        var thisModifier=controlledModule.modifiers[thlocs.selectedButton];\r\n        thisModifier[modindex]+=event.delta;\r\n        if(modindex==0){\r\n          var maxval=0xFF;\r\n          maxval=controlledModule.operators.length;\r\n          if(thisModifier[modindex]>=maxval) thisModifier[modindex]=0;\r\n          if(thisModifier[modindex]< 0) thisModifier[modindex]=maxval;\r\n        }\r\n        passiveUpdateScreen(thlocs);\r\n      }\r\n    }\r\n\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  var dimColor = [\r\n    Math.floor(controlledModule.color[0] / 3),\r\n    Math.floor(controlledModule.color[1] / 3),\r\n    Math.floor(controlledModule.color[2] / 3),\r\n  ];\r\n  var hiColor = [\r\n    Math.floor(controlledModule.color[0] / 3),\r\n    Math.floor(controlledModule.color[1] / 3),\r\n    Math.floor(controlledModule.color[2] / 2),\r\n  ];\r\n  this.engage = function (event) {\r\n    var hin=event.hardware.instanceNumber;\r\n    if(!hardwareLocals[hin])hardwareLocals[hin]=new HardwareLocals(event.hardware);\r\n    var thlocs=hardwareLocals[hin];\r\n    if(thlocs) thlocs\r\n    event.hardware.definePresetColour(\"active\", hiColor);\r\n    event.hardware.definePresetColour(\"dim\",dimColor);\r\n    hardwareLocals[hin].engaged=true;\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    var hin=event.hardware.instanceNumber;\r\n    hardwareLocals[hin].engaged=false;\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    var hin=hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin];\r\n    updateScreen(hardware);\r\n    updateLeds(hardware);\r\n  }\r\n  function updateScreen(hardware){\r\n    var hin=hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin];\r\n    if(!thlocs.engaged)return;\r\n    hardware.sendScreenA(controlledModule.name);\r\n    var curmod=controlledModule.modifiers[thlocs.selectedButton];\r\n    hardware.sendScreenB(\">\"\r\n      +thlocs.selectedButton\r\n      +\":\"+controlledModule.operators[curmod[0]].name\r\n      +\"\"+curmod[1]);\r\n  }\r\n\r\n  var passiveUpdateScreen = function (caller) {\r\n    console.log(\"blo\");\r\n    hardwareLocals.forEach(function (thlocs) {\r\n      console.log(\"pup\");\r\n      if(thlocs.engaged &&thlocs.selectedButton==caller.selectedButton){\r\n        updateScreen(thlocs.hardware);\r\n      }\r\n    })\r\n  }\r\n  var passiveUpdateHardware = function () {\r\n    console.log(\"blo\");\r\n    hardwareLocals.forEach(function (thlocs) {\r\n      console.log(\"pup\");\r\n      if(thlocs.engaged){\r\n        updateHardware(thlocs.hardware);\r\n      }\r\n    })\r\n  }\r\n  var animf = 0;\r\n  var updateLeds = function (hardware) {\r\n    var hin=hardware.instanceNumber;\r\n    var thlocs=hardwareLocals[hin]\r\n    if(!thlocs.engaged) return;\r\n\r\n    var selbmp=1<<thlocs.selectedButton;\r\n    hardware.clear();\r\n    var mutedBitmap=0;\r\n    controlledModule.modifiers.map(function(mod,i){ if(mod[0]==0) mutedBitmap|=1<<i });\r\n    hardware.paintPresetColour(\"gray\", mutedBitmap);\r\n    hardware.paintPresetColour(\"dimblue\", 0xFFFF^mutedBitmap);\r\n\r\n    if (thlocs.selectedButton!==false) {\r\n      hardware.paintPresetColour(\"active\", selbmp);\r\n    }\r\n\r\n  }\r\n  // setInterval(function(){\r\n  //   hardwareLocals.forEach(function(hardware){\r\n  //     updateLeds(hardware);\r\n  //   })\r\n  // }, 700);\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/ModModify/InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/ModModify/index.js":
/*!****************************************!*\
  !*** ./src/modules/ModModify/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX28 = __webpack_require__(/*! ./InterfaceX28 */ \"./src/modules/ModModify/InterfaceX28.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n @constructor\r\n the instance of the of the module, ment to be instantiated multiple times.\r\n require to moduleBase.call\r\n */\r\n\r\n\r\nvar ModModify = function (properties) {\r\n  var thisInstance = this;\r\n  this.preventBus=true;\r\n  this.baseName = \"ModModify\";\r\n  this.color=ModModify.color;\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n  this.interfaces.X16 = InterfaceX28;\r\n\r\n  var noteOnTracker={}\r\n\r\n  this.bitmap=0;\r\n  this.operators=[\r\n    {name:'mute',op:function(input,set){return false } },\r\n    {name:'nothing',op:function(input,set){return input} },\r\n    {name:'+',op:function(input,set){return input+set} },\r\n    {name:'*',op:function(input,set){return input*set} },\r\n    {name:'=',op:function(input,set){return set} },\r\n    {name:'%',op:function(input,set){return input%set} },\r\n    {name:'?',op:function(input,set){return input==set?input:false} },\r\n    {name:'!',op:function(input,set){return input!=set?input:false} },\r\n    {name:'sin/',op:function(input,set){return Math.sin(input/set)*0xFF} },\r\n  ];\r\n  //operation, value\r\n  this.modifiers=[\r\n    [1,0],[1,0],[1,0],[1,0],\r\n    [1,0],[1,0],[1,0],[1,0],\r\n    [1,0],[1,0],[1,0],[1,0],\r\n    [1,0],[1,0],[1,0],[1,0],\r\n  ]\r\n  this.modulus={value:16}\r\n  this.remapIndex={\r\n    value:1,\r\n    valueNames:[\"head\",\"note\",\"chan\",\"param\"],\r\n    max:3,\r\n    min:0\r\n  }\r\n  this.toggleModifierMute=function(n){\r\n    if(!self.modifiers[n]) return;\r\n    if(self.modifiers[n][0]){\r\n      self.modifiers[n][3]=self.modifiers[n][0];\r\n      self.modifiers[n][0]=0;\r\n    }else{\r\n      self.modifiers[n][0]=self.modifiers[n][3]?self.modifiers[n][3]:1;\r\n    }\r\n  }\r\n  function transformFunction(eventMessage){\r\n    // console.log(\"transform\");\r\n    var ret=eventMessage.clone();\r\n    // console.log(\" v\",ret.value);\r\n    var thisValue=ret.value[self.remapIndex.value];\r\n    // console.log(\" thisValue\",thisValue,self.remapIndex);\r\n    var thisModifier=self.modifiers[thisValue%self.modulus.value];\r\n    // console.log(\" thisModifier\",thisModifier,self.modifiers);\r\n    var opfn=self.operators[thisModifier[0]].op;\r\n    if(opfn){\r\n      ret.value[self.remapIndex.value]=opfn(thisValue,thisModifier[1]);\r\n    }else{\r\n      console.warn(\"operator not defined, modifier:\",thisModifier);\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  this.messageReceived = function (evt) {\r\n    var incomingValues=evt.eventMessage.value;\r\n    var incomingValue=incomingValues[self.remapIndex.value];\r\n    var transformed=transformFunction(evt.eventMessage);\r\n\r\n    if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      if (!noteOnTracker[incomingValues[0], incomingValues[1]]) noteOnTracker[incomingValues[0], incomingValues[1]]=[];\r\n      noteOnTracker[incomingValues[0],incomingValues[1]].push(transformed);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      if(noteOnTracker[incomingValues[0], incomingValues[1]]){\r\n        for (var trackedNoteOn of noteOnTracker[incomingValues[0], incomingValues[1]]){\r\n          trackedNoteOn.value[0]=EventMessage.headers.triggerOff;\r\n          self.output(trackedNoteOn);\r\n        }\r\n        delete noteOnTracker[incomingValues[0], incomingValues[1]];\r\n      }\r\n      // console.log(noteOnTracker);\r\n    }\r\n    // console.log(evt.eventMessage.value,\"->\",transformed.value);\r\n    self.output(transformed);\r\n  }\r\n\r\n  this.getBitmap16 = function () {\r\n    return myBitmap;\r\n  }\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noff) {\r\n  //     thisInstance.output(noff, true);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n\r\n  this.handleStepsChange = function () {\r\n    self.handle('~module', { steps: runningNotes.length });\r\n  }\r\n\r\n};\r\n\r\nModModify.color = [210, 0, 190];\r\nmodule.exports = ModModify;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/ModModify/index.js?");

/***/ }),

/***/ "./src/modules/MultiTape/InterfaceX28.js":
/*!***********************************************!*\
  !*** ./src/modules/MultiTape/InterfaceX28.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar SequenceView = __webpack_require__(/*! ./x28-SequenceView.js */ \"./src/modules/MultiTape/x28-SequenceView.js\");\r\nvar ArragementView = __webpack_require__(/*! ./x28-ArrangementView.js */ \"./src/modules/MultiTape/x28-ArrangementView.js\");\r\nvar SQUARE = String.fromCharCode(252);\r\nvar base = __webpack_require__(/*! ../../interaction/x28basic/interactorBase.js */ \"./src/interaction/x28basic/interactorBase.js\");\r\n\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function(controlledModule, environment) {\r\n  base.call(this, controlledModule);\r\n  this.controlledModule = controlledModule;\r\n\r\n  var lastEngagedViewName = \"sequencer\";\r\n  var views = {\r\n    sequencer: new SequenceView(environment, this),\r\n    arrangement: new ArragementView(environment, this)\r\n  };\r\n\r\n  function eachView(cb) {\r\n    for (var n in views) {\r\n      cb.call(views[n], n);\r\n    }\r\n  }\r\n\r\n  function engageView(nameString, event) {\r\n    eachView(function(n) {\r\n      if (n == nameString) {\r\n        lastEngagedViewName = n;\r\n        this.engage(event);\r\n      } else {\r\n        this.disengage(event);\r\n      }\r\n    });\r\n    updateSelectorLeds(event.hardware);\r\n  }\r\n  function switchView(event){\r\n    var found=false;\r\n    eachView(function(n) {\r\n      if(!found){\r\n        if (n === lastEngagedViewName) {\r\n          this.disengage(event);\r\n        } else {\r\n          console.log(\"S\"+n);\r\n          this.engage(event);\r\n          lastEngagedViewName = n;\r\n          found=true;\r\n        }\r\n      }else{\r\n        this.disengage(event);\r\n      }\r\n    });\r\n    updateSelectorLeds(event.hardware);\r\n  }\r\n\r\n  this.selectorButtonPressed = function(event) {\r\n    if (event.button == 0) {\r\n      switchView(event);\r\n    }\r\n  }\r\n  var outsideScrollHeader = 0;\r\n  var outsideScrollMutingUp = true;\r\n  this.outsideScroll = function(event) {\r\n    let delta = event.delta;\r\n    let kit = controlledModule.getTapes();\r\n\r\n    // console.log(outsideScrollHeader);\r\n\r\n    kit[outsideScrollHeader].muted.value = (outsideScrollMutingUp ? (delta > 0) : (delta < 0));\r\n    // console.log(`(${outsideScrollMutingUp}?(${delta>0}):(${delta<0}))=${(outsideScrollMutingUp?(delta>0):(delta<0))}`);\r\n\r\n    // if( kit[outsideScrollHeader].muted){\r\n    //   muteBmp|=1<<outsideScrollHeader;\r\n    // }else{\r\n    //   muteBmp&=~(1<<outsideScrollHeader);\r\n    // }\r\n\r\n    outsideScrollHeader += delta;\r\n    if (outsideScrollHeader >= kit.length) {\r\n      outsideScrollMutingUp = !outsideScrollMutingUp;\r\n      outsideScrollHeader = 0;\r\n    }\r\n    if (outsideScrollHeader < 0) {\r\n      outsideScrollMutingUp = !outsideScrollMutingUp;\r\n      outsideScrollHeader = kit.length - 1;\r\n    }\r\n    let ret = \"\";\r\n    for (let a = 0; a < kit.length; a++) {\r\n      ret += (kit[a].muted.value ? \" \" : SQUARE)\r\n    }\r\n\r\n    return (ret);\r\n  }\r\n  this.windowButtonPressed = views.arrangement.windowButtonPressed;\r\n  this.windowButtonReleased = views.arrangement.windowButtonReleased;\r\n\r\n  this.selectorButtonReleased = function(event) {\r\n\r\n  }\r\n  this.engage = function(event) {\r\n    engageView(lastEngagedViewName, event);\r\n    updateSelectorLeds(event.hardware);\r\n  }\r\n  this.disengage = function(event) {\r\n    engageView(null, event);\r\n  }\r\n\r\n  function updateSelectorLeds(hardware) {\r\n    var classicbtn = 0x00;\r\n    var sequencerbtn = 1 << 4;\r\n    var arrangerbtn = 1 << 5;\r\n    var patchmenubtn = 1 << 7;\r\n    var selectedViewBitmap = 0;\r\n    if (views.sequencer.engagedHardwares.has(hardware)) {\r\n      selectedViewBitmap |= sequencerbtn >> 4;\r\n    }\r\n    if (views.arrangement.engagedHardwares.has(hardware)) {\r\n      selectedViewBitmap |= arrangerbtn >> 4;\r\n    }\r\n    hardware.drawSelectors([\r\n      selectedViewBitmap | classicbtn | sequencerbtn | patchmenubtn,\r\n      (selectedViewBitmap | classicbtn | sequencerbtn | arrangerbtn) & ~patchmenubtn,\r\n      (selectedViewBitmap | classicbtn | arrangerbtn) & ~patchmenubtn\r\n    ]);\r\n  }\r\n  var selectedTape = 0;\r\n  var tapesAmount = 1;\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/MultiTape/NoteLogger.js":
/*!*********************************************!*\
  !*** ./src/modules/MultiTape/NoteLogger.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage=__webpack_require__(/*! ../../datatypes/EventMessage */ \"./src/datatypes/EventMessage.js\");\r\nvar headers=EventMessage.headers;\r\n\r\n\r\n\r\n\r\nvar Fifo = __webpack_require__(/*! fifo */ \"./node_modules/fifo/index.js\");\r\n\r\nvar NoteLogger = function( _settings) {\r\n  var self = this;\r\n  var clock = this.clock = {\r\n    step: 0,\r\n    microSteps: 12,\r\n    microStep: 0,\r\n    historicStep: 0\r\n  };\r\n  var settings = {\r\n    memoryLength: 2048\r\n  }\r\n  for (var a in _settings) {\r\n    settings = _settings[a];\r\n  }\r\n  var fifo = Fifo();\r\n  fifo.lastEntry=null;\r\n  var trackedNotes = [];\r\n\r\n  function addToMemory(eventMessage) {\r\n    // console.log(\"ADDDD\",eventMessage.value[1]);\r\n    fifo.lastEntry=fifo.push(eventMessage);\r\n    while (fifo.length > settings.memoryLength) {\r\n      fifo.shift();\r\n    };\r\n  }\r\n  this.addEvent = function(eventMessage) {\r\n    // console.log(\"ADDD2\");\r\n    var timeNow = [self.clock.historicStep, self.clock.microStep];\r\n    var eventKey = [eventMessage.value[1], eventMessage.value[2]];\r\n    if (eventMessage.value[0] == headers.triggerOn) {\r\n      eventMessage.starts = timeNow;\r\n      trackedNotes[eventKey] = eventMessage;\r\n    } else if (eventMessage.value[0] == headers.triggerOff) {\r\n      var trackedNote = trackedNotes[eventKey];\r\n      if (trackedNote) {\r\n        //started looks like: [step,microStep]\r\n        var started = trackedNote.starts;\r\n        trackedNote.duration = [self.clock.historicStep - started[0], self.clock.microStep - started[1]];\r\n        // console.log(\"THRKNTSTART\",tr);\r\n        while(trackedNote.duration[1]<=0){\r\n          trackedNote.duration[1]+=self.clock.microSteps;\r\n        }\r\n        console.log(trackedNote.duration);\r\n        addToMemory(trackedNote);\r\n        delete trackedNotes[eventKey];\r\n        // console.log(\"TRASH\",trackedNotes);\r\n        // console.log(\"DURAT\",trackedNote.duration);\r\n      } else {\r\n        console.warn(\"received a noteoff for a note that was not being tracked\");\r\n      }\r\n    } else {\r\n      eventMessage.starts = timeNow;\r\n      addToMemory(eventMessage);\r\n    }\r\n    // console.log(\"STARTEEED\",eventMessage.starts);\r\n  }\r\n\r\n  /**\r\n  returns number indexed array of the last n events\r\n   @param timeIndexed can be boolean or a number if you want to have the events %arized to a value\r\n  */\r\n  this.getLastNEvents = function(n, timeIndexed = false) {\r\n    var ret = [];\r\n    var modularize = !(isNaN(timeIndexed) || timeIndexed === true);\r\n    var currNode = fifo.lastEntry;\r\n    for (let a = 0; a < n; a++) {\r\n      if (timeIndexed) {\r\n        var timeIndex=[self.clock.historicStep, self.clock.microStep];\r\n        if (modularize) {\r\n          timeIndex=[self.clock.historicStep % timeIndexed, self.clock.microStep]\r\n        }\r\n        if(!ret[timeIndex]) ret[timeIndex]=[];\r\n        ret[timeIndex].push(currNode.value)\r\n      } else {\r\n        ret.push(currNode.value);\r\n      }\r\n      currNode = fifo.prev(currNode);\r\n    }\r\n    ret.push(currNode.value);\r\n    return ret;\r\n  }\r\n  /**\r\n  function to check if  @param eventMessage has length and start time in case it's a note on event\r\n  */\r\n  function isMemEventComplete(eventMessage) {\r\n    // console.log(\"EVALUTUA\",eventMessage);\r\n    // (eventMessage.starts!==undefined && eventMessage.duration!==undefined)\r\n    // console.log(\"EVALUTUB\",eventMessage);\r\n\r\n    if (eventMessage.value[0] == headers.triggerOn) {\r\n      return (eventMessage.starts!==undefined && eventMessage.duration!==undefined);\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n  /**\r\n  @returns the time of the last event. optionally can be @param modularize. If there have not been any events, it @returns false. timeIndexed cannot be a boolean If @param callback is provided, it will run it in case there is a last event.\r\n  */\r\n  this.lastEventTime = function(modularize = false, callback) {\r\n    if(fifo.last())\r\n    var ref=fifo.last().starts;\r\n    // console.log(\"RREF\",ref);\r\n    // console.log(\"FFREFFE\",ref);\r\n    if(!ref) return;\r\n    var ret = [ref[0],ref[1]];\r\n    if (ret) {\r\n      // if (ret.starts) {\r\n        if (modularize) {\r\n          ret[0] %= modularize[0];\r\n          ret[1] %= modularize[1];\r\n        }\r\n        // console.log(\"RTSTARTE\",ret);\r\n        if (callback) callback(ret);\r\n        return ret;\r\n      // } else {\r\n        // console.warn(\"nstarted!\", ret);\r\n      // }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  returns time-indexed ([step,microStep]) of events between the current time minus @param timaRangeStart and current time. @param modularize can be used to get the events %ized. if it's defined just as \"true\", the time range will be used as modulus. if @param callbackfn will be called for each event instead of returning them in array.\r\n  Be careful because the callback is called with the copy of the eventMessage itself, and therefore any changes you do to them will be reflected in the memory\r\n  */\r\n  this.getLastTimeEvents = function(timeRangeStart, modularize = false, callbackfn = false) {\r\n    // console.log(timeRangeStart);\r\n    // console.log(\"GLSTEV\");\r\n    if (modularize) {\r\n      if (isNaN(modularize) || modularize === true) modularize = timeRangeStart;\r\n    }\r\n    var breakCondition = false;\r\n    var ret = [];\r\n    var currNode = fifo.lastEntry;\r\n    while (!breakCondition) {\r\n      // console.log(\"!BRKCON\");\r\n      if (isMemEventComplete(currNode.value)) {\r\n        var tStart = [currNode.value.starts[0], currNode.value.starts[1]];\r\n        // console.log(\"EVAL!\",tStart[0],\"vs\",timeRangeStart[0]);\r\n        if (tStart[0] == timeRangeStart[0]) {\r\n          breakCondition = tStart[1] < timeRangeStart[1];\r\n        } else if (tStart[0] < timeRangeStart[0]) {\r\n          breakCondition = true;\r\n        }else{\r\n          if (modularize) {\r\n            tStart[0] %= modularize[0];\r\n            tStart[1] %= modularize[1];\r\n          }\r\n          if (callbackfn) {\r\n            callbackfn(currNode.value);\r\n          } else {\r\n            if(!ret[tStart]) ret[tStart]=[];\r\n            ret[tStart].push(currNode.value);\r\n          }\r\n        }\r\n\r\n      }else{\r\n        throw (\"bad event\",currNode.value);\r\n      }\r\n      currNode = fifo.prev(currNode);\r\n      // console.log(\"CURRNO\", currNode);\r\n      breakCondition |= currNode === null;\r\n      if(currNode === null)console.log(\"BRKCON c\");\r\n    }\r\n    if (!callbackfn) return ret;\r\n  }\r\n  /** */\r\n  this.clockFunction = function(_currentHistoricStep, _currentMicroStep) {\r\n    self.clock.microStep = _currentMicroStep;\r\n    self.clock.historicStep = _currentHistoricStep;\r\n  }\r\n  /***/\r\n  this.setExternalClock = function(externalClock) {\r\n    self.clock = externalClock;\r\n    self.clockFunction = function() {};\r\n  }\r\n}\r\nmodule.exports = NoteLogger;\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/NoteLogger.js?");

/***/ }),

/***/ "./src/modules/MultiTape/NoteOnTracker.js":
/*!************************************************!*\
  !*** ./src/modules/MultiTape/NoteOnTracker.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage=__webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar headers = EventMessage.headers;\r\nvar NoteOnTracker = function(ownerModule) {\r\n  var trackedNotes = {};\r\n  var currentMicroStep;\r\n  var currentStep;\r\n  var noteOffSuperImpose=new EventMessage({value:[headers.triggerOff,-1,-1,-1,-1]});\r\n  this.trackEventMessage = function(eventMessage, callback) {\r\n    eventMessage.started = [currentStep, currentMicroStep];\r\n    // trackedNotes.push(eventMessage);\r\n    if (eventMessage.value[0] == headers.triggerOn) {\r\n      let eventKey = [eventMessage.value[1], eventMessage.value[2]];\r\n      trackedNotes[eventKey] = eventMessage;\r\n      if (eventMessage.duration) {\r\n        callback.call(eventMessage, false);\r\n      } else {\r\n        callback.call(eventMessage, \"noteOnTracker error: noteon without duration\");\r\n      }\r\n    } else {\r\n      callback.call(eventMessage, false);\r\n    }\r\n  }\r\n  this.clockFunction = function(_currentStep, _currentMicroStep) {\r\n    currentStep = _currentStep\r\n    currentMicroStep = _currentMicroStep\r\n    for (var a in trackedNotes) {\r\n      if (trackedNotes[a].value[0] == headers.triggerOn) {\r\n        if (trackedNotes[a].started[0] + trackedNotes[a].duration[0] <= currentStep ) {\r\n          //TODO: microstep precise length if (currentMicroStep - trackedNotes[a].started[1] >= trackedNotes[a].duration[1]) {\r\n            let off=trackedNotes[a].clone().superImpose(noteOffSuperImpose);\r\n            // console.log(\"STOP\",off);\r\n            ownerModule.output(off,true);\r\n            delete trackedNotes [a];\r\n          // }\r\n        }else{\r\n          // console.log(\"KEEP\",Array.from(trackedNotes).length);\r\n          // console.log(`${trackedNotes[a].started[0] + trackedNotes[a].duration[0]} <= ${currentStep} `);\r\n        }\r\n      }else{\r\n        delete trackedNotes [a];\r\n      }\r\n    }\r\n  }\r\n  this.setAllOff = function() {\r\n    for (var a in trackedNotes) {\r\n      // console.log(\"track\",a);\r\n      if (trackedNotes.value[0] == headers.triggerOn) {\r\n        ownerModule.output(trackedNotes[a].clone().superImpose(noteOffSuperImpose),true);\r\n      }\r\n      delete trackedNotes[a];\r\n    }\r\n    // console.log(\"tr\",trackedNotes);\r\n  }\r\n  return this;\r\n};\r\nmodule.exports = NoteOnTracker;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/NoteOnTracker.js?");

/***/ }),

/***/ "./src/modules/MultiTape/Tape.js":
/*!***************************************!*\
  !*** ./src/modules/MultiTape/Tape.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar NoteLogger = __webpack_require__(/*! ./NoteLogger.js */ \"./src/modules/MultiTape/NoteLogger.js\");\r\n\r\nvar tapeCount=0;\r\n\r\nlet propertiesApplicator=function(properties){\r\n  if(properties)for(var a in properties){\r\n    this[a]=properties[a];\r\n  }\r\n}\r\n\r\nvar Tape=function(properties){\r\n\r\n  var self=this;\r\n\r\n  var memory=this.memory=[];\r\n  var muted=this.muted={value:false};\r\n  var steps=this.steps={value:32};\r\n  var overdub=this.overdub={value:false}\r\n  var silentOnInput=this.silentOnInput={\r\n    value:true,\r\n    onInput:false,\r\n  }\r\n  var name=this.name=\"tape \"+tapeCount;\r\n  var quantize=this.quantize={grid:0,currentStep:0,microDisplacement:0};\r\n\r\n  this.excited=0;\r\n\r\n  var playhead=[0,0];\r\n  var offset=[0,0];\r\n  var lastClockFunction=[0,0];\r\n  var lastMicroStepBase=12;\r\n\r\n  //noteLogger records always, and only some of it's recorded events get into the tape memory\r\n  var noteLogger=new NoteLogger();\r\n  if(!properties.clock)throw \"please provide an anchoring clock to the tape\"\r\n  noteLogger.setExternalClock(properties.clock);\r\n\r\n  /**\r\n  @param callback the function to call for each memory event. The eventMessage will be this. Callback is called with @param-s (timeIndex,eventIndex) where timeIndex is an array containing [step,microStep] of the evenMessage caller, and eventIndex is the number of the event in that very step, since each step could contain more than one event.\r\n  you can set the time range to take in consideration using:\r\n  @param {array} timeStart time of the first memory event on whom to call the callback, in [step,microStep]\r\n  @param {array} timeEnd time of the last memory event on whom to call the callback, in [step,microStep]\r\n  */\r\n  this.eachMemoryEvent = function(callback, timeStart, timeEnd) {\r\n    if (!timeStart) timeStart = [0, 0];\r\n    if (!timeEnd) timeEnd = [clock.steps, clock.microSteps];\r\n    if (timeStart[0] === undefined) console.warn(\"eachMemoryEvent timeStart parameter must be array of [step,microStep]\");\r\n    if (timeEnd[0] === undefined) console.warn(\"eachMemoryEvent timeEnd parameter must be array of [step,microStep]\");\r\n    var timeRangeStarted = false;\r\n    for (var timeIndex in memory) {\r\n      if (!timeRangeStarted) {\r\n        if (timeStart[0] <= timeIndex[0] && timeStart[1] <= timeIndex[1]) {\r\n          timeRangeStarted = true;\r\n        }\r\n      }\r\n      if (timeRangeStarted) {\r\n        for (var eventIndex in memory[timeIndex]) {\r\n          callback.call(memory[timeIndex][eventIndex], JSON.parse(\"[\" + timeIndex + \"]\"), eventIndex);\r\n        }\r\n      }\r\n      if (timeIndex[0] >= timeEnd[0] && timeIndex[1] >= timeEnd[1]) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  this.outputFunction=function(eventMessage){\r\n    console.warn(\"no output function in \"+self.name);\r\n  }\r\n  this.clearMemory=function(){\r\n    memory.splice(0);\r\n    memory=self.memory=[];\r\n  }\r\n  this.record=function(eventMessage){\r\n    noteLogger.addEvent(eventMessage);\r\n    if(silentOnInput.value){\r\n      silentOnInput.onInput=11;\r\n    }\r\n  }\r\n  this.addEvent=function(timeIndex,eventMessage){\r\n    if(!memory[timeIndex])memory[timeIndex]=[];\r\n    memory[timeIndex].push(eventMessage);\r\n    return eventMessage;\r\n  }\r\n  this.clearStep=function(timeIndex){\r\n    delete memory[timeIndex];\r\n  }\r\n  this.hasEventsAt=function(timeIndex){\r\n    console.error(\"hasEventsAt is an undone function\");\r\n  }\r\n  this.hasEventsStartingAt=function(timeIndex){\r\n    return memory[timeIndex]?memory[timeIndex]:false;\r\n  }\r\n\r\n\r\n  this.fold=function(factor,destructive=true){\r\n    if(destructive){\r\n      if(factor<=0){\r\n        console.warn(\"folding factor can't be <=0\");\r\n      }else if(factor!=1){\r\n        //we have to iterate backward or otherwise I will remove the newly duplicated events.\r\n        var timeKeys=Object.keys(memory);\r\n        // console.log(timeKeys);\r\n        for (var kekey=timeKeys.length; kekey>0; kekey--) {\r\n          var timeIndex=JSON.parse(`[${timeKeys[kekey-1]}]`);\r\n          // var timeIndex=timeKeys[kekey-1];\r\n          // console.log(timeIndex);\r\n          if(timeIndex[0]<steps.value*factor){\r\n            // console.log(`${timeIndex[0]}<=${steps.value*factor}`);\r\n            //we are in the zone that gets duplicated\r\n            var factoredTimeIndex=[timeIndex[0]+(steps.value*factor),timeIndex[1]];\r\n            memory[factoredTimeIndex]=memory[timeIndex];\r\n            // console.log(\"DUP\",timeIndex,\">>\",factoredTimeIndex);\r\n          }else{\r\n            // console.log(`${timeIndex[0]}>${steps.value*factor}`);\r\n            //we are in the zone that gets deleted\r\n            // console.log(\"DEL\",timeIndex);\r\n            delete memory[timeIndex];\r\n          }\r\n        }\r\n      }\r\n      steps.value*=factor;\r\n    }else{\r\n      if(!factor||factor<=0){\r\n        console.warn(\"invalid folding factor: \",factor);\r\n      }else{\r\n        steps.value*=factor;\r\n      }\r\n    }\r\n  }\r\n\r\n  var lastRecordedEventTime=[0,0];\r\n  this.refreshNewTapeLengthFromRecording=false;\r\n  var evaluateNewRecording = function(){\r\n    if(self.excited>0) self.excited--;\r\n    // console.log(\"STPFN\");\r\n    //If I detect a recording or a change of length in the tape, transfer the event logger memory to the tape memory\r\n    //it's not nevessary to do this process on every microStep, it happens on steps.\r\n    noteLogger.lastEventTime(false,function(lastEventTime){\r\n      // console.log(\"LEV\",lastEventTime);\r\n      if((lastRecordedEventTime[0]!=lastEventTime[0])||self.refreshNewTapeLengthFromRecording){\r\n        self.refreshNewTapeLengthFromRecording=false;\r\n        // console.log(\"LRTTRU\");\r\n        if(!overdub.value)\r\n          self.clearMemory();\r\n        // memory=self.memory;\r\n        lastRecordedEventTime=[lastEventTime[0],lastEventTime[1]];\r\n        var time=[lastEventTime[0]-self.steps.value,lastEventTime[1]-1];\r\n        // console.log(\"TTM\",time,lastEventTime);\r\n        noteLogger.getLastTimeEvents(time, false,function(_eventMessage){\r\n          var eventMessage=_eventMessage.clone();\r\n          var timeIndex=eventMessage.starts;\r\n          timeIndex[0]%=self.steps.value;\r\n          if(!memory[timeIndex]) memory[timeIndex]=[];\r\n          memory[timeIndex].push(eventMessage);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  this.clockFunction=function(timeIndex,microStepBase){\r\n    if(!muted.value){\r\n      quantize.currentStep++;\r\n      if(quantize.currentStep<quantize.grid){\r\n        // console.log(quantize.currentStep);\r\n        if(quantize.microDisplacement===false){\r\n          quantize.microDisplacement=quantize.currentStep-timeIndex[1];\r\n        }\r\n      }else{\r\n        // console.log(\"TI\",timeIndex);\r\n        // console.log(`${quantize.currentStep}<${quantize.grid}`)\r\n        catchUpEventsToClock(timeIndex,microStepBase);\r\n        quantize.currentStep=0;\r\n      }\r\n    }\r\n\r\n    if(microStepBase!==undefined){\r\n      if(microStepBase!=lastMicroStepBase){\r\n        lastMicroStepBase=microStepBase;\r\n        console.log(\"micro step base changed in tape\");\r\n      }\r\n    }\r\n\r\n\r\n\r\n    //this over-complicated way of transfering the clock from the outside is because it allows keeping the tapes on sync, and apply displacements over that.\r\n    var clockDelta=[timeIndex[0]-lastClockFunction[0],timeIndex[1]-lastClockFunction[1]];\r\n    if(clockDelta[1]<0){\r\n      clockDelta[1]+=12;\r\n    }\r\n\r\n    if(silentOnInput.onInput){\r\n      silentOnInput.onInput -= clockDelta[1];\r\n      // console.log(silentOnInput.onInput);\r\n      if(silentOnInput.onInput<=0) silentOnInput.onInput=false;\r\n    }\r\n\r\n    if(overdub.value?true:(silentOnInput.value?!silentOnInput.onInput:true)){\r\n      if(clockDelta[0]>=1) evaluateNewRecording();\r\n    }\r\n\r\n    lastClockFunction=timeIndex;\r\n  }\r\n  let catchupHead=[0,0];\r\n  function catchUpEventsToClock(timeIndex){\r\n    while(catchupHead[0]<timeIndex[0] || catchupHead[1]!=timeIndex[1]){\r\n\r\n      // console.log(`${catchupHead[0]}<${timeIndex[0]} || ${catchupHead[1]}<${timeIndex[1]}`);\r\n      // console.log(\"CU\",playhead);\r\n      if (memory[playhead]) {\r\n        for (var eventMessage of memory[playhead]) {\r\n          self.excited++;\r\n          self.outputFunction(eventMessage);\r\n        }\r\n      }\r\n\r\n      // playhead[0]++;\r\n      playhead[1]++;\r\n      while(playhead[1]>=lastMicroStepBase){\r\n        playhead[0]++;\r\n        playhead[1]-=lastMicroStepBase;\r\n      }\r\n      playhead[0]%=steps.value;\r\n\r\n      // catchupHead[0]++;\r\n      catchupHead[1]++;\r\n      while(catchupHead[1]>=lastMicroStepBase){\r\n        catchupHead[0]++;\r\n        catchupHead[1]-=lastMicroStepBase;\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  tapeCount++;\r\n  propertiesApplicator.call(this,properties);\r\n}\r\nmodule.exports=Tape;\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/Tape.js?");

/***/ }),

/***/ "./src/modules/MultiTape/TapeCanvas.js":
/*!*********************************************!*\
  !*** ./src/modules/MultiTape/TapeCanvas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\nvar TapeCanvas=module.exports=function(controlledModule){\r\n\r\n  var self=this;\r\n  var timeRange=this.timeRange={start:[0,0]}\r\n  var stepsPerButton=this.stepsPerButton={value:2};\r\n  var microStepBase=12;\r\n\r\n  // var pressRelease = new (function(){\r\n  //   var memory={};\r\n  //   this.releaseFunction=function(data){}\r\n  //   this.press=function(identifier,attachData){\r\n  //     memory[identifier]=attachData;\r\n  //   }\r\n  //   this.release=function(identifier){\r\n  //     self.releaseFunction(memory[identifier]);\r\n  //   }\r\n  //   return this;\r\n  // })();\r\n  //\r\n  // pressRelease.releaseFunction=function(data){\r\n  //   currentTape.addEvent(data.start,data.eventMessage);\r\n  // }\r\n\r\n  this.eventsBitmap=0x00;\r\n  this.eventsTrailBitmap=0x00;\r\n  var memKeys=[];\r\n  var currentTape=false;\r\n  var setTape=this.setTape=function(tape){\r\n    currentTape=tape;\r\n  }\r\n\r\n  this.sequenceButtonCall=function(button,callback){\r\n    var timeIndex=getTimeIndexOfButton(button);\r\n    //perhaps there is a modulus composition setup?\r\n    var currentEvents=currentTape.hasEventsStartingAt(timeIndex);\r\n    callback(currentEvents,timeIndex);\r\n    //if the current button has an event, return it.\r\n    //, so we can make event selction\r\n    updateBitmap();\r\n    return false;\r\n  }\r\n  this.eventDuration=function(eventMessage,newLength){\r\n    return eventMessage;\r\n  }\r\n  var pageRight=this.pageRight=function(){\r\n    timeRange.start[0]+=16*stepsPerButton.value;\r\n    updateBitmap();\r\n  }\r\n  var pageLeft=this.pageLeft=function(tape){\r\n    timeRange.start[0]-=16*stepsPerButton.value;\r\n    updateBitmap();\r\n  }\r\n  var updateBitmap=this.updateBitmap=function(){\r\n    if(!currentTape) return;\r\n    self.eventsBitmap=0;\r\n    // console.log(\"UPB\");\r\n    memKeys=Object.keys(currentTape.memory);\r\n    for(var memKey of memKeys){\r\n      if(stepsPerButton.value<1){\r\n        var eventsPerMicroStep=currentTape.clock.microSteps*stepsPerButton.value;\r\n        var memKeyPart=memKey.split(\",\");\r\n        self.eventsBitmap|=1<<((memKeyPart[0]/stepsPerButton.value)+(memKeyPart[1]/eventsPerMicroStep));\r\n      }else{\r\n        self.eventsBitmap|=1<<memKey.split(\",\")[0]/stepsPerButton.value;\r\n      }\r\n    }\r\n  }\r\n  var getTimeIndexOfButton=function(button){\r\n    ret=[button*stepsPerButton.value,0];\r\n    if(stepsPerButton<1){\r\n      ret[1]=(button%(1/stepsPerButton))*microStepBase/stepsPerButton\r\n    }\r\n    return ret;\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/TapeCanvas.js?");

/***/ }),

/***/ "./src/modules/MultiTape/index.js":
/*!****************************************!*\
  !*** ./src/modules/MultiTape/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\n\r\nvar Tape = __webpack_require__(/*! ./Tape.js */ \"./src/modules/MultiTape/Tape.js\");\r\nvar InterfaceX28 = __webpack_require__(/*! ./InterfaceX28 */ \"./src/modules/MultiTape/InterfaceX28.js\");\r\n// var Recorder = require('./Recorder.js');\r\nvar NoteOnTracker = __webpack_require__(/*! ./NoteOnTracker.js */ \"./src/modules/MultiTape/NoteOnTracker.js\");\r\nvar headers=EventMessage.headers;\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n*/\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar MultiTape = function (properties, environment) {\r\n\r\n  this.baseName = \"multitape\";\r\n  this.interfaces.X28 = InterfaceX28;\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var noteOffSuperImpose = new EventMessage({\r\n    value: [headers.triggerOff]\r\n  });\r\n  var self = this;\r\n  var myBitmap = 0;\r\n  //\r\n  /**\r\n  Events are stored using a step-based index.\r\n  @example [[step,microStep]]={EventPattern:eventMessage,age:how old}\r\n  eventMessage contains additional information:  the duration of each note, in this way its easier to keep the noteoffs\r\n  */\r\n\r\n\r\n  var tapes = [];\r\n  this.getTapes = function () {\r\n    return tapes;\r\n  }\r\n  this.addNewTape = function () {\r\n    let len = tapes.length;\r\n    tapes.push(new Tape({\r\n      outputFunction: self.memoryOutput,\r\n      clock: clock\r\n    }));\r\n    return tapes[len];\r\n  }\r\n  this.getTapeNum = function (tape) {\r\n    return tapes.indexOf(tape);\r\n  }\r\n  this.getNumTape = function (n) {\r\n    if (tapes[n]) {\r\n      return tapes[n]\r\n    } else {\r\n      console.log(\"false\");\r\n      return false;\r\n    }\r\n  }\r\n  this.getCurrentTapeNumber = function () {\r\n    let ret = tapes.indexOf(currentTape);\r\n    return ret != -1 ? ret : false;\r\n  }\r\n  this.tapeCount = function () {\r\n    return tapes.length;\r\n  }\r\n  this.selectTape = function (tape) {\r\n    currentTape = tape;\r\n    currentMemory = tape.memory;\r\n  }\r\n  this.getCurrentTape = function () {\r\n    return currentTape;\r\n  }\r\n  this.removeTape = function (tape) {\r\n    tapes.splice(tapes.indexOf(tape, 1));\r\n  }\r\n  this.clearTape = function (tape) {\r\n    tape.clearMemory();\r\n  }\r\n  this.muteTape = function (tape) {\r\n    tape.muted.value = true;\r\n  }\r\n  this.unmuteTape = function (tape) {\r\n    tape.muted.value = false;\r\n  }\r\n  this.muteTapeToggle = function (tape) {\r\n    tape.muted.value = !tape.muted.value;\r\n  }\r\n  this.eachTape = function (cb) {\r\n    for (var n in tapes) {\r\n      cb.call(tapes[n], n);\r\n    }\r\n  }\r\n  // this.tapeFold=function(factor,destructive){\r\n  //   currentTape.fold(factor,destructive);\r\n  // }\r\n  var currentTape = false;\r\n  var currentMemory = false;\r\n\r\n  function setInitState() {\r\n    currentTape = self.addNewTape();\r\n    currentMemory = currentTape.memory;\r\n    if (properties) {\r\n      console.log(\"TODO:should apply\", properties);\r\n    }\r\n    self.recording = true;\r\n  }\r\n\r\n  var clock = this.clock = {\r\n    steps: 32,\r\n    step: 0,\r\n    microSteps: 12,\r\n    microStep: 0,\r\n    historicStep: 0\r\n  };\r\n\r\n  var noteOnTracker = new NoteOnTracker(self);\r\n\r\n  var baseEventMessage = this.baseEventMessage = new EventMessage({\r\n    value: [headers.triggerOn, -1, -1, -1]\r\n  });\r\n\r\n\r\n  this.memoryOutput = function (eventMessage) {\r\n    if (self.mute) return;\r\n    //add eventPattern to a lengthManager, play that\r\n    noteOnTracker.trackEventMessage(eventMessage, function (error) {\r\n      if (error) {\r\n        console.error(error);\r\n        return\r\n      }\r\n      self.output(eventMessage);\r\n    });\r\n  }\r\n  var clockFunction = function () {\r\n    noteOnTracker.clockFunction(clock.historicStep, clock.microStep);\r\n    for (var tape of tapes) {\r\n      tape.clockFunction([clock.historicStep, clock.microStep]);\r\n    }\r\n  }\r\n\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      evt.eventMessage.value.shift();\r\n      // if (self.recording) {\r\n      // if(evt.eventMessage.value[0]==headers.triggerOff)console.log(\"LOGOFF\");\r\n      currentTape.record(evt.eventMessage);\r\n      self.handle('eventrecorded', evt);\r\n      // }\r\n    }\r\n  }\r\n  this.messageReceived = function (evt) {\r\n\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      // console.log(\"CK\");\r\n      clock.microStep = evt.eventMessage.value[2];\r\n      clock.microSteps = evt.eventMessage.value[1];\r\n      if (evt.eventMessage.value[2] % evt.eventMessage.value[1] == 0) {\r\n        clock.step++;\r\n        clock.step %= clock.steps;\r\n        clock.historicStep++;\r\n      }\r\n      clockFunction();\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      // recorder.addEvent(evt.eventMessage);\r\n      // noteLogger.addEvent(evt.eventMessage);\r\n\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) { }\r\n  }\r\n\r\n  setInitState();\r\n\r\n  // this.onRemove = function () {\r\n  //   for (var noff of noteOnTracker) {\r\n  //     noteOnTracker.setAllOff(noff);\r\n  //   }\r\n  // }\r\n\r\n}\r\n\r\nMultiTape.color = [0, 127, 255];\r\nmodule.exports = MultiTape;\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/index.js?");

/***/ }),

/***/ "./src/modules/MultiTape/recorder.js":
/*!*******************************************!*\
  !*** ./src/modules/MultiTape/recorder.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage=__webpack_require__(/*! ../../datatypes/EventMessage */ \"./src/datatypes/EventMessage.js\");\r\nvar headers = EventMessage.headers;\r\n/**\r\n@param ownerModule: the module that will use this Recorder\r\n@param memoryArray: the array where the recorded events go. The events will be indexed using [step, microStep] as index.\r\n*/\r\nvar Recorder = function(ownerModule,memoryArray){\r\n  var trackedNotes=[];\r\n  var eventsWithNoteOn={};\r\n  var self=this;\r\n  this.clock = {\r\n    steps: 32,\r\n    step: 0,\r\n    microSteps: 12,\r\n    microStep: 0\r\n  };\r\n  function addToMemory(eventTime,eventMessage){\r\n    //find if I this event needs to be merged with other\r\n    // console.log(\"mem\",eventMessage.value,eventTime);\r\n    // ownerModule.handle('event recorded',eventTime,eventMessage);\r\n    var eventMerged=false;\r\n    for(var memIndex in memoryArray){\r\n      for(var otherEvent of memoryArray[memIndex]){\r\n        if(otherEvent.compareTo(eventMessage,[\"value\"])){\r\n          var otherEventStart=memIndex;\r\n          var thisEventStart=eventTime;\r\n          //by default, compare start and end by steps\r\n          var compareTimeindex=0;\r\n          //unless their step is the same, in which case we compare starts by microStep\r\n          if(thisEventStart==otherEventStart){\r\n            compareTimeindex=1;\r\n          }\r\n          //thisEvent started after the otherevent\r\n          if(\r\n            thisEventStart[compareTimeindex]\r\n            > otherEventStart[compareTimeindex]\r\n          ){\r\n            console.log(\"started after\");\r\n            //and otherEvent length reaches this event\r\n            if( otherEvent.duration[compareTimeindex] + otherEventStart[compareTimeindex] >= thisEventStart[compareTimeindex] ){\r\n              console.log(\" >reaches\");\r\n              eventMerged=true;\r\n              //merge the two\r\n              otherEvent.duration[compareTimeindex] =Math.max(\r\n                otherEvent.duration[compareTimeindex],\r\n                otherEventStart[compareTimeindex] - (thisEventStart[compareTimeindex]+thisEvent.duration [compareTimeindex])\r\n              );\r\n              //warparound\r\n              if(compareTimeindex===0){\r\n                while(otherEvent.duration[0]<=compareTimeindex){\r\n                  otherEvent.duration[0]+=self.clock.steps;\r\n                }\r\n              }else{\r\n                while(otherEvent.duration[1]<=compareTimeindex){\r\n                  otherEvent.duration[1]+=self.clock.microSteps;\r\n                }\r\n              }\r\n\r\n            }\r\n          }/*else{\r\n            //thisEvent started before the otherevent\r\n            //and reaches the other event\r\n            if(started[0]>=otherEvent.duration[0]+otherStep){\r\n              eventMerged=true;\r\n              //merge the two: enlarge duration and advance start\r\n              otherEvent.duration[0]=Math.max(otherStep.duration[0],otherStep-(started[0]+duration[0]));\r\n              //len warparound\r\n              if(otherEvent.duration[0]<=0){\r\n                otherEvent.duration=tapeLength.value;\r\n              }\r\n              createNewTapeEvent(otherEvent,[started]);\r\n              delete tape[otherStep][otherMicroStep][n];\r\n            }\r\n          }*/\r\n        }\r\n      }\r\n    }\r\n    if(!eventMerged){\r\n      if(!memoryArray[eventTime])memoryArray[eventTime]=[];\r\n      memoryArray[eventTime].push(eventMessage);\r\n    }\r\n  }\r\n  this.addEvent=function(eventMessage){\r\n    // console.log(memoryArray);\r\n\r\n    // console.log(\"0rec\",eventMessage.value);\r\n    var timeNow=[self.clock.step,self.clock.microStep];\r\n    var eventKey=[ eventMessage.value[1],eventMessage.value[2] ];\r\n    if(eventMessage.value[0]==headers.triggerOn){\r\n      eventMessage.starts=timeNow;\r\n      trackedNotes[eventKey]=eventMessage;\r\n    }else if(eventMessage.value[0]==headers.triggerOff){\r\n      var trackedNote=trackedNotes[eventKey];\r\n      if(trackedNote){\r\n        //started looks like: [step,microStep]\r\n        var started=trackedNote.starts;\r\n        trackedNote.duration=[self.clock.step-started[0],self.clock.microStep-started[1]];\r\n        //wraparound durations\r\n        while(trackedNote.duration[0]<1){\r\n          // console.log(\"1rec\",eventMessage.value);\r\n          trackedNote.duration[0]+=self.clock.steps;\r\n        }\r\n        while(trackedNote.duration[1]<0){\r\n          // console.log(\"2rec\",eventMessage.value);\r\n          trackedNote.duration[1]+=self.clock.microSteps;\r\n        }\r\n        addToMemory(started,trackedNote);\r\n      }else{\r\n        console.warn(\"received a noteoff for a note that was not being tracked\");\r\n      }\r\n    }else{\r\n      addToMemory(timeNow,eventMessage);\r\n    }\r\n  }\r\n  this.clockFunction=function(_currentStep,_currentMicroStep){\r\n    self.clock.step=_currentStep;\r\n    self.clock.microStep=_currentMicroStep;\r\n  }\r\n\r\n  this.setExternalClock=function(externalClock){\r\n    self.clock=externalClock;\r\n    self.clockFunction=function(){};\r\n  }\r\n  return this;\r\n}\r\nmodule.exports=Recorder;\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/recorder.js?");

/***/ }),

/***/ "./src/modules/MultiTape/x28-ArrangementView.js":
/*!******************************************************!*\
  !*** ./src/modules/MultiTape/x28-ArrangementView.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\n// var EventConfigurator=require('../x16utils/EventConfigurator.js');\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n\r\nmodule.exports = function(environment, parentInteractor) {\r\n  var controlledModule = parentInteractor.controlledModule;\r\n  var self = this;\r\n\r\n  var myColor = controlledModule.color;\r\n\r\n  var selectedTapeNumber = 0;\r\n  var selectedTape = false;\r\n  var tapesAmount = 1;\r\n  var engagedConfigurator = false;\r\n\r\n  var muteMode = false;\r\n\r\n  var engagedHardwares = this.engagedHardwares = new Set();\r\n\r\n\r\n\r\n  var configurators = {};\r\n  // configurators.event=new EventConfigurator(this,{baseEvent:controlledModule.baseEventMessage});\r\n  configurators.tapeTime = new BlankConfigurator(this, {\r\n    name: \"tape\",\r\n    vars: {\r\n      \"length\": {\r\n        value: 0\r\n      },\r\n      \"fold\": {\r\n        value: 1,\r\n        factor: 2,\r\n        opDisp: \" \"\r\n      },\r\n      \"fold!\": {\r\n        value: 1,\r\n        factor: 2,\r\n        opDisp: \" \"\r\n      },\r\n      \"quantize\": {\r\n        value: 0\r\n      },\r\n      \"clear!\": {\r\n        value: 0\r\n      }\r\n    }\r\n  });\r\n\r\n  configurators.tapeTime.vars[\"length\"].changeFunction = configurators.tapeTime.vars[\"length\"].selectFunction = function(thisVar, delta) {\r\n    if (selectedTape) {\r\n      thisVar.value = selectedTape.steps.value;\r\n      if (thisVar.value + delta >= 1) {\r\n        thisVar.value += delta;\r\n        selectedTape.steps.value = thisVar.value;\r\n        selectedTape.refreshNewTapeLengthFromRecording = true;\r\n      }\r\n    }\r\n  }\r\n  configurators.tapeTime.vars[\"fold!\"].changeFunction = function(thisVar, delta) {\r\n    if (selectedTape) {\r\n      thisVar.value = selectedTape.steps.value;\r\n      if (delta > 0) {\r\n        thisVar.value = thisVar.factor;\r\n        thisVar.opDisp = \"*\";\r\n      } else {\r\n        thisVar.value = 1 / thisVar.factor;\r\n        thisVar.opDisp = \"/\";\r\n      }\r\n      selectedTape.fold(thisVar.value, true);\r\n    }\r\n  }\r\n  configurators.tapeTime.vars[\"fold!\"].nameFunction = function(thisVar) {\r\n    return \"l\" + thisVar.opDisp + thisVar.factor + \"=\" + selectedTape.steps.value;\r\n  }\r\n  configurators.tapeTime.vars[\"fold\"].changeFunction = function(thisVar, delta) {\r\n    if (selectedTape) {\r\n      thisVar.value = selectedTape.steps.value;\r\n      if (delta > 0) {\r\n        thisVar.value = thisVar.factor;\r\n        thisVar.opDisp = \"*\";\r\n      } else {\r\n        thisVar.value = 1 / thisVar.factor;\r\n        thisVar.opDisp = \"/\";\r\n      }\r\n      selectedTape.fold(thisVar.value, false);\r\n    }\r\n  }\r\n  configurators.tapeTime.vars[\"fold\"].nameFunction = function(thisVar) {\r\n    return \"l\" + thisVar.opDisp + thisVar.factor + \"=\" + selectedTape.steps.value;\r\n  }\r\n  configurators.tapeTime.vars[\"clear!\"].changeFunction = function(thisVar, delta) {\r\n    if (selectedTape) {\r\n      thisVar.value += Math.abs(delta);\r\n      thisVar.value %= 2;\r\n    }\r\n  }\r\n  configurators.tapeTime.vars[\"clear!\"].selectFunction = function(thisVar) {\r\n    thisVar.value = 0;\r\n  }\r\n  configurators.tapeTime.vars[\"clear!\"].disengageFunction = function(thisVar) {\r\n    if (thisVar.value == 1) {\r\n      if (selectedTape)\r\n        controlledModule.clearTape(selectedTape);\r\n    }\r\n  }\r\n  configurators.tapeTime.vars[\"clear!\"].nameFunction = function(thisVar) {\r\n    return (thisVar.value ? \"Clear on release\" : \"cancel\");\r\n  }\r\n  var lastEngagedConfigurator = configurators.tapeTime;\r\n\r\n  function eachEngagedHardware(cb) {\r\n    for (let hardware of engagedHardwares) {\r\n      cb(hardware);\r\n    }\r\n  }\r\n\r\n  parentInteractor.on('interaction', function(event) {\r\n    if (engagedHardwares.has(event.hardware)) {\r\n      if (typeof self[event.type] === 'function') {\r\n        // console.log(\"sequence view, event \",event);\r\n        self[event.type](event);\r\n      } else {\r\n        console.log(\"unhandled interaction\", event);\r\n      }\r\n    }\r\n  });\r\n\r\n  setInterval(function() {\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  }, 1000 / 50);\r\n  this.windowButtonPressed = function(event){\r\n    if (event.button >= tapesAmount) {\r\n      var newTape = controlledModule.addNewTape();\r\n      controlledModule.selectTape(newTape);\r\n      selectedTape = newTape;\r\n      // selectedTapeNumber = controlledModule.getTapeNum(newTape);\r\n      selectedTapeNumber=controlledModule.getCurrentTapeNumber();\r\n      tapesAmount = controlledModule.tapeCount();\r\n    } else {\r\n      let thereIs = controlledModule.getNumTape(event.button);\r\n      // console.log(thereIs);\r\n      if (thereIs) {\r\n        controlledModule.selectTape(thereIs);\r\n        selectedTapeNumber = event.button;\r\n        selectedTape = thereIs;\r\n      }\r\n    }\r\n    if (muteMode && selectedTape) {\r\n      controlledModule.muteTapeToggle(selectedTape);\r\n    }\r\n  }\r\n  this.windowButtonReleased = function(event){\r\n\r\n  }\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      self.windowButtonPressed(event);\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonReleased(event);\r\n    } else {\r\n      // controlledModule.clearStep(event.button);\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function(event) {};\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n\r\n    if(!selectedTape){\r\n      selectedTape=controlledModule.getNumTape(selectedTapeNumber);\r\n    }\r\n\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.button == 7) {\r\n        muteMode = true;\r\n        eachEngagedHardware(updateScreen);\r\n      }\r\n      if (event.button == 1) {\r\n        if (selectedTape) {\r\n          engagedConfigurator = configurators.tapeTime;\r\n          configurators.tapeTime.engage(event);\r\n          eachEngagedHardware(updateScreen);\r\n\r\n        }\r\n      }\r\n      lastEngagedConfigurator = engagedConfigurator;\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator = false;\r\n    }\r\n    if (event.button == 7) {\r\n      muteMode = false;\r\n      eachEngagedHardware(updateScreen);\r\n    }\r\n    // if(event.button==5){\r\n    //   if(engagedConfigurator==configurators.tapeTime){\r\n    //     engagedConfigurator=false;\r\n    //     configurators.tapeTime.engage(event);\r\n    //   }\r\n    // }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function(hardware) {\r\n\r\n    updateScreen(hardware);\r\n    updateLeds(hardware);\r\n\r\n  }\r\n  var updateScreen = function(hardware) {\r\n    if (!engagedConfigurator) {\r\n\r\n      hardware.sendScreenA((controlledModule.name.substring(0, 5)) + \">\" + (muteMode ? \"mute\" : \"arrange\"));\r\n      hardware.sendScreenB(\"tape \" + selectedTapeNumber + \" \" + (selectedTape ? (selectedTape.muted.value ? \"muted\" : \"active\") : \"\"));\r\n    }\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    if (!engagedConfigurator) {\r\n      var selectedTapeBitmap = 1 << selectedTapeNumber;\r\n      var mutedTapesBitmap = 0;\r\n      var excitedTapesBitmap = 0;\r\n      controlledModule.eachTape(function(n) {\r\n        if (this.muted.value) mutedTapesBitmap |= 1 << n;\r\n        if (this.excited > 0) excitedTapesBitmap |= 1 << n;\r\n      });\r\n      var tapesBitmap = ~(0xffff << tapesAmount);\r\n      hardware.draw([\r\n          excitedTapesBitmap  |selectedTapeBitmap  | mutedTapesBitmap,\r\n          excitedTapesBitmap  |selectedTapeBitmap  |(tapesBitmap   &~mutedTapesBitmap),\r\n        ( selectedTapeBitmap  ^excitedTapesBitmap  | tapesBitmap)  &~mutedTapesBitmap]);\r\n      // hardware.clear();\r\n      // hardware.drawColor(tapesBitmap&0xffff, myColor);\r\n      // hardware.drawColor(mutedTapesBitmap&0xffff, [127, 126, 127]);\r\n      // hardware.drawColor(selectedTapeBitmap & excitedTapesBitmap&0xffff, [255, 255, 255]);\r\n\r\n    }\r\n  }\r\n}\r\n/**/\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/x28-ArrangementView.js?");

/***/ }),

/***/ "./src/modules/MultiTape/x28-SequenceView.js":
/*!***************************************************!*\
  !*** ./src/modules/MultiTape/x28-SequenceView.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage=__webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar TimeIndex=__webpack_require__(/*! ../../datatypes/TimeIndex */ \"./src/datatypes/TimeIndex.js\");\r\n\r\nvar EventConfigurator=__webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar TapeCanvas=__webpack_require__(/*! ./TapeCanvas.js */ \"./src/modules/MultiTape/TapeCanvas.js\");\r\n\r\nmodule.exports=function(environment,parentInteractor){\r\n  var controlledModule=parentInteractor.controlledModule;\r\n  var configurators={};\r\n  var engagedConfigurator=false;\r\n  var lastEngagedConfigurator=false;\r\n  configurators.event=new EventConfigurator(this,{baseEvent:controlledModule.baseEventMessage});\r\n  var tapeCanvas=new TapeCanvas(controlledModule);\r\n  var stepsBmp=0;\r\n  var engagedHardwares=this.engagedHardwares=new Set();\r\n  var self=this;\r\n  var refreshInterval=false;\r\n  var needUpdateSequence=false;\r\n  var currentTape=false;\r\n\r\n  var currentlySelectedEvents=false;\r\n\r\n  var momentaryBitmap=false;\r\n  var myColor=controlledModule.color;\r\n  parentInteractor.on('interaction',function(event){\r\n    if (engagedHardwares.has(event.hardware)){\r\n      if(typeof self[event.type]==='function'){\r\n        // console.log(\"sequence view, event \"+event.type);\r\n        self[event.type](event);\r\n      }else{\r\n        console.log(\"unhandled interaction\",event);\r\n      }\r\n    }\r\n  });\r\n  controlledModule.on('eventrecorded',function(){\r\n    needUpdateSequence=true;\r\n  });\r\n\r\n  function eachEngagedHardware(cb){\r\n    for(let hardware of engagedHardwares){\r\n      cb(hardware);\r\n    }\r\n  }\r\n\r\n  this.matrixButtonPressed=function(event){\r\n    if(engagedConfigurator){\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    }else{\r\n      var buttonEvents=tapeCanvas.sequenceButtonCall(event.button,function(currentEvents,timeIndex){\r\n        if(event.tied){\r\n          // console.log(\"TIED\");\r\n          if(currentlySelectedEvents){\r\n            // console.log(\"DUR\",timeIndex);\r\n            //dummy duration, should actually be timeIndex-currentEvent.start\r\n            //but currentEvent.start donesnt exist\r\n            //adn if result is negative, the start of event is shifted\r\n            currentlySelectedEvents[0].duration=timeIndex;\r\n            // TimeIndex.add(currentlySelectedEvents[0].start,timeIndex);\r\n          }\r\n        }else{\r\n          if(currentEvents){\r\n            currentTape.clearStep(timeIndex);\r\n            currentlySelectedEvents=currentEvents;\r\n          }else{\r\n            var newEvent=currentTape.addEvent(timeIndex,configurators.event.getEventMessage());\r\n            newEvent.duration=[2,0];\r\n            currentlySelectedEvents=[newEvent];\r\n          }\r\n        }\r\n\r\n      });\r\n      eachEngagedHardware(updateHardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased=function(event){\r\n    if(engagedConfigurator){\r\n    }else{\r\n      eachEngagedHardware(updateHardware);\r\n    }\r\n  };\r\n\r\n  this.selectorButtonPressed=function(event){\r\n    if(engagedConfigurator){\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    }else{\r\n      if(event.button==1){\r\n        lastEngagedConfigurator=engagedConfigurator=configurators.event;\r\n        engagedConfigurator.engage(event);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased=function(event){\r\n    var hardware=event.hardware;\r\n    if(engagedConfigurator){\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator=false;\r\n    }\r\n  };\r\n  this.bottomButtonPressed=function(event){\r\n    if(event.button==\"right\"){\r\n      momentaryBitmap=0b0000010010000100;\r\n      tapeCanvas.pageRight();\r\n    }else{\r\n      momentaryBitmap=0b0000001000010010;\r\n      tapeCanvas.pageRight();\r\n    }\r\n  }\r\n  this.bottomButtonReleased=function(event){\r\n    // console.log(event);\r\n    momentaryBitmap=false;\r\n  }\r\n\r\n  this.encoderScrolled=function(event){\r\n    if(engagedConfigurator){\r\n      engagedConfigurator.encoderScrolled(event);\r\n    }else{\r\n      if(lastEngagedConfigurator){\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.engage=function(event){\r\n\r\n    currentTape=controlledModule.getCurrentTape();\r\n    tapeCanvas.setTape(currentTape);\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n    refreshInterval=setInterval(function(){\r\n      if(needUpdateSequence){\r\n        needUpdateSequence=false;\r\n        tapeCanvas.updateBitmap();\r\n      }\r\n      if(!engagedConfigurator){\r\n        eachEngagedHardware(updateLeds);\r\n      }\r\n    },1000/20);\r\n  };\r\n  this.disengage=function(event){\r\n    engagedHardwares.delete(event.hardware);\r\n    clearInterval(refreshInterval);\r\n  }\r\n  var updateHardware=function(hardware){\r\n    updateScreen(hardware);\r\n    updateLeds(hardware);\r\n  }\r\n  var updateScreen=function(hardware){\r\n    hardware.sendScreenA(controlledModule.name.substring(0,5)+\">sequence\");\r\n  }\r\n  var updateLeds=function(hardware){\r\n    if(momentaryBitmap){\r\n      // hardware.draw([momentaryBitmap,0,0]);\r\n      hardware.drawColor(momentaryBitmap,myColor,false);\r\n    }else{\r\n      var eventsBmp=tapeCanvas.eventsBitmap;\r\n      var headerBmp=1<<((controlledModule.clock.step/tapeCanvas.stepsPerButton.value)+tapeCanvas.timeRange.start[0]);\r\n      //TODO: this function is taking way too much time\r\n      // controlledModule.eachMemoryEvent(function(timeIndex,eventIndex){\r\n      //   console.log(timeIndex);\r\n      //   eventsBmp|=1<<(timeIndex[0]/2);\r\n      // });\r\n      hardware.drawColor(eventsBmp,myColor,false);\r\n      hardware.drawColor(headerBmp,[255,255,255]);\r\n\r\n      // hardware.draw([selectedTapeBitmap,selectedTapeBitmap|tapesBitmap,selectedTapeBitmap|tapesBitmap]);\r\n    }\r\n  }\r\n}\r\n/**/\n\n//# sourceURL=webpack://environment/./src/modules/MultiTape/x28-SequenceView.js?");

/***/ }),

/***/ "./src/modules/Narp/HttpGui.js":
/*!*************************************!*\
  !*** ./src/modules/Narp/HttpGui.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// var Base=require('../../interaction/http-server/InteractorBase.js');\r\nmodule.exports=function(controlledModule, environment, gui){\r\n  // Base.call(this,controlledModule,environment,gui);\r\n  this.features={\r\n    grid:{type:'grid',w:4,h:4},\r\n    console:{type:'text'}\r\n  }\r\n\r\n  gui.on('input',function(){\r\n    console.log('user input on http');\r\n  });\r\n\r\n  controlledModule.on('step',function(evt){\r\n    gui.update('grid',{highlight:evt.bmp});\r\n  });\r\n  controlledModule.on('~bitmap',function(evt){\r\n    gui.update('grid',{bitmap:evt.bmp});\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Narp/HttpGui.js?");

/***/ }),

/***/ "./src/modules/Narp/InterfaceX16.js":
/*!******************************************!*\
  !*** ./src/modules/Narp/InterfaceX16.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\n\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function(controlledModule,environment) {\r\n  base.call(this);\r\n  var currentStep = 0;\r\n  var configurators = {};\r\n  configurators.event = new EventConfigurator(this, {\r\n    baseEvent: controlledModule.baseEventMessage\r\n  });\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  });\r\n  configurators.time = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"step ratio\": {\r\n        value:controlledModule.stepDivision.value,\r\n      },\r\n      \"mode\": {\r\n        value: \"toggle\",\r\n        changeFunction: function(thisVar, delta) {\r\n          if (thisVar.value == \"momentary\") {\r\n            thisVar.value = \"toggle\"\r\n          } else {\r\n            thisVar.value = \"momentary\"\r\n          }\r\n        },\r\n        disengageFunction: function(thisVar) {\r\n          if (thisVar.value == \"momentary\") {\r\n            controlledModule.clearAll();\r\n          }\r\n        }\r\n      },\r\n      \"note duration\": controlledModule.noteDuration\r\n    }\r\n  });\r\n  configurators.time.vars[\"step ratio\"].changeFunction = function(thisVar, delta) {\r\n\r\n    thisVar.value=controlledModule.stepDivision.value\r\n\r\n    if (delta > 0) {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value *= 2;\r\n      } else {\r\n        thisVar.value++\r\n      }\r\n    } else {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value /= 2;\r\n      } else {\r\n        thisVar.value--;\r\n      }\r\n    }\r\n    controlledModule.stepDivision.value=thisVar.value;\r\n    controlledModule.recordStepDivision();\r\n  };\r\n\r\n  configurators.time.vars[\"note duration\"].changeFunction = function(thisVar, delta) {\r\n    delta /= 12;\r\n    thisVar.value += delta;\r\n  };\r\n  configurators.time.vars[\"note duration\"].nameFunction = function(thisVar) {\r\n    return (Math.floor(thisVar.value * 100) / 100) + \" steps\";\r\n  };\r\n\r\n  \r\n  this.outsideScroll = function (event) {\r\n    configurators.time.vars[\"step ratio\"].changeFunction(\r\n      configurators.time.vars[\"step ratio\"],\r\n      event.delta);\r\n    return (\"steps:\"+configurators.time.vars[\"step ratio\"].value);\r\n  }\r\n\r\n  var playMode = configurators.time.vars[\"mode\"];\r\n\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = 0;\r\n\r\n  function hasEvent(button) {\r\n    return 0 != (controlledModule.getBitmap16() & (1 << button));\r\n  }\r\n  var engagedHardwares = new Set();\r\n  controlledModule.on('step', function(step) {\r\n    // console.log(\"STPP\");\r\n    currentStep = step;\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  });\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      if (playMode.value == \"momentary\") {\r\n        controlledModule.setStep(event.button,true);\r\n      } else {\r\n        controlledModule.toggleStep(event.button,true);\r\n      }\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    if (engagedConfigurator) {} else {\r\n      if (playMode.value == \"momentary\") {\r\n        controlledModule.clearStep(event.button,true);\r\n      } else {}\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else if (event.data[0] == 1) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.event;\r\n    }else if (event.data[0] == 2) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.time;\r\n    }else if (event.button >= 8) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.record;\r\n    }\r\n    if(engagedConfigurator){\r\n      engagedConfigurator.engage(event);\r\n      lastEngagedConfigurator = engagedConfigurator;\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator){\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator = false;\r\n      updateHardware(hardware);\r\n    }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  configurators.record.autoEngageWindow();\r\n  var updateHardware = function(hardware) {\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateScreen = function(hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    // hardware.sendScreenB(\"n:\"+currentStep);\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    let bmp = controlledModule.getBitmaps16();\r\n    hardware.draw([bmp.header | bmp.steps, bmp.header, bmp.header | bmp.steps]);\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Narp/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/Narp/index.js":
/*!***********************************!*\
  !*** ./src/modules/Narp/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\n\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/Narp/InterfaceX16.js\");\r\n// var InterfaceHttp = require('./HttpGui');\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n\r\n*/\r\n\r\nvar instancesCount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + instancesCount;\r\n  instancesCount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar Narp = function (properties, environment) {\r\n  var self = this;\r\n  var myBitmap = this.bitmap = 0;\r\n  var currentStep = 0;\r\n  var stepDivision = this.stepDivision = {\r\n    value: 2\r\n  }\r\n\r\n  var noteDuration = this.noteDuration = {\r\n    value: 1\r\n  }\r\n\r\n  var noteOnTracker = new NoteOnTracker(this);\r\n  var substep = 0;\r\n\r\n  this.baseName = \"narp\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n\r\n  var baseEventMessage = this.baseEventMessage = new EventMessage({\r\n    value: [headers.triggerOn, -1, -1, -1]\r\n  });\r\n\r\n\r\n  this.recordingUi = true;\r\n\r\n  var recMessages = {\r\n    set: new EventMessage({ value: [headers.triggerOn, -1, -1] }),\r\n    clear: new EventMessage({ value: [headers.triggerOff, -1, -1] }),\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] }),\r\n  }\r\n\r\n  this.recordStepDivision = function () {\r\n    recMessages.rate.value[2] = stepDivision.value * 12;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n  // this.interfaces.Http = InterfaceHttp;\r\n\r\n  var setStep = this.setStep = function (square, uiTriggered = false) {\r\n    myBitmap |= 1 << square;\r\n    if (self.recordingUi && uiTriggered) {\r\n      recMessages.set.value[1] = square;\r\n      self.recordOutput(recMessages.set);\r\n      // console.log(\"RECO\");\r\n    }\r\n    self.handle('~bitmap', { bmp: myBitmap, operation: \"+\" });\r\n    self.handleStepsChange();\r\n  }\r\n\r\n  var clearStep = this.clearStep = function (square, uiTriggered = false) {\r\n    myBitmap &= ~(1 << square);\r\n    if (self.recordingUi && uiTriggered) {\r\n      recMessages.clear.value[1] = square;\r\n      self.recordOutput(recMessages.clear);\r\n      // console.log(\"RECO\");\r\n    }\r\n    self.handle('~bitmap', { bmp: myBitmap, operation: \"-\" });\r\n    self.handleStepsChange();\r\n  }\r\n\r\n  var toggleStep = this.toggleStep = function (square, uiTriggered = false) {\r\n    if (myBitmap & (1 << square)) {\r\n      clearStep(square, uiTriggered);\r\n    } else {\r\n      setStep(square, uiTriggered);\r\n    }\r\n    return myBitmap;\r\n  }\r\n\r\n  var clearAll = this.clearAll = function () {\r\n    myBitmap = 0;\r\n    self.handle('~bitmap', { bmp: myBitmap, operation: \"=\" });\r\n  }\r\n\r\n  this.handleStepsChange = function () {\r\n    var active = activeNumbers();\r\n    self.handle('~module', { steps: active.length });\r\n  }\r\n\r\n  var generatedOutput = function (eventMessage, buttonNumber) {\r\n    if (self.mute) return;\r\n    eventMessage.life = Math.ceil(noteDuration.value);\r\n    noteOnTracker.add(eventMessage);\r\n    self.output(eventMessage);\r\n  }\r\n\r\n  var headerBmp = 0;\r\n  var stepFunction = function () {\r\n    var active = activeNumbers();\r\n    if (active.length) {\r\n      currentStep %= active.length;\r\n      var loneBit = myBitmap & (1 << active[currentStep]);\r\n      headerBmp = loneBit;\r\n      // console.log(currentStep);\r\n      // console.log(loneBit.toString(2));\r\n      if (loneBit) {\r\n        var op = Math.log2(loneBit);\r\n        // console.log(op);\r\n\r\n        let outputMessage = baseEventMessage.clone();\r\n        outputMessage.value[1] = baseEventMessage.value[1] + op;\r\n\r\n        generatedOutput(outputMessage, op);\r\n\r\n        self.handle('step', {\r\n          step: currentStep,\r\n          generated: op,\r\n          bmp: loneBit,\r\n        });\r\n      }\r\n      currentStep++;\r\n    } else {\r\n      headerBmp = 0;\r\n    }\r\n  }\r\n  var activeNumbers = function () {\r\n    var keepGoing = myBitmap;\r\n    var ret = [];\r\n    var count = 0;\r\n    while (keepGoing > 0) {\r\n      if (1 & keepGoing) {\r\n        ret.push(count);\r\n      }\r\n      count++;\r\n      keepGoing = keepGoing >> 1;\r\n    }\r\n    return ret;\r\n  }\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      var clockBase = evt.eventMessage.value[1];\r\n      var clockMicroStep = evt.eventMessage.value[2];\r\n      if ((clockMicroStep / stepDivision.value) % clockBase == 0) {\r\n        substep++;\r\n        if (substep >= stepDivision.value) {\r\n          substep = 0;\r\n          stepFunction();\r\n        }\r\n      }\r\n      noteOnTracker.each(function (noteOff, identifier) {\r\n        noteOff.life -= 1 / clockBase;\r\n        // console.log(\"LF\",noteOff.life);\r\n        if (noteOff.life <= 0) {\r\n          self.output(noteOnTracker.noteOff(identifier));\r\n        }\r\n      });\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      this.setStep(evt.eventMessage.value[1] % 16);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      this.clearStep(evt.eventMessage.value[1] % 16);\r\n    } else if (evt.eventMessage.value[0] == headers.changeRate) {\r\n      // console.log(\"CHANGERATEHEAER\",evt.eventMessage.value);\r\n      stepDivision.value = evt.eventMessage.value[2] / (evt.eventMessage.value[1] || 1);\r\n    } \r\n  }\r\n  this.getBitmaps16 = function () {\r\n    return {\r\n      steps: myBitmap,\r\n      header: headerBmp & myBitmap\r\n    };\r\n  }\r\n\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.each(function (noteOff, identifier) {\r\n  //     self.output(noteOff, false);\r\n  //   });\r\n  //   noteOnTracker.empty();\r\n  //   clearAll();\r\n  //   return true;\r\n  // }\r\n}\r\n\r\nNarp.color = [100, 0, 190];\r\nmodule.exports = Narp\n\n//# sourceURL=webpack://environment/./src/modules/Narp/index.js?");

/***/ }),

/***/ "./src/modules/Noise/HttpGui.js":
/*!**************************************!*\
  !*** ./src/modules/Noise/HttpGui.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// var Base=require('../../interaction/http-server/InteractorBase.js');\r\nmodule.exports=function(controlledModule, environment, gui){\r\n  // Base.call(this,controlledModule,environment,gui);\r\n  this.features={\r\n    grid:{type:'grid',w:4,h:4},\r\n    console:{type:'text'}\r\n  }\r\n\r\n  gui.on('input',function(){\r\n    console.log('user input on http');\r\n  });\r\n\r\n  controlledModule.on('step',function(evt){\r\n    gui.update('grid',{highlight:evt.bmp});\r\n  });\r\n  controlledModule.on('~bitmap',function(evt){\r\n    gui.update('grid',{bitmap:evt.bmp});\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Noise/HttpGui.js?");

/***/ }),

/***/ "./src/modules/Noise/InterfaceX16.js":
/*!*******************************************!*\
  !*** ./src/modules/Noise/InterfaceX16.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\n\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function(controlledModule,environment) {\r\n  base.call(this);\r\n  var currentStep = 0;\r\n  var configurators = {};\r\n  configurators.event = new EventConfigurator(this, {\r\n    baseEvent: controlledModule.baseEventMessage\r\n  });\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  });\r\n  configurators.time = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"step ratio\": {\r\n        value:controlledModule.stepDivision.value,\r\n      },\r\n      \"mode\": {\r\n        value: \"toggle\",\r\n        changeFunction: function(thisVar, delta) {\r\n          if (thisVar.value == \"momentary\") {\r\n            thisVar.value = \"toggle\"\r\n          } else {\r\n            thisVar.value = \"momentary\"\r\n          }\r\n        },\r\n        disengageFunction: function(thisVar) {\r\n          if (thisVar.value == \"momentary\") {\r\n            controlledModule.clearAll();\r\n          }\r\n        }\r\n      },\r\n      \"note duration\": controlledModule.noteDuration,\r\n      \"probability\":controlledModule.probability,\r\n    }\r\n  });\r\n  configurators.time.vars[\"step ratio\"].changeFunction = function(thisVar, delta) {\r\n\r\n    thisVar.value=controlledModule.stepDivision.value\r\n\r\n    if (delta > 0) {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value *= 2;\r\n      } else {\r\n        thisVar.value++\r\n      }\r\n    } else {\r\n      if (thisVar.value < 2) {\r\n        thisVar.value /= 2;\r\n      } else {\r\n        thisVar.value--;\r\n      }\r\n    }\r\n    controlledModule.stepDivision.value=thisVar.value;\r\n    controlledModule.recordStepDivision();\r\n  };\r\n\r\n  configurators.time.vars[\"note duration\"].changeFunction = function(thisVar, delta) {\r\n    delta /= 12;\r\n    thisVar.value += delta;\r\n  };\r\n  configurators.time.vars[\"note duration\"].nameFunction = function(thisVar) {\r\n    return (Math.floor(thisVar.value * 100) / 100) + \" steps\";\r\n  };\r\n\r\n  \r\n  this.outsideScroll = function (event) {\r\n    configurators.time.vars[\"step ratio\"].changeFunction(\r\n      configurators.time.vars[\"step ratio\"],\r\n      event.delta);\r\n    return (\"steps:\"+configurators.time.vars[\"step ratio\"].value);\r\n  }\r\n\r\n  var playMode = configurators.time.vars[\"mode\"];\r\n\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = 0;\r\n\r\n  function hasEvent(button) {\r\n    return 0 != (controlledModule.getBitmap16() & (1 << button));\r\n  }\r\n  var engagedHardwares = new Set();\r\n  controlledModule.on('step', function(step) {\r\n    // console.log(\"STPP\");\r\n    currentStep = step;\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  });\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      if (playMode.value == \"momentary\") {\r\n        controlledModule.setStep(event.button,true);\r\n      } else {\r\n        controlledModule.toggleStep(event.button,true);\r\n      }\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    if (engagedConfigurator) {} else {\r\n      if (playMode.value == \"momentary\") {\r\n        controlledModule.clearStep(event.button,true);\r\n      } else {}\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else if (event.data[0] == 1) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.event;\r\n    }else if (event.data[0] == 2) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.time;\r\n    }else if (event.button >= 8) {\r\n      lastEngagedConfigurator = engagedConfigurator = configurators.record;\r\n    }\r\n    if(engagedConfigurator){\r\n      engagedConfigurator.engage(event);\r\n      lastEngagedConfigurator = engagedConfigurator;\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator){\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator = false;\r\n      updateHardware(hardware);\r\n    }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  configurators.record.autoEngageWindow();\r\n  var updateHardware = function(hardware) {\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateScreen = function(hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    // hardware.sendScreenB(\"n:\"+currentStep);\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    let bmp = controlledModule.getBitmaps16();\r\n    hardware.draw([bmp.header | bmp.steps, bmp.header, bmp.header | bmp.steps]);\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Noise/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/Noise/index.js":
/*!************************************!*\
  !*** ./src/modules/Noise/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\n\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/Noise/InterfaceX16.js\");\r\n// var InterfaceHttp = require('./HttpGui');\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n\r\n*/\r\n\r\nvar instancesCount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + instancesCount;\r\n  instancesCount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar Noise = function (properties, environment) {\r\n  var self = this;\r\n  var myBitmap = this.bitmap = 0;\r\n  var patMem = new Set();\r\n  var currentStep = 0;\r\n  var stepDivision = this.stepDivision = {\r\n    value: 2\r\n  }\r\n  var probability = this.probability={\r\n    value:1,\r\n    nameFunction(thisVar){\r\n      return thisVar.value*100+\"%\";\r\n    },\r\n    changeFunction(thisVar,delta){\r\n      thisVar.value+=delta*0.01;\r\n      thisVar.value = Math.round(thisVar.value * 100) / 100;\r\n    }\r\n  }\r\n\r\n  var noteDuration = this.noteDuration = {\r\n    value: 1\r\n  }\r\n\r\n  var noteOnTracker = new NoteOnTracker(this);\r\n  var substep = 0;\r\n\r\n  this.baseName = \"Noise\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n\r\n  var baseEventMessage = this.baseEventMessage = new EventMessage({\r\n    value: [headers.triggerOn, 0, -1, -1]\r\n  });\r\n\r\n\r\n  this.recordingUi = true;\r\n\r\n  var recMessages = {\r\n    set: new EventMessage({ value: [headers.triggerOn, -1, -1] }),\r\n    clear: new EventMessage({ value: [headers.triggerOff, -1, -1] }),\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] }),\r\n  }\r\n\r\n  this.recordStepDivision = function () {\r\n    recMessages.rate.value[2] = stepDivision.value * 12;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n  // this.interfaces.Http = InterfaceHttp;\r\n\r\n  var setStep = this.setStep = function (square, uiTriggered = false) {\r\n    patMem.add(square);\r\n    if (self.recordingUi && uiTriggered) {\r\n      recMessages.set.value[1] = square;\r\n      self.recordOutput(recMessages.set);\r\n      // console.log(\"RECO\");\r\n    }\r\n    self.handleStepsChange();\r\n  }\r\n\r\n  var clearStep = this.clearStep = function (square, uiTriggered = false) {\r\n    patMem.delete(square);\r\n    if (self.recordingUi && uiTriggered) {\r\n      recMessages.clear.value[1] = square;\r\n      self.recordOutput(recMessages.clear);\r\n      // console.log(\"RECO\");\r\n    }\r\n    self.handleStepsChange();\r\n  }\r\n\r\n  var toggleStep = this.toggleStep = function (square, uiTriggered = false) {\r\n    if (patMem.has(square)) {\r\n      clearStep(square, uiTriggered);\r\n    } else {\r\n      setStep(square, uiTriggered);\r\n    }\r\n    return myBitmap;\r\n  }\r\n\r\n  var clearAll = this.clearAll = function () {\r\n    patMem.clear();\r\n    self.handleStepsChange();\r\n  }\r\n\r\n  this.handleStepsChange = function () {\r\n    activeNumbers();\r\n    self.handle('~module', { steps: patMem.size });\r\n  }\r\n\r\n  var generatedOutput = function (eventMessage) {\r\n    if (self.mute) return;\r\n    eventMessage.life = Math.ceil(noteDuration.value);\r\n    noteOnTracker.add(eventMessage);\r\n    self.output(eventMessage);\r\n  }\r\n\r\n  var headerBmp = 0;\r\n  var stepFunction = function () {\r\n    var active = patMem.size;\r\n    \r\n    if (active) {\r\n      \r\n      var selectedNumber=0;\r\n      \r\n      var avail=Array.from(patMem);\r\n      \r\n      if (probability.value<1)\r\n        if (Math.random() > probability.value){\r\n          headerBmp=0;\r\n          return;\r\n        }\r\n\r\n      selectedNumber=avail[Math.floor(Math.random()*avail.length)];\r\n      // console.log(avail);\r\n      // console.log(selectedNumber);\r\n\r\n      let outputMessage = baseEventMessage.clone();\r\n      outputMessage.value[1] = baseEventMessage.value[1] + selectedNumber;\r\n\r\n      generatedOutput(outputMessage);\r\n\r\n      self.handle('step', {\r\n        step: currentStep,\r\n        generated: selectedNumber\r\n      });\r\n\r\n      headerBmp=1<<selectedNumber;\r\n      currentStep++;\r\n    } else {\r\n      headerBmp = 0;\r\n    }\r\n  }\r\n  var activeNumbers = function () {\r\n    myBitmap=0;\r\n    patMem.forEach(function(index,value){\r\n      myBitmap|=1<<index;\r\n    });\r\n    self.handle('~bitmap', { bmp: myBitmap });\r\n    \r\n  }\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      var clockBase = evt.eventMessage.value[1];\r\n      var clockMicroStep = evt.eventMessage.value[2];\r\n      if ((clockMicroStep / stepDivision.value) % clockBase == 0) {\r\n        substep++;\r\n        if (substep >= stepDivision.value) {\r\n          substep = 0;\r\n          stepFunction();\r\n        }\r\n      }\r\n      noteOnTracker.each(function (noteOff, identifier) {\r\n        noteOff.life -= 1 / clockBase;\r\n        // console.log(\"LF\",noteOff.life);\r\n        if (noteOff.life <= 0) {\r\n          self.output(noteOnTracker.noteOff(identifier));\r\n        }\r\n      });\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      this.setStep(evt.eventMessage.value[1] % 16);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      this.clearStep(evt.eventMessage.value[1] % 16);\r\n    } else if (evt.eventMessage.value[0] == headers.changeRate) {\r\n      // console.log(\"CHANGERATEHEAER\",evt.eventMessage.value);\r\n      stepDivision.value = evt.eventMessage.value[2] / (evt.eventMessage.value[1] || 1);\r\n    } \r\n  }\r\n  this.getBitmaps16 = function () {\r\n    return {\r\n      steps: myBitmap,\r\n      header: headerBmp & myBitmap\r\n    };\r\n  }\r\n\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.each(function (noteOff, identifier) {\r\n  //     self.output(noteOff, false);\r\n  //   });\r\n  //   noteOnTracker.empty();\r\n  //   clearAll();\r\n  //   return true;\r\n  // }\r\n}\r\n\r\nNoise.color = [100, 80, 190];\r\nmodule.exports = Noise\n\n//# sourceURL=webpack://environment/./src/modules/Noise/index.js?");

/***/ }),

/***/ "./src/modules/NoteSustainer/InterfaceX16.js":
/*!***************************************************!*\
  !*** ./src/modules/NoteSustainer/InterfaceX16.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base=__webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\n\r\n//instance section\r\nmodule.exports = function(controlledModule) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      polyphony: controlledModule.polyphony,\r\n    }\r\n  });\r\n  configurators.global.vars.polyphony.changeFunction=function(thisVar,delta){\r\n    thisVar.value=parseInt(thisVar.value);\r\n    if(thisVar.value+delta>=0){\r\n      thisVar.value+=delta;\r\n      controlledModule.triggerPolyphonyChange();\r\n      passiveUpdateLeds();\r\n    }\r\n  }\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = 0;\r\n\r\n  var engagedHardwares = new Set();\r\n\r\n  var runningNotes=[];\r\n  function runningNotesChange(evMes){\r\n    runningNotes=controlledModule.getRunningNotes();\r\n    passiveUpdateLeds();\r\n  }\r\n  controlledModule.on('non',runningNotesChange);\r\n  controlledModule.on('noff',runningNotesChange);\r\n\r\n  function passiveUpdateLeds() {\r\n    if (!engagedConfigurator)\r\n      for (var hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  }\r\n\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      if(event.button<runningNotes.length){\r\n        controlledModule.killNote(runningNotes[event.button]);\r\n      }\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    if (engagedConfigurator) {} else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function(event) {};\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function(hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    var notesBmp=~(0xffff<<runningNotes.length)\r\n    var containerBmp=~(0xffff<<controlledModule.polyphony.value)\r\n    hardware.draw([containerBmp^notesBmp, containerBmp|notesBmp, containerBmp|notesBmp]);\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/NoteSustainer/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/NoteSustainer/index.js":
/*!********************************************!*\
  !*** ./src/modules/NoteSustainer/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/NoteSustainer/InterfaceX16.js\");\r\n\r\nvar headers = EventMessage.headers;\r\nvar CHANGEPOLYPHONYHEADER = headers.changeRate;\r\nvar KILLNOTESHEADER = headers.choke;\r\n\r\nvar testcount = 0;\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar NoteSustainer = function(properties) {\r\n\r\n  var thisInstance = this;\r\n  var myBitmap = 0;\r\n  var polyphony = this.polyphony={value:1};\r\n\r\n  let runningNotes = [];\r\n\r\n  this.getRunningNotes=function(){\r\n    return runningNotes;\r\n  }\r\n  this.baseName = \"Note sust\";\r\n\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n  this.interfaces.X16 =  InterfaceX16;\r\n\r\n  var recMessages={\r\n    kill:new EventMessage({value:[KILLNOTESHEADER,0,0]}),\r\n    polyphony:new EventMessage({value:[CHANGEPOLYPHONYHEADER,0,0]})\r\n  }\r\n  this.triggerPolyphonyChange=function(){\r\n    recMessages.polyphony.value[1]=polyphony.value;\r\n    self.recordOutput(recMessages.rate);\r\n    self.handle('~module',{polyphony:polyphony.value});\r\n    polyphonyConstrainCheck();\r\n  }\r\n\r\n  this.messageReceived = function(evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick && (evt.eventMessage.value[2] % evt.eventMessage.value[1] == 0)) {\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      addNote(evt.eventMessage.clone());\r\n      self.output(evt.eventMessage);\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n    } else if (evt.eventMessage.value[0] == CHANGEPOLYPHONYHEADER) {\r\n      polyphony.value=evt.eventMessage.value[1];\r\n    } else  if (evt.eventMessage.value[0] == KILLNOTESHEADER) {\r\n      killAllNotes();\r\n    }\r\n  }\r\n\r\n  this.onRemove = function() {\r\n    killAllNotes();\r\n    return true;\r\n  }\r\n\r\n  var killNote=this.killNote=function(note){\r\n    var shut=runningNotes.indexOf(note);\r\n    if(shut>-1){\r\n      shut=runningNotes.splice(shut,1)[0];\r\n      shut.value[0]=headers.triggerOff;\r\n      self.output(shut);\r\n      self.handle('noff',shut);\r\n      return shut;\r\n    }else{\r\n      console.warn(\"note kill requested, it was not in the runningNotes\",note);\r\n    }\r\n  }\r\n\r\n  function killOldestNote(){\r\n    var shut=runningNotes.shift();\r\n    if(shut){\r\n      shut.value[0]=headers.triggerOff;\r\n      self.output(shut);\r\n      self.handle('noff',shut);\r\n    }\r\n    return shut;\r\n  }\r\n  function killAllNotes(){\r\n    while(killOldestNote());\r\n  }\r\n  function polyphonyConstrainCheck(){\r\n    if(polyphony.value<0) polyphony.value=0;\r\n    while(runningNotes.length>polyphony.value){\r\n      // console.log(\"NOTEOFF\");\r\n      killOldestNote();\r\n    }\r\n  }\r\n  function addNote(eventMessage){\r\n    runningNotes.push(eventMessage);\r\n    self.handle('non',eventMessage);\r\n    polyphonyConstrainCheck();\r\n  }\r\n};\r\n\r\nNoteSustainer.color = [210, 0, 233];\r\nmodule.exports=NoteSustainer;\n\n//# sourceURL=webpack://environment/./src/modules/NoteSustainer/index.js?");

/***/ }),

/***/ "./src/modules/Operator/InterfaceX16.js":
/*!**********************************************!*\
  !*** ./src/modules/Operator/InterfaceX16.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n// var RecordMenu = require('../x28utils/RecordMenu.js');\r\n\r\nmodule.exports = function (controlledModule, environment) {\r\n  base.call(this);\r\n  var currentStep = 0;\r\n  var configurators = {};\r\n\r\n\r\n\r\n\r\n  var OpSetter = function (varn) {\r\n    var self = this;\r\n    this.value = 0;\r\n    this.op = 0;\r\n    var opChangeFunction = function (thisVar, delta) {\r\n      console.log(self.value);\r\n      self.op += delta;\r\n      if (self.op >= controlledModule.availOps) {\r\n        self.op = 0;\r\n      } else if (self.op < 0) {\r\n        self.op = controlledModule.availOps - 1;\r\n      }\r\n      controlledModule.opMap[varn] = self.op;\r\n      controlledModule.handle('~');\r\n    }\r\n    var valChangeFunction = function (thisVar, delta) {\r\n      console.log(self.value);\r\n      self.value += delta;\r\n      controlledModule.baseEventMessage.value[varn] = self.value;\r\n      controlledModule.handle('~');\r\n    }\r\n    var nameFunction = function (thisVar) {\r\n      if (!self.op) return \"nothing\"\r\n      return controlledModule.opNames[self.op] + \"\" + controlledModule.baseEventMessage.value[varn];\r\n    }\r\n    this.valu = function () {\r\n      return {\r\n        // value:0,\r\n        nameFunction: nameFunction,\r\n        changeFunction: valChangeFunction\r\n      }\r\n    }\r\n    this.operator = function () {\r\n      return {\r\n        // value:0,\r\n        nameFunction: nameFunction,\r\n        changeFunction: opChangeFunction\r\n      }\r\n    }\r\n  }\r\n  var opSetters = [\r\n    new OpSetter(0),\r\n    new OpSetter(1),\r\n    new OpSetter(2),\r\n    new OpSetter(3),\r\n  ];\r\n\r\n  configurators.ops = new BlankConfigurator(this, {\r\n    name: \"operate\",\r\n    vars: {\r\n      \"head 0\": opSetters[0].operator(),\r\n      \"n 1\": opSetters[1].operator(),\r\n      \"n 2\": opSetters[2].operator(),\r\n      \"n 3\": opSetters[3].operator(),\r\n      \"val head 0\": opSetters[0].valu(),\r\n      \"val n 1\": opSetters[1].valu(),\r\n      \"val n 2\": opSetters[2].valu(),\r\n      \"val n 3\": opSetters[3].valu(),\r\n    }\r\n  });\r\n\r\n  // configurators.record = new RecordMenu(this, {\r\n  //   environment: environment,\r\n  //   controlledModule: controlledModule\r\n  // });\r\n\r\n  var lastEngagedConfigurator = false;\r\n  var engagedConfigurator = false;\r\n\r\n\r\n  function hasEvent(button) {\r\n    return 0 != (controlledModule.getBitmap16() & (1 << button));\r\n  }\r\n  var engagedHardwares = new Set();\r\n  controlledModule.on('step', function (step) {\r\n    // console.log(\"STPP\");\r\n    currentStep = step;\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  });\r\n  this.matrixButtonPressed = function (event) {\r\n    \r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n  };\r\n\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      // if (event.data[0] == 1) {\r\n      //   engagedConfigurator = configurators.ops;\r\n      //   configurators.ops.engage(event);\r\n      // }else if (event.data[0] == 2) {\r\n      //   // engagedConfigurator = configurators.time;\r\n      //   // configurators.time.engage(event);\r\n      // }else if (event.button >= 8) {\r\n      //   // engagedConfigurator = configurators.record;\r\n      // }\r\n      // if(engagedConfigurator){\r\n      //   lastEngagedConfigurator = engagedConfigurator;\r\n      //   engagedConfigurator.engage(event);\r\n      // }\r\n\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    // if (engagedConfigurator) {\r\n    //   if (event.button == 1) {\r\n    //     engagedConfigurator.disengage(event);\r\n    //   }\r\n    //   engagedConfigurator=false;\r\n    // }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n    event.hardware.draw([0, 0, 0]);\r\n\r\n    engagedConfigurator = configurators.ops;\r\n    configurators.ops.engage(event);\r\n\r\n    // configurators.record.redraw(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateScreen = function (hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    // hardware.sendScreenB(\"n:\"+currentStep);\r\n  }\r\n  var updateLeds = function (hardware) {\r\n\r\n  }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Operator/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/Operator/index.js":
/*!***************************************!*\
  !*** ./src/modules/Operator/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\n\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/Operator/InterfaceX16.js\");\r\n\r\n/**\r\n@constructor ModuleSingleton\r\nsingleton, only one per run of the program\r\nevery module needs to run at the beginning of the runtime to register it's interactor in the interactionManager\r\n\r\n*/\r\nvar headers = EventMessage.headers;\r\nvar instancesCount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + instancesCount;\r\n  instancesCount++;\r\n}\r\n/**\r\n@constructor\r\nthe instance of the of the module, ment to be instantiated multiple times.\r\nrequire to moduleBase.call\r\n*/\r\nvar Operator = function (properties) {\r\n\r\n  //maybe the operator should allow layering of many operation layers, also adding timing operations\r\n\r\n  var self = this;\r\n  this.preventBus = true;\r\n  this.baseName = \"Operator\";\r\n\r\n  var baseEventMessage = this.baseEventMessage = new EventMessage({ value: [0, 0, 0, 0] });\r\n\r\n  let opMap = this.opMap = [0, 0, 0, 0];\r\n\r\n  testGetName.call(this);\r\n\r\n  if (properties.name) this.name = properties.name;\r\n\r\n  var noteOnTracker = new NoteOnTracker(this);\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n  this.ops = {\r\n    \"none\": function (signal) {\r\n      return signal;\r\n    },\r\n    \"=\": function (signal, value) {\r\n      return value\r\n    },\r\n    \"+\": function (signal, value) {\r\n      return signal + value\r\n    },\r\n    \"-\": function (signal, value) {\r\n      return signal - value\r\n    },\r\n    \"*\": function (signal, value) {\r\n      return signal * value;\r\n    },\r\n    \"%\": function (signal, value) {\r\n      return signal % value;\r\n    },\r\n    \"?\": function (signal, value) {\r\n      if (value == signal) return signal;\r\n      return false;\r\n    },\r\n    \"!\": function (signal, value) {\r\n      if (value != signal) return signal;\r\n      return false;\r\n    },\r\n    \"s<\": function (signal, value) {\r\n      if (value > signal) return signal;\r\n      return false;\r\n    },\r\n    \"s>\": function (signal, value) {\r\n      if (value < signal) return signal;\r\n      return false;\r\n    }\r\n  }\r\n  //make lookup arrays\r\n  this.opNames = [];\r\n  var opFns = this.opFns = [];\r\n  this.availOps = 0;\r\n  for (var n in this.ops) {\r\n    this.opNames.push(n);\r\n    this.opFns.push(this.ops[n]);\r\n    this.availOps++;\r\n  }\r\n\r\n  this.triggerOperationChange = function () {\r\n    // operationEventMessage.update();\r\n    // self.recordOutput(operationEventMessage);\r\n  }\r\n  this.triggerValueChange = function () {\r\n    // valuesEventMessage.update();\r\n    // self.recordOutput(valuesEventMessage);\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    var inEvt = evt.eventMessage;\r\n\r\n    if (inEvt.value[0] == headers.record) {\r\n      inEvt.value.shift();\r\n      for (var a in inEvt.value) {\r\n        baseEventMessage.value[a] = inEvt.value[a];\r\n      }\r\n    }\r\n  }\r\n  this.messageReceived = function (evt) {\r\n    var inEvt = evt.eventMessage;\r\n    var outEvt = inEvt.clone();\r\n    var cancelEvent = false;\r\n    if (inEvt.value[0] == headers.triggerOff) {\r\n      var noteTrackerKey = [inEvt.value[1], inEvt.value[2]];\r\n      // console.log(noteTrackerKey);\r\n      noteOnTracker.ifNoteOff(noteTrackerKey, function (noteOff) {\r\n        self.output(noteOff);\r\n        // console.log(\"NOFF\",noteOff.value);\r\n      });\r\n    }\r\n\r\n    for (var n in opMap) {\r\n      if (opMap[n]) {\r\n        var result = opFns[opMap[n]](inEvt.value[n], baseEventMessage.value[n]);\r\n        if (typeof result === \"boolean\") {\r\n          // console.log(\"CANCEL\",inEvt.value);\r\n          cancelEvent = true;\r\n        } else {\r\n          // console.log(\"PASS\",inEvt.value);\r\n\r\n          outEvt.value[n] = result;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!cancelEvent) {\r\n      if (inEvt.value[0] == headers.triggerOn) {\r\n        var noteTrackerKey = [inEvt.value[1], inEvt.value[2]];\r\n        noteOnTracker.add(outEvt, noteTrackerKey);\r\n      }\r\n      self.output(outEvt);\r\n    }\r\n\r\n  }\r\n  // this.onRemove = function () {\r\n  //   for (let a in opMap) {\r\n  //     opMap[a] = 0;\r\n  //   }\r\n  //   noteOnTracker.empty(function (noteOff) {\r\n  //     // console.log(\"NOFF\",noteOff.value);\r\n  //     self.output(noteOff);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n}\r\n\r\nOperator.color = [255, 0, 255];\r\nmodule.exports = Operator\n\n//# sourceURL=webpack://environment/./src/modules/Operator/index.js?");

/***/ }),

/***/ "./src/modules/OscTest/InterfaceX16.js":
/*!*********************************************!*\
  !*** ./src/modules/OscTest/InterfaceX16.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// \"use strict\";\r\n// var EventMessage = require('../../datatypes/EventMessage.js');\r\n// var BlankConfigurator = require('../x16utils/BlankConfigurator.js');\r\n// var base = require('../../interaction/x16basic/interactorBase.js');\r\n\r\n\r\n// var osc = require(\"osc\");\r\n\r\n\r\n// //instance section\r\n// module.exports = function (controlledModule) {\r\n//   base.call(this);\r\n\r\n\r\n\r\n\r\n//   var getIPAddresses = function () {\r\n//     var os = require(\"os\"),\r\n//       interfaces = os.networkInterfaces(),\r\n//       ipAddresses = [];\r\n\r\n//     for (var deviceName in interfaces) {\r\n//       var addresses = interfaces[deviceName];\r\n//       for (var i = 0; i < addresses.length; i++) {\r\n//         var addressInfo = addresses[i];\r\n//         if (addressInfo.family === \"IPv4\" && !addressInfo.internal) {\r\n//           ipAddresses.push(addressInfo.address);\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return ipAddresses;\r\n//   };\r\n\r\n//   var udpPort = new osc.UDPPort({\r\n//     localAddress: \"0.0.0.0\",\r\n//     localPort: 57121\r\n//   });\r\n\r\n//   udpPort.on(\"ready\", function () {\r\n//     var ipAddresses = getIPAddresses();\r\n\r\n//     console.log(\"Listening for OSC over UDP.\");\r\n//     ipAddresses.forEach(function (address) {\r\n//       console.log(\" Host:\", address + \", Port:\", udpPort.options.localPort);\r\n//     });\r\n//   });\r\n\r\n//   udpPort.on(\"message\", function (msg) {\r\n//     if (msg.address !== \"/hello\")\r\n//       udpPort.send({ address: \"/hello\", args: [0, 1, 2, 3] });\r\n//     console.log(msg);\r\n//   });\r\n\r\n//   udpPort.on(\"error\", function (err) {\r\n//     console.log(err);\r\n//   });\r\n\r\n//   udpPort.open();\r\n\r\n\r\n\r\n\r\n//   var configurators = {};\r\n//   configurators.global = new BlankConfigurator(this, {\r\n//     name: \"\",\r\n//     vars: {\r\n//       \"step length\": {value:controlledModule.clock.substeps},\r\n//     }\r\n//   });\r\n//   configurators.global.vars['step length'].changeFunction=function(thisVar, delta) {\r\n//     thisVar.value += delta;\r\n//     if (thisVar.value < -4) {\r\n//       thisVar.value -= delta;\r\n//     } else if (thisVar.value < 1) {\r\n//       controlledModule.clock.substeps = Math.pow(2, thisVar.value);//go by 12 divisible numbers: Math.floor( Math.pow(2,-1)/(1/12) )/12\r\n//     } else {\r\n//       controlledModule.clock.substeps = thisVar.value;\r\n//     }\r\n//   }\r\n//   configurators.global.vars['step length'].nameFunction = function (thisVar) {\r\n//     return \"to \" + controlledModule.clock.substeps;\r\n//   }\r\n//   var engagedConfigurator = false;\r\n//   var lastEngagedConfigurator = configurators.event;\r\n//   var stepsBmp = controlledModule.sequenceBitmap;\r\n\r\n//   var engagedHardwares = new Set();\r\n\r\n//   this.matrixButtonPressed = function (event) {\r\n//     if (engagedConfigurator) {\r\n//       engagedConfigurator.matrixButtonPressed(event);\r\n//     } else {\r\n//       stepsBmp.value^=1<<event.button;\r\n//       console.log(stepsBmp.value.toString(2));\r\n//       updateHardware(event.hardware);\r\n//     }\r\n//   };\r\n//   this.matrixButtonReleased = function (event) {\r\n//     if (engagedConfigurator) { } else {\r\n//       updateHardware(event.hardware);\r\n//     }\r\n//   };\r\n//   this.matrixButtonHold = function (event) { };\r\n//   this.selectorButtonPressed = function (event) {\r\n//     var hardware = event.hardware;\r\n//     if (engagedConfigurator) {\r\n//       engagedConfigurator.selectorButtonPressed(event);\r\n//     } else {\r\n//       if (event.data[0] == 2) {\r\n//         engagedConfigurator = configurators.global;\r\n//         configurators.global.engage(event);\r\n//       }\r\n//     }\r\n//   };\r\n//   this.selectorButtonReleased = function (event) {\r\n//     var hardware = event.hardware;\r\n//     if (event.data[0] == 2) {\r\n//       if (engagedConfigurator == configurators.global) {\r\n//         lastEngagedConfigurator = engagedConfigurator;\r\n//         engagedConfigurator.disengage(event);\r\n//         engagedConfigurator = false;\r\n//       }\r\n//     }\r\n//   };\r\n//   this.encoderScrolled = function (event) {\r\n//     if (engagedConfigurator) {\r\n//       engagedConfigurator.encoderScrolled(event);\r\n//     } else {\r\n//       if (lastEngagedConfigurator) {\r\n//         lastEngagedConfigurator.encoderScrolled(event)\r\n//       }\r\n//     }\r\n//   };\r\n//   this.encoderPressed = function (event) { };\r\n//   this.encoderReleased = function (event) { };\r\n//   this.engage = function (event) {\r\n//     engagedHardwares.add(event.hardware);\r\n//     updateHardware(event.hardware);\r\n//   };\r\n//   this.disengage = function (event) {\r\n//     engagedHardwares.delete(event.hardware);\r\n//   }\r\n//   var updateHardware = function (hardware) {\r\n//     hardware.sendScreenA(controlledModule.name);\r\n//     updateLeds(hardware);\r\n//   }\r\n//   var passiveUpdateLeds=function(){\r\n//     engagedHardwares.forEach(function (hardware) {\r\n//       updateLeds(hardware);\r\n//     })\r\n//   }\r\n//   controlledModule.on('step', passiveUpdateLeds);\r\n//   var animf=0;\r\n//   var updateLeds = function (hardware) {\r\n//     // stepsBmp = makeAnimationBitmap({x:2,y:2},animf);\r\n//     var playHeadBmp = 0x1111 << controlledModule.clock.step;\r\n//     hardware.draw([playHeadBmp, stepsBmp.value, stepsBmp.value]);\r\n//     animf++;\r\n//     if(animf>8) animf=0;\r\n//   }\r\n  \r\n\r\n\r\n// }\n\n//# sourceURL=webpack://environment/./src/modules/OscTest/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/OscTest/index.js":
/*!**************************************!*\
  !*** ./src/modules/OscTest/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/OscTest/InterfaceX16.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n @constructor\r\n the instance of the of the module, ment to be instantiated multiple times.\r\n require to moduleBase.call\r\n */\r\n\r\n\r\nvar RouteSequencer = function (properties) {\r\n  var thisInstance = this;\r\n  var myBitmap = 0;\r\n\r\n  var noteOnTracker = [];\r\n\r\n  var settings = this.settings = {\r\n    // feedback:{\r\n    //   value:0,\r\n    //   valueNames:['no','yes'],\r\n    // },\r\n  }\r\n  let clock = this.clock = {\r\n    substep: 0,\r\n    step: 0,\r\n    substeps: 1\r\n  }\r\n  let sequenceBitmap = this.sequenceBitmap = {\r\n    value: properties.bitmap || 0\r\n  }\r\n\r\n  this.baseName = \"RouteSequencer\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n\r\n  var memory = new Set();\r\n  var recMessages = {\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] })\r\n  }\r\n  this.recordRate = function () {\r\n    recMessages.rate.value[2] = settings.delayMicro.value;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      var event = evt.eventMessage;\r\n      event.value.shift();\r\n      memory.add(event);\r\n    }\r\n    //backpropagate rec messages\r\n  }\r\n\r\n  var outputs = self.getOutputs();\r\n  var updateOutputs = function () {\r\n    outputs = self.getOutputs();\r\n  }\r\n  //this module has a special case where output function is redefined\r\n  this.output = function (eventMessage, overrideMute, properties={}) {\r\n    updateOutputs();\r\n    if ((!self.mute) || overrideMute) {\r\n      self.enqueue(function () {\r\n        var chan = 0;\r\n        if (properties.destination) {\r\n          if (self.outputs.has(properties.destination)) {\r\n            properties.destination.messageReceived({ eventMessage: eventMessage.clone(), origin: self });\r\n          }\r\n        } else {\r\n          outputs.forEach(function (tModule) {\r\n            if (sequenceBitmap.value & (1 << (clock.step + chan * 4))) {\r\n              tModule.messageReceived({ eventMessage: eventMessage.clone(), origin: self });\r\n              self.handle('>message', { origin: self, destination: tModule, val: eventMessage, eventMessage: eventMessage });\r\n            }\r\n            chan++;\r\n            chan %= 4;\r\n          })\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  this.on(\">message\", function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.triggerOn) {\r\n      noteOnTracker[evt.eventMessage.value[1]] = evt;\r\n    }\r\n  });\r\n\r\n  var stepFunction = function () {\r\n    clock.step++;\r\n    clock.step %= 4;\r\n    self.handle('step');\r\n  }\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      var clockBase = evt.eventMessage.value[1];\r\n      var clockMicroStep = evt.eventMessage.value[2];\r\n      if ((clockMicroStep / clock.substeps) % clockBase == 0) {\r\n\r\n        clock.substep++;\r\n\r\n        // console.log(\"T\",clock);\r\n        if (clock.substep >= clock.substeps) {\r\n\r\n          clock.substep = 0;\r\n          stepFunction();\r\n        }\r\n      }\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      var tracked = noteOnTracker[evt.eventMessage.value[1]];\r\n      if (tracked)\r\n          self.output(evt.eventMessage, false, tracked);\r\n    } else {\r\n\r\n      self.output(evt.eventMessage);\r\n    }\r\n  }\r\n\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noff) {\r\n  //     thisInstance.output(noff, true);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n\r\n  this.handleStepsChange = function () {\r\n    self.handle('~module', { steps: runningNotes.length });\r\n  }\r\n\r\n};\r\n\r\nRouteSequencer.color = [125, 0, 233];\r\nmodule.exports = RouteSequencer;\n\n//# sourceURL=webpack://environment/./src/modules/OscTest/index.js?");

/***/ }),

/***/ "./src/modules/PianoRoll/InterfaceX28.js":
/*!***********************************************!*\
  !*** ./src/modules/PianoRoll/InterfaceX28.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\n// var headers = EventMessage.headers;\r\n\r\nvar UARROW=String.fromCharCode(197);\r\nvar DARROW=String.fromCharCode(198);\r\nvar RARROW=String.fromCharCode(199);\r\nvar LARROW=String.fromCharCode(200);\r\n\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\n\r\nmodule.exports = function(controlledModule,environment) {\r\n  base.call(this);\r\n  var self=this;\r\n  var configurators = {};\r\n  var shiftMode=false;\r\n\r\n  var sequenceView=new controlledModule.memory.View();\r\n\r\n  function getContextFilter(){\r\n    if(shiftMode){\r\n      return [0]\r\n    }else{\r\n      return [0,1,2]\r\n    }\r\n  }\r\n  configurators.event = new EventConfigurator(this, {\r\n    // baseEvent: new EventMessage({ value: [headers.triggerOn,0,-1,-1]})\r\n    preset:1\r\n  });\r\n\r\n\r\n  var memPlayHead = controlledModule.memory.getPlayhead();\r\n  configurators.time = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"loop start\": {\r\n        value: memPlayHead.start,\r\n        changeFunction(thisvar,delta){\r\n          thisvar.value = memPlayHead.start;\r\n          thisvar.value+=delta;\r\n          if(thisvar.value<0) thisvar.value=0;\r\n          controlledModule.memory.setLoopDisplacement(thisvar.value);\r\n          redrawSequenceOnNextUpdate=true;\r\n        },\r\n       },\r\n      \"loop len\": {\r\n        value: memPlayHead.end,\r\n        changeFunction(thisvar,delta){\r\n          thisvar.value = memPlayHead.end-memPlayHead.start;\r\n          thisvar.value += delta;\r\n          if (thisvar.value < 1) thisvar.value = 1;\r\n          controlledModule.memory.setLoopLength(thisvar.value);\r\n          redrawSequenceOnNextUpdate = true;\r\n        }\r\n      },\r\n      \"shift playhead\":{\r\n        value:0,\r\n        changeFunction(thisvar,delta){\r\n          var clock=controlledModule.clock;\r\n          if(!shiftMode) delta*=clock.microSteps;\r\n          thisvar.value+=delta;\r\n          controlledModule.memory.jog(delta / clock.microSteps);\r\n        },\r\n        nameFunction(thisVar) {\r\n          let micros = controlledModule.clock.microSteps;\r\n          if (shiftMode) {\r\n            return thisVar.value + \"/\" + micros +\" steps\";\r\n          } else {\r\n            return \"\" + DARROW +\" micro \"+thisVar.value / 12 + \" steps\";\r\n          }\r\n        }\r\n      },\r\n      \"quantize\": {\r\n        value: controlledModule.quantize.portions,\r\n        changeFunction(thisVar,delta){\r\n          thisVar.value+=delta;\r\n          if(thisVar.value)\r\n            while(\r\n              controlledModule.clock.microSteps/thisVar.value\r\n              !== Math.floor(controlledModule.clock.microSteps/thisVar.value)\r\n            ){\r\n              thisVar.value++;\r\n            }\r\n          if(thisVar.value<0) thisVar.value=controlledModule.clock.microSteps-1;\r\n          thisVar.value%=controlledModule.clock.microSteps;\r\n          controlledModule.quantize.portions=thisVar.value;\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  var engagedConfigurator=false;\r\n  var semiEngagedConfigurator=false;\r\n  var stepOnScreen=0;\r\n  var engagedHardwares = new Set();\r\n  var redrawSequenceOnNextUpdate=false;\r\n\r\n  function buttonHasEvent(button) {\r\n    if (!listOfEventsInView[button]) return false;\r\n    return listOfEventsInView[button].length;\r\n  }\r\n\r\n  controlledModule.memory.on('step', function(clock) {\r\n    stepOnScreen = clock.step-clock.start;\r\n    // console.log(\"step\",stepOnScreen);\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  });\r\n\r\n  this.matrixButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      var bhe = buttonHasEvent(event.button);\r\n      var thereWasEvent=false;\r\n      if (bhe > 0){\r\n        var listOfEventsInButton = listOfEventsInView[event.button];\r\n        // console.log(listOfEventsInView);\r\n        //Potentially show a list of all the events in the step?\r\n        if (shiftMode) {\r\n          var rmev = listOfEventsInButton[listOfEventsInButton.length - 1];\r\n          configurators.event.setFromEventMessage(rmev);\r\n          controlledModule.memory.removeEvent(rmev, event.button);\r\n          thereWasEvent = true;\r\n        } else {\r\n          for (var evm of listOfEventsInButton){\r\n            if (evm.compareValuesTo(configurators.event.getEventMessage(), getContextFilter())){\r\n              controlledModule.memory.removeEvent(evm, event.button);\r\n              thereWasEvent=true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if(!thereWasEvent){\r\n        controlledModule.memory.addEvent(configurators.event.getEventMessage(),event.button+memPlayHead.start);\r\n      }\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    if (engagedConfigurator) {} else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else if (event.data[0] == 0) {\r\n      shiftMode=true;\r\n      redrawSequenceOnNextUpdate=true;\r\n    } else if (event.data[0] == 1) {\r\n      engagedConfigurator = configurators.event;\r\n    } else if (event.data[0] == 2) {\r\n      engagedConfigurator = configurators.time;\r\n    }else if (event.button >= 8) {\r\n      engagedConfigurator = configurators.record;\r\n    }\r\n    if(!shiftMode){\r\n      if(engagedConfigurator) engagedConfigurator.engage(event);\r\n      semiEngagedConfigurator = engagedConfigurator;\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 0) {\r\n      shiftMode = false;\r\n      redrawSequenceOnNextUpdate = true;\r\n    } else if (engagedConfigurator){\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator = false;\r\n      updateHardware(hardware);\r\n    }\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    if(semiEngagedConfigurator==configurators.event){\r\n      redrawSequenceOnNextUpdate=true;\r\n    }\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (semiEngagedConfigurator) {\r\n        semiEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function(event) {};\r\n  this.encoderReleased = function(event) {};\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function(hardware) {\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  }\r\n  var updateScreen = function(hardware) {\r\n    hardware.sendScreenA(controlledModule.name);\r\n    // hardware.sendScreenB(\"n:\"+currentStep);\r\n  }\r\n  var sequenceBitmap = 0;\r\n  var focusSequenceBitmap=0;\r\n  var listOfEventsInView={};\r\n  var updateSequence=function(){\r\n    memPlayHead=controlledModule.memory.getPlayhead();\r\n\r\n    // var playhead=sequenceView.getPlayhead();\r\n\r\n    var firstStep=memPlayHead.start;\r\n    var lastStep=memPlayHead.end;\r\n\r\n    listOfEventsInView = controlledModule.memory.getStepRange(firstStep, lastStep+firstStep);\r\n\r\n    var offsetView=firstStep;\r\n    var quantizeView=1;\r\n\r\n    var relist = {};\r\n\r\n    for (var stindex in listOfEventsInView) {\r\n      var viewIndex = Math.floor(stindex * quantizeView) / quantizeView;\r\n      // viewIndex-=offsetView;\r\n      if (!relist[viewIndex]) relist[viewIndex] = [];\r\n      if (!isNaN(viewIndex)) {\r\n        relist[viewIndex] = relist[viewIndex].concat(listOfEventsInView[stindex]);\r\n      }\r\n    }\r\n\r\n    listOfEventsInView = relist;\r\n    // console.log(listOfEventsInView);\r\n\r\n    let list = listOfEventsInView;\r\n    let currentEventMessage=configurators.event.getEventMessage();\r\n    var baseBmp = 0;\r\n    var fBmp=0;\r\n    for(var step in list){\r\n      var viewStep = step;\r\n      if(buttonHasEvent(step))  baseBmp|=1<<viewStep;\r\n      for(var evt of list[step]){\r\n        if (evt.compareValuesTo){\r\n          if (evt.compareValuesTo(currentEventMessage, getContextFilter())){\r\n            fBmp |= 1 << viewStep;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    sequenceBitmap=baseBmp;\r\n    focusSequenceBitmap=fBmp;\r\n    redrawSequenceOnNextUpdate=false;\r\n  }\r\n\r\n  controlledModule.memory.on('changed', function (evt) {\r\n    redrawSequenceOnNextUpdate=true\r\n    if(evt.added){\r\n      if(evt.added.length) configurators.event.setFromEventMessage(evt.added[evt.added.length-1]);\r\n    }\r\n  });\r\n  var updateLeds = function(hardware) {\r\n\r\n    if (redrawSequenceOnNextUpdate){\r\n      updateSequence();\r\n    }\r\n    var playheadBitmap=0;\r\n    // console.log(self.name,\"redraw\");\r\n    if(stepOnScreen >= 0 && stepOnScreen < 16){\r\n      playheadBitmap = 1 << stepOnScreen;\r\n    }\r\n    hardware.draw([0, focusSequenceBitmap, focusSequenceBitmap| sequenceBitmap]);\r\n    //TODO: fix blinking on the hardware\r\n    // hardware.clear();\r\n    // hardware.drawColor(sequenceBitmap, [0, 0, 127],true);\r\n    // hardware.drawColor(focusSequenceBitmap, [64, 127, 200]);\r\n    hardware.drawColor(playheadBitmap, [255,255,255]);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/PianoRoll/InterfaceX28.js?");

/***/ }),

/***/ "./src/modules/PianoRoll/TapeMem.js":
/*!******************************************!*\
  !*** ./src/modules/PianoRoll/TapeMem.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar Observable = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nvar headers = EventMessage.headers;\r\n\r\nvar TapeMem = function (props = {}) {\r\n    Observable.call(this);\r\n    var self = this;\r\n    var lastFrame = 0;\r\n    //resolution\r\n    var framesPerStep = 96;\r\n    var memory = {};\r\n    var upcomingFrame = 0;\r\n    var loopLength = 0;\r\n    var loopStart = 0;\r\n    var loopEnd = 0;\r\n    var notesOn = new Set();\r\n\r\n    // var loopLastFrame=0;\r\n    function stepToFrame(step) {\r\n        return Math.round(step * framesPerStep);\r\n    }\r\n    function frameToStep(frame) {\r\n        return frame / framesPerStep;\r\n    }\r\n\r\n\r\n    this.jog = function (stepJog) {\r\n      var frameIncrement = stepToFrame(stepJog);\r\n      upcomingFrame = upcomingFrame + frameIncrement;\r\n      // console.log(\"JOG\",stepJog,prevFrame,upcomingFrame,frameToStep(upcomingFrame-prevFrame));\r\n    }\r\n    this.jumpToStep=function(step){\r\n      var frameStep=stepToFrame(step);\r\n      upcomingFrame=frameStep;\r\n    }\r\n\r\n    this.quantizePlayheadPosition = function (roundfn = function (val) { return Math.round(val) }) {\r\n        var prev = upcomingFrame;\r\n        upcomingFrame = frameToStep( roundfn(stepToFrame(upcomingFrame)) );\r\n        // console.log(\"QPP\", prev - upcomingFrame);\r\n    }\r\n\r\n\r\n    //stepIncrement should come as a float, it will be quantized back to array index using framesPerStep\r\n    //it represents steps to advance, and portions of it.\r\n    // var teststep=0;\r\n    this.tapeFrame = function (stepIncrement) {\r\n        var frameIncrement = stepToFrame(stepIncrement);\r\n\r\n\r\n        // console.log(stepIncrement%frameIncrement);\r\n        upcomingFrame = upcomingFrame + frameIncrement;\r\n\r\n\r\n        //TODO: this is important: if the current frame reaches the loop end, it needs to add to the current step whichever amount of steps were left over from the end of the loops\r\n        if (upcomingFrame >= loopEnd) upcomingFrame = loopStart;\r\n\r\n        if (upcomingFrame % framesPerStep == 0 || lastFrame > upcomingFrame) {\r\n            self.handle(\"step\", self.getPlayhead());\r\n        }\r\n        //scan all memory from last frame to current frame and trigger all those events.\r\n        //...\r\n        var eventsInRange = [];\r\n        var framesInRange = self.getFrameRange(lastFrame, upcomingFrame - 1);\r\n        for (var frevli in framesInRange) {\r\n            var frevl = framesInRange[frevli];\r\n            eventsInRange = eventsInRange.concat(frevl);\r\n        }\r\n        eventsInRange.map(function (evt) {\r\n            if (evt.value[0] == headers.triggerOn) {\r\n                notesOn.add(evt);\r\n                if (!evt.duration) {\r\n                    console.warn(\"note on without duration in tape:\", evt);\r\n                    evt.duration = framesPerStep;\r\n                }\r\n            }\r\n        });\r\n        notesOn.forEach(function (note) {\r\n            if (!note.life) note.life = note.duration;\r\n            note.life -= frameIncrement;\r\n\r\n            if (note.life <= 0) {\r\n                var noff = note.clone();\r\n                noff.value[0] = headers.triggerOff;\r\n                eventsInRange.push(noff)\r\n                notesOn.delete(note);\r\n            };\r\n        });\r\n\r\n        lastFrame = upcomingFrame;\r\n\r\n        self.eventTriggerFunction(eventsInRange);\r\n        // console.log(\"upcomingFrame\",stepToFrame(stepIncrement),upcomingFrame);\r\n    }\r\n    this.getPlayhead = function () {\r\n        return { frame: lastFrame, step: frameToStep(lastFrame), start: frameToStep(loopStart), end: frameToStep(loopEnd) }\r\n    }\r\n    this.setLoopPoints = function (start, end) {\r\n        if (start) loopStart = stepToFrame(start);\r\n        if (end) loopEnd = stepToFrame(end);\r\n        // loopLastFrame=loopEnd-1;\r\n        loopLength = loopEnd - loopStart;\r\n    }\r\n    this.setLoopLength = function (to) {\r\n        loopEnd = loopStart + stepToFrame(to);\r\n        // loopLastFrame=loopEnd-1;\r\n        loopLength = loopEnd - loopStart;\r\n    }\r\n    this.setLoopDisplacement = function (start) {\r\n        loopStart = stepToFrame(start);\r\n        loopEnd = loopStart + loopLength;\r\n    }\r\n    this.eventTriggerFunction = function (eventsList) {\r\n    }\r\n    var noteOnRecordTracker = {};\r\n    this.recordEvent = function (event) {\r\n        var eventFrame = upcomingFrame;\r\n        //prevent more than one same event in the same spot..\r\n        for (var n in memory[eventFrame]) {\r\n            if (memory[eventFrame][n].compareValuesTo(event, [0, 1, 2, 3])) {\r\n                console.log(\"duplicate prevented\");\r\n                return;\r\n            }\r\n        }\r\n        //manage noteon and offs\r\n        if (event.value[0] == headers.triggerOn) {\r\n            noteOnRecordTracker[event.value[1], event.value[2]] = event;\r\n            event.started = upcomingFrame;\r\n            return;\r\n        } else if (event.value[0] = headers.triggerOff) {\r\n            event = noteOnRecordTracker[event.value[1], event.value[2]];\r\n            if (!event) return;\r\n            if (event.started !== undefined) {\r\n                var countFrame = upcomingFrame;\r\n                //wraparound loop\r\n                while (countFrame < event.started) {\r\n                    countFrame += Math.abs(loopLength);\r\n                }\r\n                event.duration = countFrame - event.started\r\n                console.log(\"event duration\", Math.round(frameToStep(event.duration)));\r\n\r\n                eventFrame = event.started;\r\n            }\r\n            delete noteOnRecordTracker[event.value[1], event.value[2]];\r\n        }\r\n        if (!memory[eventFrame]) memory[eventFrame] = [];\r\n        // console.log(\"REC\",eventFrame,event.value,event.duration)\r\n        memory[eventFrame].push(event);\r\n        self.handle('changed', { added: [event] });\r\n        return event;\r\n    }\r\n    this.addEvent = function (event, step) {\r\n        var frame = stepToFrame(step);\r\n        if (!memory[frame]) memory[frame] = [];\r\n        memory[frame].push(event);\r\n        self.handle('changed', { added: [event] });\r\n        return event;\r\n    }\r\n    this.removeEvent = function (event) {\r\n        for (var frame in memory) {\r\n            var memfr = memory[frame];\r\n            var eventLoc = memfr.indexOf(event);\r\n            if (eventLoc !== -1) {\r\n                foundEvent = memfr.splice(eventLoc, 1);\r\n            }\r\n        }\r\n        self.handle('changed', { removed: [event] });\r\n    }\r\n    this.clearStepRange = function (start, end) {\r\n        var firstFrame = stepToFrame(start);\r\n        var lastFrame = stepToFrame(end);\r\n        var removed = [];\r\n        for (var index in memory) {\r\n            if (index > firstFrame && index < lastFrame) {\r\n                removed = removed.concat(memory[index]);\r\n                delete memory[index];\r\n            }\r\n        }\r\n        self.handle('changed', { removed: removed });\r\n    }\r\n    this.clearStep = function (step) {\r\n        self.clearStepRange(step, step + 1);\r\n    }\r\n\r\n    //TODO: create a tape view object, which defines view start and end, and addresses all modification/ request functions in accordnce to view's position & zoom.\r\n    //this would also be good for multi-controller sequencing\r\n    //these functions return relative event positions!\r\n    this.getStepRange = function (start, end) {\r\n        var frameStart = stepToFrame(start);\r\n        var frameEnd = stepToFrame(end);\r\n        var ret = self.getFrameRange(frameStart, frameEnd - 1);\r\n\r\n        return ret;\r\n    }\r\n    this.getFrameRange = function (frameStart, frameEnd) {\r\n        var ret = {}\r\n        while (frameStart >= frameEnd) {\r\n            loopLength = loopEnd - loopStart;\r\n            if (loopLength < 1) {\r\n                console.error(\"negative loop length\");\r\n                return;\r\n            }\r\n            // console.log(\"wraparound\");\r\n            frameEnd += loopLength;\r\n        }\r\n        for (var index in memory) {\r\n            if (index >= frameStart && index <= frameEnd) {\r\n                var thisStep = frameToStep(index);\r\n                var thisRelativeStep = thisStep - frameToStep(frameStart);\r\n                ret[thisRelativeStep] = memory[index];\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    this.View = function () {\r\n        var start = 0;\r\n        var end = 0;\r\n        var cursor = 0;\r\n        this.properties = function () {\r\n            return {\r\n                cursorFrame: cursor,\r\n                cursor: frameToStep(cursor),\r\n                start: frameToStep(start),\r\n                end: frameToStep(end)\r\n            }\r\n        }\r\n        this.set = function (to) {\r\n            if (to.cursor !== undefined) {\r\n                cursor = stepToFrame(to.cursor);\r\n            }\r\n            if (to.cursorFrame !== undefined) {\r\n                cursor = to.upcomingFrame;\r\n            }\r\n            if (to.start !== undefined) {\r\n                start = stepToFrame(to.start);\r\n            }\r\n            if (to.end !== undefined) {\r\n                end = stepToFrame(to.end);\r\n            }\r\n        }\r\n        this.setLoopPoints = function (start, end) {\r\n            if (start) loopStart = stepToFrame(start);\r\n            if (end) loopEnd = stepToFrame(end);\r\n            // loopLastFrame=loopEnd-1;\r\n            loopLength = loopEnd - loopStart;\r\n        }\r\n        this.setLoopLength = function (to) {\r\n            loopEnd = loopStart + stepToFrame(to);\r\n            // loopLastFrame=loopEnd-1;\r\n            loopLength = loopEnd - loopStart;\r\n        }\r\n        this.setLoopDisplacement = function (start) {\r\n            loopStart = stepToFrame(start);\r\n            loopEnd = loopStart + loopLength;\r\n        }\r\n    }\r\n}\r\nmodule.exports = TapeMem;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/PianoRoll/TapeMem.js?");

/***/ }),

/***/ "./src/modules/PianoRoll/index.js":
/*!****************************************!*\
  !*** ./src/modules/PianoRoll/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX28 = __webpack_require__(/*! ./InterfaceX28 */ \"./src/modules/PianoRoll/InterfaceX28.js\");\r\nvar TapeMem=__webpack_require__(/*! ./TapeMem.js */ \"./src/modules/PianoRoll/TapeMem.js\");\r\nvar headers = EventMessage.headers;\r\n\r\nvar instancesCount = 0;\r\nvar testGetName = function() {\r\n  this.name = this.baseName + \" \" + instancesCount;\r\n  instancesCount++;\r\n}\r\nvar PianoRoll = function(properties,environment) {\r\n  var self = this;\r\n\r\n  var noteOnTracker = new Set();\r\n  var noteLengthTracker=new(function(){\r\n    this.tracker=[];\r\n    this.add=function(what){\r\n      what.started=clock.step\r\n      this.tracker[what.value[1], what.value[2]]=what;\r\n    }\r\n    this.get=function(num1,num2){\r\n\r\n    }\r\n  })();\r\n  this.memory=new TapeMem();\r\n  this.memory.setLoopPoints(0,16);\r\n  var memory=this.memory;\r\n\r\n\r\n\r\n  this.clock={\r\n    rate:1,\r\n    playHead:0,\r\n    microStep:0,\r\n    microSteps:12\r\n  }\r\n  var quantize=this.quantize={\r\n    portions:0,\r\n    offset:0,\r\n  };\r\n\r\n  var clock=this.clock;\r\n\r\n  this.baseName = \"PianoRoll\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n\r\n  //defined as x16 because it probably is compatible\r\n  this.interfaces.X16 = InterfaceX28;\r\n  // this.interfaces.Http = InterfaceHttp;\r\n\r\n  function ramp(t, range) {\r\n    if (t > 0) {\r\n      return t % range;\r\n    } else {\r\n      return range - Math.abs(t % range);\r\n    }\r\n  }\r\n\r\n  var rec={}\r\n  memory.on('step',function(a){\r\n    self.clock.playHead=Math.floor(a.playHead);\r\n    self.clock.microStep=(a.playHead * a.microSteps);\r\n    if(rec.status){\r\n      // console.log(\"REC\",a);\r\n      rec.duration++;\r\n    }\r\n  });\r\n\r\n\r\n  this.recordingReceived=function(evt){\r\n    var message=evt.eventMessage;\r\n    if (message.value[0] == headers.record) {\r\n      message.value.shift();\r\n      self.memory.recordEvent(message);\r\n    } else if (message.value[0]==headers.recordStatus){\r\n      rec.status = message.value[1];\r\n      if(rec.status){\r\n        rec.duration=0;\r\n        rec.started=memory.getPlayhead();\r\n      }else{\r\n        // console.log(\"recording ended:\",rec);\r\n      }\r\n    }\r\n  }\r\n\r\n  this.messageReceived = function(evt) {\r\n    var eventMessage=evt.eventMessage;\r\n    if (eventMessage.value[0] == headers.clockTick) {\r\n      clock.microSteps=eventMessage.value[1];\r\n      var microStep=eventMessage.value[2];\r\n      self.handle('microstep',clock);\r\n      if(quantize.portions){\r\n        if((microStep + quantize.offset) % (clock.microSteps/quantize.portions) == 0)\r\n          self.memory.tapeFrame(1/quantize.portions);\r\n      }else{\r\n        //TODO: get delta of microstep and that is the added microstep to memoryframe\r\n        //just in case a clock skips a micro.\r\n        self.memory.tapeFrame(1/clock.microSteps);\r\n      }\r\n\r\n    } else if (eventMessage.value[0] == headers.triggerOn) {\r\n      console.log(\"jump\",eventMessage.value[1],eventMessage.value[2]/clock.microSteps);\r\n      self.memory.jumpToStep(eventMessage.value[1]+eventMessage.value[2]/clock.microSteps);\r\n    } else if (eventMessage.value[0] == headers.triggerOff) {\r\n    } else if (eventMessage.value[0] == headers.changeRate) {\r\n    } else if (eventMessage.value[0] == headers.triggerOff + 1) {\r\n    }\r\n  }\r\n\r\n  self.memory.eventTriggerFunction=function(triggeredEventsList){\r\n    var duPrevent={};\r\n    for(var evtn in triggeredEventsList){\r\n      var evt=triggeredEventsList[evtn];\r\n      if (duPrevent[evt.value.slice(0,3).join(\"-\")]){\r\n        // console.log(duPrevent);\r\n      }else{\r\n        duPrevent[evt.value.slice(0,3).join(\"-\")] = true;\r\n        // console.log(evt);\r\n        self.output(evt);\r\n        noteOnTracker.add(evt);\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nPianoRoll.color = [50, 50, 120];\r\nmodule.exports = PianoRoll\r\n\n\n//# sourceURL=webpack://environment/./src/modules/PianoRoll/index.js?");

/***/ }),

/***/ "./src/modules/PresetKit/InterfaceHttp.js":
/*!************************************************!*\
  !*** ./src/modules/PresetKit/InterfaceHttp.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Observable = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nmodule.exports = function (controlledModule, environment) {\r\n    var self = this;\r\n    Observable.call(this);\r\n    var baseEngage = this.engage;\r\n    this.engage = function (callback) {\r\n        baseEngage(callback);\r\n        controlledModule.on('bitmap-triggered', function (evt) {\r\n            callback({\r\n                type: \"~module\",\r\n                origin: controlledModule,\r\n                bitmap: evt.bitmap\r\n            });\r\n\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/PresetKit/InterfaceHttp.js?");

/***/ }),

/***/ "./src/modules/PresetKit/InterfaceX16.js":
/*!***********************************************!*\
  !*** ./src/modules/PresetKit/InterfaceX16.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar RecordMenu = __webpack_require__(/*! ../x28utils/RecordMenu.js */ \"./src/modules/x28utils/RecordMenu.js\");\r\n\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\nvar SQUARE = String.fromCharCode(252);\r\n\r\n\r\n\r\n/**\r\ndefinition of a presetkit interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function(controlledModule, environment) {\r\n  base.call(this);\r\n  var engagedHardwares = new Set();\r\n  var self=this;\r\n  var engagedConfigurator = false;\r\n  var configurators = this.configurators = {};\r\n  var muteBmp = 0;\r\n  var muteMode = false;\r\n  var muteAction = function(button) {\r\n    var muted = controlledModule.togglePresetMute(button);\r\n    (muted ? muteBmp |= 1 << button : muteBmp &= ~(1 << button));\r\n  }\r\n  configurators.event = new EventConfigurator(this);\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  });\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"auto map\": {\r\n        value: 0,\r\n        list: [false, 1, 2, 3]\r\n      },\"use velocity\": {\r\n        value: false,\r\n      }\r\n    }\r\n  });\r\n  var usingVelocity=configurators.global.vars[\"use velocity\"];\r\n  var pauseUi=false;\r\n  configurators.global.vars[\"auto map\"].selectFunction = function(thisVar) {\r\n    thisVar.value=thisVar.list.indexOf(controlledModule.autoMap);\r\n  };\r\n  configurators.global.vars[\"auto map\"].changeFunction = function(thisVar, delta) {\r\n    // if(isNaN(thisVar.value)) thisVar.value=0;\r\n    thisVar.value += delta;\r\n    thisVar.value %= thisVar.list.length;\r\n    controlledModule.autoMap = thisVar.list[thisVar.value];\r\n  };\r\n\r\n  configurators.global.vars[\"auto map\"].nameFunction = function(thisVar) {\r\n    if(controlledModule.kit[0].value[0]==EventMessage.headers.triggerOn){\r\n      switch (thisVar.value) {\r\n        case 0:\r\n          return \"off\";\r\n        case 1:\r\n          return \"1 (note)\";\r\n        case 2:\r\n          return \"2 (timbre)\";\r\n        case 3:\r\n          return \"3 (velo)\";\r\n        default: console.log(\"invalid var:\",thisVar); return \"?\";\r\n      }\r\n    }else{\r\n      switch (thisVar.value) {\r\n        case 0:\r\n          return \"off\";\r\n        case 1:\r\n          return num+thisVar.value;\r\n        default: console.log(\"invalid var:\", thisVar); return \"?\";\r\n      }\r\n    }\r\n  };\r\n\r\n  var muteMode = false;\r\n\r\n  var lastEngagedConfigurator = configurators.event;\r\n\r\n  var availablePresetsBitmap = 0;\r\n  var highlightedBitmap = 0;\r\n  var selectedPresetNumbers = [];\r\n\r\n  function eachSelectedPresetNumber(cb) {\r\n    selectedPresetNumbers.map(cb);\r\n  }\r\n\r\n  function lastSelectedPresetNumber(cb) {\r\n    cb(selectedPresetNumbers[selectedPresetNumbers.length - 1], selectedPresetNumbers.length - 1);\r\n  }\r\n  controlledModule.on('extrigger', function(event) {\r\n    highlightedBitmap |= 1 << event.preset;\r\n    controlledModule.handle('bitmap-triggered',{bitmap:highlightedBitmap});\r\n    setTimeout(function() {\r\n      var num = event.preset;\r\n      highlightedBitmap &= ~(1 << num);\r\n      controlledModule.handle('bitmap-triggered',{bitmap:highlightedBitmap});\r\n\r\n    }, 500);\r\n  });\r\n\r\n  setInterval(function() {\r\n    passiveUpdateLeds();\r\n  }, 1000 / 20);\r\n\r\n  controlledModule.on('kitchanged', function() {\r\n    updateAvailablePresetsBitmap();\r\n  });\r\n  var lastTriggeredVelocity\r\n  this.matrixButtonVelocity = function(event) {\r\n    //the if prevents retrigger the first time\r\n    lastTriggeredVelocity=Math.floor(event.data[1]/2 - 1) ;\r\n    if(usingVelocity.value && !engagedConfigurator){\r\n      // console.log(event);\r\n      controlledModule.uiTriggerOn(event.data[0],Math.floor(event.data[1]/2 - 1) );\r\n      pauseUi=false;\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  var pressedMatrixButtons=new Set();\r\n\r\n  this.matrixButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (muteMode) {\r\n      muteAction(event.button);\r\n      updateLeds(hardware);\r\n    } else if (engagedConfigurator) {\r\n      var eventResponse=engagedConfigurator.matrixButtonPressed(event);\r\n      if (engagedConfigurator == configurators.util) {\r\n        updateLeds(hardware);\r\n      } else {\r\n        // engagedConfigurator.matrixButtonPressed(event);\r\n      }\r\n      if(eventResponse)if(eventResponse.presetSelected){\r\n        if(controlledModule.autoMap!==false){\r\n          controlledModule.kit[0] = configurators.event.getEventMessage();\r\n        }else{\r\n          eachSelectedPresetNumber(function(selectedPresetNumber) {\r\n            controlledModule.kit[selectedPresetNumber] = configurators.event.getEventMessage();\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n\r\n      if (event.tied) {\r\n        selectedPresetNumbers.push(event.button);\r\n      } else {\r\n        selectedPresetNumbers = [event.button];\r\n      }\r\n\r\n      if(usingVelocity.value){\r\n        pauseUi=true;\r\n      }else{\r\n        controlledModule.uiTriggerOn(event.button);\r\n      }\r\n\r\n      pressedMatrixButtons.add(event.button);\r\n      if(controlledModule.autoMap!==false){\r\n        if (controlledModule.kit[0])\r\n          configurators.event.setFromEventMessage(controlledModule.kit[0], hardware);\r\n      }else if (controlledModule.kit[event.button])\r\n        if (lastEngagedConfigurator == configurators.event) {\r\n          // configurators.event.baseEvent=controlledModule.kit[selectedPresetNumber].on;\r\n          lastSelectedPresetNumber(function(selectedPresetNumber) {\r\n            configurators.event.setFromEventMessage(controlledModule.kit[selectedPresetNumber], hardware);\r\n          });\r\n        }\r\n      updateHardware(hardware);\r\n    }\r\n  };\r\n\r\n  this.matrixButtonReleased = function(event) {\r\n\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonReleased(event);\r\n    } else {\r\n      if(!muteMode){\r\n        controlledModule.uiTriggerOff(event.button);\r\n        pressedMatrixButtons.delete(event.button);\r\n      }\r\n    }\r\n  };\r\n\r\n  this.matrixButtonHold = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonHold(event);\r\n    } else {}\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.button == 1) {\r\n        lastEngagedConfigurator = engagedConfigurator = configurators.event;\r\n      } else if (event.button == 2) {\r\n        lastEngagedConfigurator = engagedConfigurator = configurators.global;\r\n\r\n      } else if (event.button == 0 || event.button == 3) { //0 is used in x28 and 3 in x16\r\n        muteMode = !muteMode;\r\n        event.hardware.sendScreenA(\"mute or hold\");\r\n      } else if (event.button >= 8) {\r\n        lastEngagedConfigurator = engagedConfigurator = configurators.record;\r\n      }\r\n      if (engagedConfigurator) engagedConfigurator.engage(event);\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator = false;\r\n    } else {}\r\n    muteMode = false;\r\n    updateHardware(event.hardware);\r\n  };\r\n  var updateAvailablePresetsBitmap = function() {\r\n    availablePresetsBitmap = 0;\r\n    for (var a in controlledModule.kit) {\r\n      availablePresetsBitmap |= 1 << a;\r\n    }\r\n  }\r\n  this.encoderScrolled = function(event) {\r\n\r\n\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      let configuratorResponse = lastEngagedConfigurator.encoderScrolled(event);\r\n      if (lastEngagedConfigurator==configurators.event) {\r\n        if (configuratorResponse) {\r\n          if(controlledModule.autoMap!==false){\r\n            if (!controlledModule.kit[0]) {\r\n              controlledModule.kit[0] = configurators.event.getEventMessage();\r\n            }\r\n            controlledModule.kit[0].value[configuratorResponse.selectedValueNumber] = configuratorResponse.selectedValueValue;\r\n          }else{\r\n            eachSelectedPresetNumber(function(selectedPresetNumber) {\r\n              if (!controlledModule.kit[selectedPresetNumber]) {\r\n                controlledModule.kit[selectedPresetNumber] = configurators.event.getEventMessage();\r\n              }\r\n              controlledModule.kit[selectedPresetNumber].value[configuratorResponse.selectedValueNumber] = configuratorResponse.selectedValueValue;\r\n            });\r\n          }\r\n          updateAvailablePresetsBitmap();\r\n        };\r\n      }\r\n    }\r\n\r\n    pressedMatrixButtons.forEach(function (itm) {\r\n      console.log(\"active change, button\", itm);\r\n      controlledModule.uiTriggerOn(itm);\r\n    });\r\n\r\n    updateHardware(event.hardware);\r\n  };\r\n  let outsideScrollHeader = 0;\r\n  let outsideScrollMutingUp = true;\r\n  this.outsideScroll = function(event) {\r\n    let delta = event.delta;\r\n    let kit = controlledModule.kit;\r\n\r\n    // console.log(outsideScrollHeader);\r\n\r\n    kit[outsideScrollHeader].mute = (outsideScrollMutingUp ? (delta > 0) : (delta < 0));\r\n    // console.log(`(${outsideScrollMutingUp}?(${delta>0}):(${delta<0}))=${(outsideScrollMutingUp?(delta>0):(delta<0))}`);\r\n\r\n    if (kit[outsideScrollHeader].mute) {\r\n      muteBmp |= 1 << outsideScrollHeader;\r\n    } else {\r\n      muteBmp &= ~(1 << outsideScrollHeader);\r\n    }\r\n\r\n    outsideScrollHeader += delta;\r\n    if (outsideScrollHeader >= 16) {\r\n      outsideScrollMutingUp = !outsideScrollMutingUp;\r\n      outsideScrollHeader = 0;\r\n    }\r\n    if (outsideScrollHeader < 0) {\r\n      outsideScrollMutingUp = !outsideScrollMutingUp;\r\n      outsideScrollHeader = 15;\r\n    }\r\n    let ret = \"\";\r\n    for (let a = 0; a < 16; a++) {\r\n      ret += (kit[a].mute ? \" \" : SQUARE)\r\n    }\r\n\r\n    return (ret);\r\n  }\r\n  this.encoderPressed = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderPressed(event);\r\n    } else {}\r\n  };\r\n  this.encoderReleased = function(event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderReleased(event);\r\n    } else {}\r\n  };\r\n  this.engage = function(event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    outsideScrollHeader = 0;\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  configurators.record.autoEngageWindow();\r\n  var updateHardware = function(hardware) {\r\n    if(pauseUi) return;\r\n    hardware.sendScreenA(controlledModule.name);\r\n    if(usingVelocity.value){\r\n      // var step=0XFF/16;\r\n      // var str=\"\";\r\n      // for(var a=0; a<16; a++){\r\n      //   if(a*step<lastTriggeredVelocity){\r\n      //     str+=\"|\";\r\n      //   }else{\r\n      //     str+=\" \";\r\n      //   }\r\n      // }\r\n      hardware.sendScreenB(lastTriggeredVelocity+\"_____\");\r\n    }\r\n    updateLeds(hardware);\r\n  }\r\n\r\n  function passiveUpdateLeds() {\r\n    if(pauseUi) return;\r\n\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        updateLeds(hardware);\r\n      }\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    if(pauseUi) return;\r\n\r\n    var selectedPresetBitmap = 0;\r\n    var pressedPresetBitmap=0;\r\n    pressedMatrixButtons.forEach(function(a){\r\n      pressedPresetBitmap|=1<<a;\r\n    });\r\n    eachSelectedPresetNumber(function(selectedPresetNumber) {\r\n      selectedPresetBitmap |= 1 << selectedPresetNumber;\r\n    });\r\n\r\n    hardware.draw([\r\n      (highlightedBitmap | selectedPresetBitmap) & ~muteBmp,\r\n      (highlightedBitmap | selectedPresetBitmap | availablePresetsBitmap | pressedPresetBitmap) & ~muteBmp,\r\n      selectedPresetBitmap | availablePresetsBitmap | pressedPresetBitmap | muteBmp\r\n    ],false);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/PresetKit/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/PresetKit/index.js":
/*!****************************************!*\
  !*** ./src/modules/PresetKit/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar headers = EventMessage.headers;\r\nvar NoteOnTracker = __webpack_require__(/*! ../moduleUtils/NoteOnTracker.js */ \"./src/modules/moduleUtils/NoteOnTracker.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/PresetKit/InterfaceX16.js\");\r\n\r\n\r\nvar instanced = 0;\r\nvar name = function() {\r\n    this.name = this.baseName + \" \" + instanced;\r\n    instanced++;\r\n}\r\nvar PresetKit = function(properties, environment) {\r\n    this.baseName = \"preset kit\";\r\n\r\n    var self = this;\r\n    //get my unique name\r\n    name.call(this);\r\n    this.preventBus=true;\r\n    this.autoMap = false;\r\n\r\n    if (properties.autoMap == true) this.autoMap = 1;\r\n    if (properties.autoMap == 'timbre') this.autoMap = 2;\r\n    if (properties.autoMap == 'note') this.autoMap = 1;\r\n\r\n    this.recordingUi = true;\r\n\r\n    if (properties.name) this.name = properties.name;\r\n\r\n\r\n    this.interfaces.X16 = InterfaceX16;\r\n    this.interfaces.Http = __webpack_require__(/*! ./InterfaceHttp.js */ \"./src/modules/PresetKit/InterfaceHttp.js\");\r\n\r\n    var kit = this.kit = {};\r\n\r\n\r\n    for (var n = 0; n < 16; n++) {\r\n        this.kit[n] = new EventMessage({ value: [headers.triggerOn, -1, -1, -1] });\r\n    }\r\n\r\n    if (properties.kit) {\r\n        for (var n in properties.kit) {\r\n            this.kit[n % 16] = new EventMessage({\r\n                value: properties.kit[n]\r\n            });\r\n        }\r\n        self.handle('kitchanged');\r\n    }\r\n\r\n    var noteOnTracker = new NoteOnTracker(this);\r\n\r\n    this.uiTriggerOn = function(presetNumber, velo) {\r\n        // console.log(\"VELO\",velo);\r\n        if (velo === false || velo === undefined) { velo = -1 }\r\n        if (self.mute) return;\r\n\r\n        if (kit[presetNumber] || self.autoMap !== false) {\r\n            if (kit[presetNumber]) {\r\n                if (kit[presetNumber].mute) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            var recMessage = new EventMessage({\r\n                value: [headers.triggerOn, presetNumber, 0, velo]\r\n            });\r\n\r\n            self.triggerOn(presetNumber, recMessage, true);\r\n            // console.log(\"ton\", recMessage.value);\r\n            if (self.recordingUi) {\r\n                self.recordOutput(recMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.uiTriggerOff = function(presetNumber) {\r\n        // console.log(\"UI off\");\r\n        // console.log(\"koff=\",noteOnTracker[presetNumber]);\r\n        noteOnTracker.ifNoteOff(presetNumber + \"ui\", function(noteOff) {\r\n            self.output(noteOff, true);\r\n            // console.log(\" send off\");\r\n            if (self.recordingUi) {\r\n                var recMessage = new EventMessage({\r\n                    value: [headers.triggerOff, presetNumber, 0, 0]\r\n                });\r\n\r\n                // console.log(\" record off\", recMessage.value);\r\n                self.recordOutput(recMessage);\r\n                /*new EventMessage({\r\n                  value: [headers.triggerOff, 0, presetNumber, 0]\r\n                })*/\r\n            }\r\n        });\r\n    }\r\n\r\n    this.triggerOn = function(presetNumber, originalMessage, ui = false) {\r\n        presetNumber %= 16;\r\n        self.handle(\"extrigger\", {\r\n            preset: presetNumber\r\n        });\r\n        if (self.autoMap !== false) {\r\n            if (!kit[0]) {\r\n                kit[0] = new EventMessage()\r\n            };\r\n\r\n            var newEvent = kit[0].clone().underImpose(originalMessage);\r\n\r\n            if (kit[presetNumber]) {\r\n                if (kit[presetNumber].mute) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            newEvent.value[self.autoMap] += presetNumber;\r\n            var onkey = presetNumber;\r\n            if (ui == true) onkey += \"ui\";\r\n            noteOnTracker.add(newEvent, onkey);\r\n            self.output(newEvent);\r\n\r\n        } else {\r\n            if (self.mute) return;\r\n            if (kit[presetNumber]) {\r\n                if (!kit[presetNumber].mute) {\r\n                    var outputMessage = kit[presetNumber].clone().underImpose(originalMessage);\r\n\r\n\r\n                    var onkey = presetNumber;\r\n                    if (ui == true) onkey += \"ui\";\r\n                    noteOnTracker.add(kit[presetNumber], onkey);\r\n                    // noteOnTracker.add(kit[presetNumber], presetNumber);\r\n                    self.output(outputMessage);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this.triggerOff = function(presetNumber) {\r\n        presetNumber %= 16;\r\n        self.handle(\"extrigger\", {\r\n            preset: presetNumber\r\n        });\r\n        noteOnTracker.ifNoteOff(presetNumber, function(noteOff) {\r\n            // console.log(\"noteoff\", noteOff.value);\r\n            self.output(noteOff, true);\r\n        });\r\n    }\r\n\r\n    this.stepMicro = function() { }\r\n    var recordHead = 0;\r\n    this.recordEvent = function(evM) {\r\n        self.handle('kitchanged');\r\n        kit[recordHead] = new EventMessage(evM);\r\n        // console.log(\"rec\",kit[recordHead]);\r\n        recordHead++;\r\n        recordHead %= 16;\r\n    }\r\n    this.togglePresetMute = function(presetNumber) {\r\n        if (kit[presetNumber]) {\r\n            kit[presetNumber].mute = !kit[presetNumber].mute === true;\r\n            return kit[presetNumber].mute;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    this.recordingReceived = function(event) {\r\n        var evM = event.eventMessage;\r\n\r\n        if (evM.value[0] == headers.record) {\r\n            evM.value.shift();\r\n            // console.log(\"rec\",evm);\r\n            this.recordEvent(evM);\r\n        }\r\n    }\r\n    this.messageReceived = function(event) {\r\n        var evM = event.eventMessage;\r\n        // console.log(evM);\r\n        self.handle('receive', event);\r\n        if (evM.value[0] == headers.clockTick) {\r\n            self.stepMicro(evM.value[1], evM.value[2]);\r\n        } else if (evM.value[0] == headers.triggerOn) {\r\n            //nton\r\n            self.triggerOn(evM.value[1], evM);\r\n        } else if (evM.value[0] == headers.triggerOff) {\r\n            //ntoff\r\n            self.triggerOff(evM.value[1]);\r\n        }\r\n    }\r\n\r\n}\r\nPresetKit.color = [90, 70, 30];\r\nmodule.exports = PresetKit\r\n\r\n/*\r\nTEsting:\r\n- does it send notes upon tap?\r\n- does it record notes?\r\n- does it send notes off?\r\n- if anote is tapped, then asecond note is tapped and the first note released, does it send all the note off and on?\r\n- if another module sends a note off, does it stop an note that is going on in the interface?\r\n- does the note ons that are being tracked get removed when it receives note off from another module? (example recording to an arpeggiator)\r\n\r\n\r\n*/\r\n\n\n//# sourceURL=webpack://environment/./src/modules/PresetKit/index.js?");

/***/ }),

/***/ "./src/modules/RouteSequencer/InterfaceHttp.js":
/*!*****************************************************!*\
  !*** ./src/modules/RouteSequencer/InterfaceHttp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Observable = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nmodule.exports = function (controlledModule, environment) {\r\n    var self = this;\r\n    Observable.call(this);\r\n    var bitmapCache = 0;\r\n\r\n    var tBitmap=function(){\r\n        \r\n\r\n        var playHeadBmp = 0x1111;\r\n        var int = (\r\n                controlledModule.sequenceBitmap.value \r\n                >> controlledModule.clock.step\r\n            ) & playHeadBmp;\r\n        return int | int>>3 | int>>6 | int>>9;\r\n    }\r\n\r\n    var mySequenceInterval = false;\r\n    var baseEngage = this.engage;\r\n    this.engage = function (callback) {\r\n        baseEngage(callback);\r\n        controlledModule.on(\"step\",function () {\r\n            callback({\r\n                type:'~module', \r\n                steps: 4,\r\n                // step:controlledModule.clock.step, not used, instead I send currently on\r\n                bitmap: tBitmap(),//controlledModule.sequenceBitmap.value,\r\n                origin:controlledModule\r\n            });\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/RouteSequencer/InterfaceHttp.js?");

/***/ }),

/***/ "./src/modules/RouteSequencer/InterfaceX16.js":
/*!****************************************************!*\
  !*** ./src/modules/RouteSequencer/InterfaceX16.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n\r\n\r\n//instance section\r\nmodule.exports = function (controlledModule) {\r\n  base.call(this);\r\n  var configurators = {};\r\n  configurators.global = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"step length\": { value: controlledModule.clock.substeps },\r\n      \"send ck. (!)\": {value: controlledModule.settings.sendClock },\r\n      \"route mode\": controlledModule.routeMode,\r\n    },\r\n  });\r\n  configurators.global.vars['route mode'].changeFunction=function(thisVar, delta) {\r\n    thisVar.value += delta;\r\n    if (thisVar.value > thisVar.valueNames.length) {\r\n      thisVar.value = 0;\r\n    } else if (thisVar.value < 0) {\r\n      thisVar.value=thisVar.valueNames.length;\r\n    }\r\n  }\r\n  configurators.global.vars['route mode'].nameFunction=function(thisVar, delta) {\r\n    return thisVar.valueNames[thisVar.value];\r\n  }\r\n  configurators.global.vars['step length'].changeFunction=function(thisVar, delta) {\r\n    thisVar.value += delta;\r\n    if (thisVar.value < -4) {\r\n      thisVar.value -= delta;\r\n    } else if (thisVar.value < 1) {\r\n      controlledModule.clock.substeps = Math.pow(2, thisVar.value);//go by 12 divisible numbers: Math.floor( Math.pow(2,-1)/(1/12) )/12\r\n    } else {\r\n      controlledModule.clock.substeps = thisVar.value;\r\n    }\r\n  }\r\n\r\n  configurators.global.vars[\"send ck. (!)\"].changeFunction = function (thisVar, delta) {\r\n    thisVar.value=thisVar.value==false;\r\n    controlledModule.settings.sendClock=thisVar.value;\r\n  }\r\n\r\n  configurators.global.vars['step length'].nameFunction = function (thisVar) {\r\n    return \"to \" + controlledModule.clock.substeps;\r\n  }\r\n  var engagedConfigurator = false;\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var stepsBmp = controlledModule.sequenceBitmap;\r\n\r\n  var engagedHardwares = new Set();\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } else {\r\n      stepsBmp.value^=1<<event.button;\r\n      console.log(stepsBmp.value.toString(2));\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    if (engagedConfigurator) { } else {\r\n      updateHardware(event.hardware);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    } else {\r\n      if (event.data[0] == 2) {\r\n        engagedConfigurator = configurators.global;\r\n        configurators.global.engage(event);\r\n      }\r\n    }\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] == 2) {\r\n      if (engagedConfigurator == configurators.global) {\r\n        lastEngagedConfigurator = engagedConfigurator;\r\n        engagedConfigurator.disengage(event);\r\n        engagedConfigurator = false;\r\n      }\r\n    }\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.encoderScrolled(event);\r\n    } else {\r\n      if (lastEngagedConfigurator) {\r\n        lastEngagedConfigurator.encoderScrolled(event)\r\n      }\r\n    }\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n  var updateHardware = function (hardware) {\r\n    if (engagedConfigurator) return;\r\n    hardware.sendScreenA(controlledModule.name);\r\n    updateLeds(hardware);\r\n  }\r\n  var passiveUpdateLeds=function(){\r\n    engagedHardwares.forEach(function (hardware) {\r\n      updateLeds(hardware);\r\n    })\r\n  }\r\n  controlledModule.on('step', passiveUpdateLeds);\r\n  var animf=0;\r\n  var updateLeds = function (hardware) {\r\n    if (engagedConfigurator) return;\r\n\r\n    // stepsBmp = makeAnimationBitmap({x:2,y:2},animf);\r\n    var playHeadBmp = 0x1111 << controlledModule.clock.step;\r\n    hardware.draw([playHeadBmp, stepsBmp.value, stepsBmp.value]);\r\n    animf++;\r\n    if(animf>8) animf=0;\r\n  }\r\n  // setInterval(function(){\r\n  //   engagedHardwares.forEach(function(hardware){\r\n  //     updateLeds(hardware);\r\n  //   })\r\n  // }, 700);\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/RouteSequencer/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/RouteSequencer/index.js":
/*!*********************************************!*\
  !*** ./src/modules/RouteSequencer/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/RouteSequencer/InterfaceX16.js\");\r\nvar InterfaceHttp = __webpack_require__(/*! ./InterfaceHttp */ \"./src/modules/RouteSequencer/InterfaceHttp.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar headers = EventMessage.headers;\r\n\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = this.baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\n/**\r\n @constructor\r\n the instance of the of the module, ment to be instantiated multiple times.\r\n require to moduleBase.call\r\n */\r\n\r\n\r\nvar RouteSequencer = function (properties) {\r\n  var thisInstance = this;\r\n  var myBitmap = 0;\r\n\r\n  var noteOnTracker = [];\r\n\r\n  var settings = this.settings = {\r\n    // feedback:{\r\n    //   value:0,\r\n    //   valueNames:['no','yes'],\r\n    // },\r\n    sendClock:false\r\n  }\r\n  this.routeMode={\r\n    value: 0,\r\n    valueNames:['outputs','inputs'],\r\n  }\r\n\r\n  let clock = this.clock = {\r\n    substep: 0,\r\n    step: 0,\r\n    substeps: 1\r\n  }\r\n  let sequenceBitmap = this.sequenceBitmap = {\r\n    value: properties.bitmap || 0,\r\n  }\r\n\r\n  this.baseName = \"RouteSequencer\";\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n  var self = this;\r\n\r\n  this.interfaces.X16 = InterfaceX16;\r\n  this.interfaces.Http = InterfaceHttp;\r\n\r\n  var memory = new Set();\r\n  var recMessages = {\r\n    rate: new EventMessage({ value: [headers.changeRate, 12, -1] })\r\n  }\r\n  this.recordRate = function () {\r\n    recMessages.rate.value[2] = settings.delayMicro.value;\r\n    self.recordOutput(recMessages.rate);\r\n  }\r\n  this.recordingReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.record) {\r\n      var event = evt.eventMessage;\r\n      event.value.shift();\r\n      memory.add(event);\r\n    }\r\n    //backpropagate rec messages\r\n  }\r\n\r\n  var outputs = self.getOutputs();\r\n  var updateOutputs = function () {\r\n    outputs = self.getOutputs();\r\n  }\r\n  var inputs = self.getInputs();\r\n  var updateInputs=function(){\r\n    inputs=self.getInputs();\r\n  }\r\n\r\n  var normalOutputFunction=this.output;\r\n\r\n  var specialOutputFunction = function (_eventMessage, overrideMute, properties={}) {\r\n\r\n    if ((!self.mute) || overrideMute) {\r\n        var eventMessage=_eventMessage;\r\n\r\n\r\n      self.enqueue(function(){\r\n        var chan = 0;\r\n        if (properties.destination) {\r\n          if (self.outputs.has(properties.destination)) {\r\n            properties.destination.messageReceived({ eventMessage: eventMessage.clone(), origin: self });\r\n          }\r\n        } else {\r\n          outputs.forEach(function (tModule) {\r\n            if (sequenceBitmap.value & (1 << (clock.step + chan * 4))) {\r\n              var evMesClone=eventMessage.clone();\r\n              tModule.messageReceived({ eventMessage: evMesClone, origin: self });\r\n              self.handle('>message', { origin: self, destination: tModule, val: evMesClone});\r\n            }\r\n            chan++;\r\n            chan %= 4;\r\n          })\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  this.output=function(eventMessage,overrideMute,properties={}){\r\n    if(self.routeMode.value==0){\r\n      specialOutputFunction(eventMessage,overrideMute,properties);\r\n    }else{\r\n      normalOutputFunction(eventMessage,overrideMute);\r\n    }\r\n  }\r\n  this.on(\"+connection\",updateOutputs);\r\n  this.on(\"-connection\",updateOutputs);\r\n  this.on(\">message\", function (evt) {\r\n    if (evt.val.value[0] == headers.triggerOn) {\r\n      noteOnTracker[evt.val.value[1]] = evt;\r\n    }\r\n  });\r\n\r\n  var stepFunction = function () {\r\n    clock.step++;\r\n    clock.step %= 4;\r\n    self.handle('step');\r\n  }\r\n\r\n  this.messageReceived = function (evt) {\r\n    if (evt.eventMessage.value[0] == headers.clockTick) {\r\n      var clockBase = evt.eventMessage.value[1];\r\n      var clockMicroStep = evt.eventMessage.value[2];\r\n      if ((clockMicroStep / clock.substeps) % clockBase == 0) {\r\n\r\n        clock.substep++;\r\n\r\n        // console.log(\"T\",clock);\r\n        if (clock.substep >= clock.substeps) {\r\n\r\n          clock.substep = 0;\r\n          stepFunction();\r\n        }\r\n      }\r\n      if (settings.sendClock){\r\n        self.output(evt.eventMessage);\r\n      }\r\n    } else if (evt.eventMessage.value[0] == headers.triggerOff) {\r\n      var tracked = noteOnTracker[evt.eventMessage.value[1]];\r\n      if (tracked)\r\n          self.output(evt.eventMessage, false, tracked);\r\n    } else {\r\n      if(self.routeMode.value==1){\r\n        updateInputs();\r\n        //-1 so that bus input is not counted\r\n        var inputn=inputs.indexOf(evt.origin)-1;\r\n        if (sequenceBitmap.value & (1 << (clock.step + inputn * 4))) {\r\n          // console.log(\"input n\",inputn);\r\n          self.output(evt.eventMessage);\r\n        }\r\n\r\n      }else{\r\n        self.output(evt.eventMessage);\r\n      }\r\n    }\r\n  }\r\n\r\n  // this.onRemove = function () {\r\n  //   noteOnTracker.empty(function (noff) {\r\n  //     thisInstance.output(noff, true);\r\n  //   });\r\n  //   return true;\r\n  // }\r\n\r\n  this.handleStepsChange = function () {\r\n    self.handle('~module', { steps: runningNotes.length });\r\n  }\r\n\r\n};\r\n\r\nRouteSequencer.color = [125, 0, 233];\r\nmodule.exports = RouteSequencer;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/RouteSequencer/index.js?");

/***/ }),

/***/ "./src/modules/Sequencer/EventPattern.js":
/*!***********************************************!*\
  !*** ./src/modules/Sequencer/EventPattern.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage=__webpack_require__(/*! ../../datatypes/EventMessage */ \"./src/datatypes/EventMessage.js\");\r\n// var noteSpec=require(\"../modules/standards/note.js\");\r\nvar CLOCKTICKHEADER = 0x00;\r\nvar TRIGGERONHEADER = 0x01;\r\nvar TRIGGEROFFHEADER = 0x02;\r\nvar RECORDINGHEADER = 0xAA;\r\n/**\r\nprototype of event messages in a format that is handy for storage\r\n*/\r\nvar EventPattern=function(properties){\r\n  var thisPE=this;\r\n\r\n  this.compareTo=function(other,propertyList){\r\n    return thisPE.on.compareTo(other.on,propertyList);//& this.off.compareTo(other.off);\r\n  }\r\n  this.fromEventMessage=function(evMes){\r\n    thisPE.on=new EventMessage(evMes);\r\n    thisPE.off=new EventMessage(evMes);\r\n    if(thisPE.on.value[0]==TRIGGERONHEADER){\r\n      thisPE.off.value[0]=TRIGGEROFFHEADER;\r\n      thisPE.off.value[3]=0x00;\r\n    }else{\r\n      thisPE.off=false;\r\n    }\r\n    return thisPE;\r\n  };\r\n\r\n  if(properties){\r\n    for(var a in properties){\r\n      thisPE[a]=properties[a];\r\n    }\r\n    if(thisPE.on.isEventMessage!==true) thisPE.on=new EventMessage(thisPE.on);\r\n    if(thisPE.off===undefined){\r\n      thisPE.fromEventMessage(thisPE.on);\r\n    }else if(thisPE.off!==false)\r\n      if(thisPE.off.isEventMessage!==true) thisPE.off=new EventMessage(thisPE.off);\r\n      //untested:\r\n  }else{\r\n    thisPE.on=new EventMessage();\r\n    thisPE.fromEventMessage(thisPE.on);\r\n  }\r\n}\r\nmodule.exports=EventPattern;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/EventPattern.js?");

/***/ }),

/***/ "./src/modules/Sequencer/InterfaceHttp.js":
/*!************************************************!*\
  !*** ./src/modules/Sequencer/InterfaceHttp.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Observable = __webpack_require__(/*! onhandlers */ \"./node_modules/onhandlers/on.js\");\r\nmodule.exports = function (controlledModule, environment) {\r\n    var self = this;\r\n    Observable.call(this);\r\n    var bitmapCache = 0;\r\n\r\n    var getBitmap = function () {\r\n        var ret = 0x0000;\r\n        // console.log(controlledModule.patData);\r\n\r\n        for (var step in controlledModule.patData) {\r\n            if (controlledModule.patData[step])\r\n                if (controlledModule.patData[step].length)\r\n                    ret |= 1 << step;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    var mySequenceInterval = false;\r\n    var baseEngage = this.engage;\r\n    this.engage = function (callback) {\r\n        baseEngage(callback);\r\n        controlledModule.on('step', function (evt) {\r\n            // console.log(controlledModule.currentStep);\r\n            var msg = {\r\n                type: \"~module\",\r\n                origin: controlledModule,\r\n                step: controlledModule.currentStep.value\r\n            }\r\n            var nBp = getBitmap();\r\n            // if (nBp != bitmapCache) {\r\n                bitmapCache = nBp;\r\n                msg.bitmap = nBp;\r\n                // console.log(\"send ~bitmap\");\r\n            // }\r\n            callback(msg);\r\n\r\n        });\r\n        mySequenceInterval = setInterval(function () {\r\n\r\n        }, 200);\r\n    }\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/InterfaceHttp.js?");

/***/ }),

/***/ "./src/modules/Sequencer/InterfaceX16.js":
/*!***********************************************!*\
  !*** ./src/modules/Sequencer/InterfaceX16.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventConfigurator = __webpack_require__(/*! ../x16utils/EventConfigurator.js */ \"./src/modules/x16utils/EventConfigurator.js\");\r\nvar BlankConfigurator = __webpack_require__(/*! ../x16utils/BlankConfigurator.js */ \"./src/modules/x16utils/BlankConfigurator.js\");\r\nvar RecordMenu = __webpack_require__(/*! ../x16utils/RecordMenu.js */ \"./src/modules/x16utils/RecordMenu.js\");\r\nvar NoteLengthner = __webpack_require__(/*! ./sequencerGuts/NoteLengthner.js */ \"./src/modules/Sequencer/sequencerGuts/NoteLengthner.js\");\r\nvar EventPattern = __webpack_require__(/*! ./EventPattern */ \"./src/modules/Sequencer/EventPattern.js\");\r\nvar headers = EventMessage.headers;\r\n\r\nvar base = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n\r\nfunction log(b, n) {\r\n  return Math.log(n) / Math.log(b);\r\n}\r\n/**\r\ndefinition of a monoSequencer interactor for the x16basic controller hardware\r\n*/\r\nmodule.exports = function (controlledModule, environment) {\r\n  base.call(this);\r\n  var self = this;\r\n  //boilerplate\r\n\r\n  base.call(this, controlledModule);\r\n  var thisInterface = this;\r\n  var currentViewStartStep = 0;\r\n  var engagedHardwares = new Set();\r\n\r\n  //tracking vars\r\n  var lastRecordedNote = false;\r\n\r\n\r\n  var noteLengthnerStartPointsBitmap = 0x0;\r\n  var noteLengthnerLengthsBitmap = 0x0;\r\n  var noteLengthner = new NoteLengthner(controlledModule);\r\n  noteLengthner.onStep(function (thisNoteLengthner, nicCount) {\r\n    //TODO lengthsBitmap should be on scope of interface, not noteLengthner\r\n    // console.log(nicCount);\r\n    if (nicCount > 0) {\r\n      noteLengthnerLengthsBitmap |= noteLengthnerLengthsBitmap << 1;\r\n      noteLengthnerLengthsBitmap |= noteLengthnerLengthsBitmap >> 16;\r\n    }\r\n  });\r\n  //different interaction modes\r\n  var skipMode = false;\r\n  var shiftPressed = false;\r\n  var configuratorsPressed = {};\r\n\r\n  //configurators setup\r\n  var engagedConfigurator = false;\r\n  var configurators = {};\r\n  configurators.event = new EventConfigurator(this, {\r\n    values: [1, 0, -1, -1]\r\n  });\r\n\r\n\r\n  configurators.event.getEventPattern = function () {\r\n    var newEvPat = new EventPattern();\r\n    newEvPat.fromEventMessage(this.getEventMessage());\r\n    newEvPat.stepLength = 1;\r\n    return newEvPat;\r\n  }\r\n  configurators.event.setFromEventPattern = function (evPat) {\r\n    if (evPat) {\r\n      if (evPat.on) {\r\n        this.setFromEventMessage(evPat.on);\r\n        // baseEvent = new EventMessage(EvPat.on);\r\n        this.passiveUpdateScreen();\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  var lastEngagedConfigurator = configurators.event;\r\n  var loopDisplace = controlledModule.loopDisplace;\r\n  configurators.record = new RecordMenu(this, {\r\n    environment: environment,\r\n    controlledModule: controlledModule\r\n  });\r\n\r\n  //interaction with controlledModule\r\n  var currentStep = controlledModule.currentStep;\r\n  var loopLength = controlledModule.loopLength;\r\n  var lookLoop = {\r\n    value: 0\r\n  };\r\n  configurators.time = new BlankConfigurator(this, {\r\n    name: \"\",\r\n    vars: {\r\n      \"loop length\": loopLength,\r\n      \"fold\": { value: controlledModule.loopLength.value, base: 2 },\r\n      \"fold!\": { value: controlledModule.loopLength.value, base: 2 },\r\n      \"shift+cpte.\": { value: 0 },\r\n      \"loop look\": lookLoop,\r\n      \"page\": { value: 0 },\r\n      \"step length\": { value: controlledModule.stepDivide.value },\r\n      \"drift substep\": controlledModule.loopDisplace,\r\n      \"microstep offset\": controlledModule.microStepDisplace,\r\n      \"playing\": controlledModule.playing,\r\n      \"stoppable\": controlledModule.listenTransport,\r\n      \"rec mode\": { value: controlledModule.recordSettings.mode },\r\n      \"on rec end\": { value: controlledModule.recordSettings.switchOnEnd },\r\n      \"load sequence\": { value:false },\r\n      \"save sequence\": { value:0 },\r\n    }\r\n  });\r\n\r\n\r\n  configurators.time.vars[\"save sequence\"].changeFunction = function (thisVar, delta) {\r\n    if(!thisVar.list)return;\r\n    thisVar.value += delta;\r\n    if(thisVar.value>thisVar.list.length) thisVar.value=0;\r\n    if(thisVar.value<0) thisVar.value=thisVar.list.length;\r\n  }\r\n  configurators.time.vars[\"save sequence\"].nameFunction = function (thisVar) {\r\n    if(!thisVar.list) return \"...\";\r\n    return thisVar.list[thisVar.value]+\"\";\r\n  }\r\n  configurators.time.vars[\"save sequence\"].selectFunction = function (thisVar) {\r\n    controlledModule.listSequenceFiles().then(function(list){\r\n      thisVar.list=list;\r\n    });\r\n  }\r\n  configurators.time.vars[\"save sequence\"].disengageFunction = function (thisVar) {\r\n    controlledModule.saveSequenceFile(thisVar.list[thisVar.value]);\r\n  }\r\n\r\n  configurators.time.vars[\"load sequence\"].changeFunction = function (thisVar, delta) {\r\n    if(!thisVar.list)return;\r\n    thisVar.value += delta;\r\n    if(thisVar.value>thisVar.list.length) thisVar.value=0;\r\n    if(thisVar.value<0) thisVar.value=thisVar.list.length;\r\n  }\r\n  configurators.time.vars[\"load sequence\"].nameFunction = function (thisVar) {\r\n    if(!thisVar.list) return \"...\";\r\n    return thisVar.list[thisVar.value]+\"\";\r\n  }\r\n  configurators.time.vars[\"load sequence\"].selectFunction = function (thisVar) {\r\n    controlledModule.listSequenceFiles().then(function(list){\r\n      thisVar.list=list;\r\n    });\r\n  }\r\n  configurators.time.vars[\"load sequence\"].disengageFunction = function (thisVar) {\r\n    controlledModule.loadSequenceFile(thisVar.list[thisVar.value]);\r\n  }\r\n\r\n  configurators.time.vars[\"step length\"].changeFunction = function (thisVar, delta) {\r\n    thisVar.value += delta;\r\n    if (thisVar.value < -4) {\r\n      thisVar.value -= delta;\r\n    } else if (thisVar.value < 1) {\r\n      controlledModule.stepDivide.value = Math.pow(2, thisVar.value);//go by 12 divisible numbers: Math.floor( Math.pow(2,-1)/(1/12) )/12\r\n    } else {\r\n      controlledModule.stepDivide.value = thisVar.value;\r\n    }\r\n  }\r\n  configurators.time.vars[\"step length\"].nameFunction = function (thisVar) {\r\n    return \"to \" + controlledModule.stepDivide.value;\r\n  }\r\n  configurators.time.vars[\"shift+cpte.\"].changeFunction = function (v, d) {\r\n    v.value += d;\r\n    controlledModule.offsetSequence(d);\r\n    controlledModule.currentStep.value += d;\r\n  };\r\n  configurators.time.vars[\"shift+cpte.\"].selectFunction = function (v) {\r\n    v.value = 0;\r\n  }\r\n\r\n  configurators.time.vars[\"loop length\"].min = 1;\r\n  configurators.time.vars[\"loop length\"].changeFunction = function (thisVar, delta) {\r\n    if (thisVar.value + delta >= 1)\r\n      thisVar.value += delta;\r\n    controlledModule.handleStepsChange();\r\n  }\r\n\r\n  configurators.time.vars[\"fold\"].nameFunction = configurators.time.vars[\"fold!\"].nameFunction = function (thisVar) {\r\n    //TODO: ensure that the thisVar.value ends up being the actual length\r\n    return `${thisVar.base}^${Math.round(thisVar.power * 100) / 100}>${Math.round(thisVar.value)}`;\r\n\r\n  }\r\n  configurators.time.vars[\"fold\"].selectFunction = configurators.time.vars[\"fold!\"].selectFunction = function (thisVar) {\r\n    thisVar.value = controlledModule.loopLength.value;\r\n    thisVar.power = log(thisVar.base, thisVar.value);\r\n  }\r\n  configurators.time.vars[\"fold!\"].changeFunction = function (thisVar, delta) {\r\n    var oldLength = thisVar.value;\r\n    if (shiftPressed) {\r\n      thisVar.base += delta;\r\n    } else {\r\n      thisVar.power += delta;\r\n    }\r\n    thisVar.value = Math.round(Math.pow(thisVar.base, thisVar.power));\r\n    if (thisVar.value < 1) {\r\n      thisVar.value = 1;\r\n    }\r\n    if (thisVar.base < 1) {\r\n      thisVar.base = 1;\r\n    }\r\n    if (thisVar.power < 1) {\r\n      thisVar.power = 1;\r\n    }\r\n    // console.log(\"FOLD\",thisVar.value);\r\n    controlledModule.duplicateSequence(0, oldLength, thisVar.value / oldLength);\r\n    controlledModule.loopLength.value = thisVar.value;\r\n    controlledModule.handleStepsChange();\r\n  }\r\n  configurators.time.vars[\"fold\"].changeFunction = function (thisVar, delta) {\r\n    var oldLength = thisVar.value;\r\n    if (shiftPressed) {\r\n      thisVar.base += delta;\r\n    } else {\r\n      thisVar.power += delta;\r\n    }\r\n    thisVar.value = Math.round(Math.pow(thisVar.base, thisVar.power));\r\n    if (thisVar.value < 1) {\r\n      thisVar.value = 1;\r\n    }\r\n    if (thisVar.base < 1) {\r\n      thisVar.base = 1;\r\n    }\r\n    if (thisVar.power < 1) {\r\n      thisVar.power = 1;\r\n    }\r\n    controlledModule.loopLength.value = thisVar.value;\r\n    controlledModule.handleStepsChange();\r\n  }\r\n\r\n  this.outsideScroll = function(event) {\r\n    var change=configurators.time.vars[\"fold\"];\r\n    // console.log(event);\r\n    change.selectFunction(change);\r\n    change.changeFunction(change,event.delta);\r\n    var ret=\"fold:\"+change.nameFunction(change);\r\n    return (ret);\r\n  }\r\n\r\n  configurators.time.vars[\"loop look\"].nameFunction = function (thisVar) {\r\n    return (thisVar.value == 0 ? \"off\" : \"\" + thisVar.value);\r\n  };\r\n  configurators.time.vars[\"loop look\"].changeFunction = function (thisVar, delta) {\r\n    if (thisVar.value + delta >= 0)\r\n      thisVar.value += delta;\r\n  }\r\n  configurators.time.vars[\"page\"].changeFunction = function (thisVar, delta) {\r\n    if (thisVar.value + delta >= 0)\r\n      thisVar.value += delta;\r\n    thisVar.value = thisVar.value % controlledModule.loopLength.value;\r\n    currentViewStartStep = thisVar.value * 16;\r\n\r\n  }\r\n\r\n  configurators.time.vars[\"drift substep\"].nameFunction = function (thisVar) {\r\n    return (thisVar.value > 0 ? \"+\" : \" \") + thisVar.value;\r\n  };\r\n  // configurators.time.vars[\"time displace\"].changeFunction = function(thisVar,delta){\r\n  //   if(thisVar.value+delta>=0)\r\n  //   thisVar.value+=delta;\r\n  // }\r\n  configurators.time.vars[\"microstep offset\"].nameFunction = function (thisVar) {\r\n    return thisVar.value + \"/\" + controlledModule.microStepDivide.value;\r\n  };\r\n\r\n  configurators.time.vars[\"playing\"].changeFunction = function (thisVar, delta) {\r\n    if (delta > 0) {\r\n      thisVar.value = true;\r\n    } else {\r\n      thisVar.value = false;\r\n    }\r\n  }\r\n  configurators.time.vars[\"stoppable\"].changeFunction = function (thisVar, delta) {\r\n    thisVar.value = !thisVar.value;\r\n  }\r\n\r\n  configurators.time.vars[\"rec mode\"].changeFunction = function (thisVar, delta) {\r\n    var possible = controlledModule.recordSettings.namesList.length;\r\n    thisVar.value = controlledModule.recordSettings.mode;\r\n    thisVar.value += delta;\r\n    if (thisVar.value < 0) thisVar.value = possible - 1;\r\n    thisVar.value %= possible;\r\n    controlledModule.recordSettings.mode = thisVar.value;\r\n  }\r\n  configurators.time.vars[\"rec mode\"].nameFunction = function (thisVar) {\r\n    return controlledModule.recordSettings.namesList[thisVar.value] || \"nothing\";\r\n  }\r\n  configurators.time.vars[\"on rec end\"].nameFunction = configurators.time.vars[\"rec mode\"].nameFunction;\r\n  configurators.time.vars[\"on rec end\"].changeFunction = function (thisVar, delta) {\r\n    var possible = controlledModule.recordSettings.namesList.length;\r\n    thisVar.value = controlledModule.recordSettings.switchOnEnd;\r\n    thisVar.value += delta;\r\n    if (thisVar.value < 0) thisVar.value = possible;\r\n    thisVar.value %= possible + 1;\r\n    controlledModule.recordSettings.switchOnEnd = thisVar.value;\r\n    if (thisVar.value > possible) {\r\n      controlledModule.recordSettings.switchOnEnd = false;\r\n    }\r\n  }\r\n\r\n  function eachFold(button, callback) {\r\n    var len = loopLength.value;\r\n    var look = lookLoop.value || len;\r\n    button %= look;\r\n    //how many repetitions of the lookloop are represented under this button?\r\n    var stepFolds;\r\n    if (len % look > button) {\r\n      stepFolds = Math.ceil(len / look);\r\n    } else {\r\n      stepFolds = Math.floor(len / look);\r\n    }\r\n    // console.log(\"start check folds:\"+stepFolds+\" len:\"+len+\" look:\"+look);\r\n    for (var foldNumber = 0; foldNumber < stepFolds; foldNumber++) {\r\n      callback((look * foldNumber) + button);\r\n    }\r\n    return {\r\n      stepFolds: stepFolds\r\n    }\r\n  }\r\n\r\n  //does the event under the button repeat througout all the repetitions of lookLoop?\r\n  var getThroughfoldBoolean = function (button, filterFunction) {\r\n    var ret = 0;\r\n    var stepFolds = eachFold(button, function (step) {\r\n      if (controlledModule.patData[step])\r\n        if (typeof filterFunction === \"function\") {\r\n          //yes, every step is an array\r\n          for (var stepData of controlledModule.patData[step]) {\r\n            if (filterFunction(stepData)) ret++;\r\n          }\r\n        } else {\r\n          // console.log(\"   check bt\"+step);\r\n          for (var stepData of controlledModule.patData[step]) {\r\n            if (controlledModule.patData[step] || false) ret++;\r\n          }\r\n        }\r\n    }).stepFolds;\r\n    //if the step was repeated throughout all the folds, the return is true.\r\n    if (ret >= stepFolds) ret = true; //ret can be higher than twofold because each step can hold any n of events\r\n    // console.log(\"ret is \"+ret);\r\n    return ret;\r\n  };\r\n\r\n  var getBitmapx16 = function (filter, requireAllFold, representLength) {\r\n    var ret = 0x0000;\r\n    let buttonStart = currentViewStartStep;\r\n    if (requireAllFold) {\r\n      for (var button = 0; button < 16; button++)\r\n        if (getThroughfoldBoolean(button + buttonStart, filter) === requireAllFold) ret |= 0x1 << button;\r\n    } else {\r\n      if (filter) {\r\n        for (var button = 0; button < 16; button++)\r\n          if (controlledModule.patData[button + buttonStart])\r\n            for (var stepData of controlledModule.patData[button + buttonStart])\r\n              if (filter(stepData)) {\r\n                /*  if(representLength){\r\n                    ret|=~(0xffff<<stepData.stepLength)<<button;\r\n                    // console.log(\"*-l\",stepData.stepLength);\r\n                  }else{*/\r\n                ret |= 0x1 << button;\r\n                /*  }*/\r\n              }\r\n      } else {\r\n        for (var button = 0; button < 16; button++)\r\n          if (controlledModule.patData[button + buttonStart])\r\n            for (var stepData of controlledModule.patData[button + buttonStart])\r\n              if (stepData) {\r\n                ret |= 0x1 << button;\r\n              }\r\n      }\r\n    }\r\n    // console.log(\">\"+ret.toString(16));\r\n    return ret;\r\n  }\r\n\r\n\r\n\r\n  controlledModule.on('noteOnRecorded', function (event) {\r\n    configurators.event.setFromEventPattern(event.eventPattern);\r\n  });\r\n  controlledModule.on('step', function (event) {\r\n\r\n    if (!engagedConfigurator)\r\n      for (let hardware of engagedHardwares) {\r\n        if (engagedConfigurator === false)\r\n          self.updateLeds(hardware);\r\n        self.updatePageDisplay(hardware);\r\n      }\r\n    // loopDisplace.value=controlledModule.loopDisplace.value;\r\n  });\r\n\r\n  this.matrixButtonPressed = function (event) {\r\n    // console.log(event.data);\r\n    var button = event.button;\r\n    var targetButton = button + currentViewStartStep;\r\n    var hardware = event.hardware;\r\n    if (skipMode) {\r\n      controlledModule.restart(targetButton);\r\n\r\n    } else if (engagedConfigurator === false) {\r\n      var currentFilter = shiftPressed ? moreBluredFilter : bluredFilter;\r\n      var throughfold = getThroughfoldBoolean(targetButton, currentFilter);\r\n      // console.log(\"THEREIS\",throughfold);\r\n      //if shift is pressed, there is only one repetition throughfold required, making the edition more prone to delete.\r\n      if (shiftPressed) {\r\n        if (throughfold !== true) throughfold = throughfold > 0;\r\n      } else {\r\n        throughfold = throughfold === true;\r\n      }\r\n      // console.log(throughfold);\r\n      if (throughfold) {\r\n        var removedEvent = false;\r\n        //there is an event on every fold of the lookloop\r\n        eachFold(targetButton, function (step) {\r\n          removedEvent = controlledModule.clearStepByFilter(step, currentFilter)\r\n        });\r\n\r\n        if (removedEvent && shiftPressed) {\r\n          // console.log(removedEvent);\r\n          configurators.event.setFromEventPattern(removedEvent[0], event.hardware);\r\n          lastEngagedConfigurator = configurators.event;\r\n        }\r\n      }\r\n      /*else if(trhoughFold>0){\r\n                //there is an event on some folds of the lookloop\r\n                var newStepEv=configurators.event.getEventPattern();\r\n                eachFold(button,function(step){\r\n                  store(step,newStepEv);\r\n                });\r\n              }*/\r\n      else {\r\n        //on every repetition is empty\r\n        var targetEventPattern = configurators.event.getEventPattern();\r\n\r\n        noteLengthner.startAdding(targetButton, targetEventPattern);\r\n\r\n        noteLengthnerStartPointsBitmap |= 0x1 << button;\r\n        noteLengthnerLengthsBitmap = noteLengthnerStartPointsBitmap;\r\n      }\r\n      self.updateLeds(hardware);\r\n    } else {\r\n\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    } // console.log(event.data);\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    var targetButton = event.button + currentViewStartStep;\r\n    noteLengthner.finishAdding(targetButton, function (differenciator, sequencerEvent, nicCount) {\r\n      eachFold(differenciator, function (step) {\r\n        /*var added=*/\r\n        controlledModule.storeNoDup(step, sequencerEvent);\r\n      });\r\n      if (nicCount == 0) {\r\n        noteLengthnerStartPointsBitmap = 0;\r\n        noteLengthnerLengthsBitmap = 0;\r\n      }\r\n      // console.log(nicCount);\r\n    } /*,configurators.event.getEventPattern()*/);\r\n\r\n\r\n\r\n    if (engagedConfigurator === false) {\r\n      self.updateLeds(hardware);\r\n    } else {\r\n\r\n      engagedConfigurator.matrixButtonPressed(event);\r\n    }\r\n  };\r\n  this.matrixButtonHold = function (event) { };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n\r\n    if (engagedConfigurator)\r\n      engagedConfigurator.selectorButtonPressed(event);\r\n    // console.log(event);\r\n    //keep trak of pressed buttons for button combinations\r\n    configuratorsPressed[event.data[0]] = true;\r\n    if (configuratorsPressed[0] && configuratorsPressed[1] || configuratorsPressed[3] && configuratorsPressed[1]) {\r\n      if (lastEngagedConfigurator)\r\n        lastEngagedConfigurator.disengage(event);\r\n      lastEngagedConfigurator = engagedConfigurator = false;\r\n      skipMode = true;\r\n      hardware.sendScreenA(\"skip to step\");\r\n      self.updateLeds(hardware);\r\n    } else if (event.data[0] == 1) {\r\n      /**TODO: use configurator objects instead of their names**/\r\n      engagedConfigurator = configurators.event;\r\n      lastEngagedConfigurator = configurators.event;\r\n      configurators.event.engage(event);\r\n    } else if (event.data[0] == 2) {\r\n      engagedConfigurator = configurators.time;\r\n      lastEngagedConfigurator = configurators.time;\r\n      engagedConfigurator.engage(event);\r\n    } else if (event.data[0] == 0 || event.data[0] == 3) {\r\n      if (lastEngagedConfigurator)\r\n        lastEngagedConfigurator.disengage(event);\r\n      lastEngagedConfigurator = engagedConfigurator = false;\r\n      shiftPressed = true;\r\n      hardware.sendScreenA(\"select through\");\r\n      self.updateLeds(hardware);\r\n    } else if (event.data[0] >= 4) {\r\n      var wouldPage = (event.data[0] - 4) * 16;\r\n      //pressed the same button for a second time, and is one of both extreme buttons\r\n      // if(currentViewStartStep==wouldPage){\r\n      //   if(event.data[0]==7){\r\n      //     currentViewStartStep+=16;\r\n      //   }else if(event.data[0]==4){\r\n      //     if (currentViewStartStep>=0){\r\n      //       currentViewStartStep-=16;\r\n      //     }\r\n      //   }\r\n      // }else{\r\n      currentViewStartStep = wouldPage;\r\n      self.updatePageDisplay(event.hardware);\r\n      // }\r\n    } else if (event.data[0] >= 8) {\r\n      engagedConfigurator = configurators.record;\r\n      lastEngagedConfigurator = configurators.record;\r\n      engagedConfigurator.engage(event);\r\n    }\r\n\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n    configuratorsPressed[event.data[0]] = false;\r\n\r\n    skipMode = false;\r\n    shiftPressed = false;\r\n\r\n    if (engagedConfigurator) {\r\n      engagedConfigurator.selectorButtonReleased(event);\r\n      engagedConfigurator.disengage(event);\r\n      engagedConfigurator = false;\r\n    }\r\n\r\n    updateHardware(hardware);\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    var hardware = event.hardware;\r\n    if (lastEngagedConfigurator) {\r\n      lastEngagedConfigurator.encoderScrolled(event);\r\n    }\r\n    self.updateLeds(hardware);\r\n  };\r\n  this.encoderPressed = function (event) { };\r\n  this.encoderReleased = function (event) { };\r\n  this.engage = function (event) {\r\n    var hardware = event.hardware;\r\n    engagedHardwares.add(event.hardware);\r\n    updateHardware(event.hardware);\r\n    // hardware.sendScreenA(controlledModule.name);\r\n\r\n    //when you record from a preset kit, and then search the Sequencer\r\n    //it can get really hard to find the sequencer if they don't show the\r\n    //recording by defaut\r\n    if (lastRecordedNote) {\r\n      // console.log(\"lastRecordedNote\",lastRecordedNote);\r\n      //this will update the output list in the sequencer, otherwise it may have a value out of array\r\n      configurators.event.options[0].valueNames(0);\r\n      configurators.event.setFromEventPattern(lastRecordedNote);\r\n      lastRecordedNote = false;\r\n    }\r\n    self.updateLeds(hardware);\r\n    self.updatePageDisplay(hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    engagedHardwares.delete(event.hardware);\r\n  }\r\n\r\n  //feedback functions\r\n  var updateHardware = function (hardware) {\r\n    // hardware.sendScreenA(controlledModule.name);\r\n    self.updateLeds(hardware);\r\n  }\r\n  // var self.updateLeds=function(hardware){\r\n  //   stepsBmp=getBitmap16();\r\n  //   hardware.draw([playHeadBmp,playHeadBmp|stepsBmp,stepsBmp]);\r\n  // }\r\n\r\n  var focusedFilter = new configurators.event.Filter({\r\n    header: true,\r\n    value_a: true,\r\n    value_b: true\r\n  });\r\n  var bluredFilter = new configurators.event.Filter({\r\n    header: true,\r\n    value_a: true\r\n  });\r\n  var moreBluredFilter = new configurators.event.Filter({\r\n    header: true\r\n  });\r\n  var filterNone = new configurators.event.Filter({\r\n  });\r\n  this.updatePageDisplay = function (hardware) {\r\n    var currentPageBmp = (1 << (Math.floor(currentViewStartStep / 16))) & 0xF;\r\n    var playheadPageBmp = (1 << (Math.floor(currentStep.value / 16))) & 0xF;\r\n    hardware.paintColorFromLedN([currentPageBmp], [255, 255, 255], 4);\r\n    hardware.paintColorFromLedN([playheadPageBmp & ~currentPageBmp], [127, 127, 0], 4);\r\n    hardware.paintColorFromLedN([(currentPageBmp | playheadPageBmp) ^ 0xF], [0, 0, 0], 4);\r\n  }\r\n  self.updateLeds = function (hardware) {\r\n    //actually should display also according to the currently being tweaked\r\n    var showThroughfold = lastEngagedConfigurator == configurators.time;\r\n    var mostImportant = getBitmapx16(shiftPressed ? moreBluredFilter : focusedFilter, showThroughfold);\r\n    var mediumImportant = getBitmapx16(bluredFilter, showThroughfold);\r\n    mediumImportant |= noteLengthnerStartPointsBitmap;\r\n    var leastImportant = getBitmapx16(moreBluredFilter, false, !shiftPressed);\r\n    var everyEvent = getBitmapx16(filterNone, false, false);\r\n    leastImportant |= noteLengthnerLengthsBitmap;\r\n    var drawStep = 0;\r\n    var playHeadBmp = 0;\r\n\r\n    //\"render\" play header:\r\n    //if we are in modulus view, it renders many playheads\r\n    if (lastEngagedConfigurator == \"time\") {\r\n      drawStep = currentStep.value % (lookLoop.value || loopLength.value);\r\n      var stepFolds = Math.ceil(loopLength.value / (lookLoop.value || loopLength.value));\r\n      for (var a = 0; a < stepFolds; a++) {\r\n        playHeadBmp |= 0x1 << drawStep + a * (lookLoop.value || loopLength.value);\r\n      }\r\n      playHeadBmp &= 0xFFFF;\r\n    } else {\r\n      //otherwise, normal one header\r\n      drawStep = currentStep.value % loopLength.value;\r\n      var playHeadBmp = 0x1 << (drawStep + currentViewStartStep);\r\n    }\r\n\r\n    hardware.draw([\r\n      (playHeadBmp ^ mostImportant) | (shiftPressed ? (everyEvent ^ mediumImportant) : 0),\r\n      playHeadBmp | mostImportant | mediumImportant,\r\n      mostImportant | mediumImportant | leastImportant,\r\n    ]);\r\n\r\n    return [mostImportant, mediumImportant, leastImportant, everyEvent];\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/InterfaceX16.js?");

/***/ }),

/***/ "./src/modules/Sequencer/index.js":
/*!****************************************!*\
  !*** ./src/modules/Sequencer/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Recorder = __webpack_require__(/*! ./sequencerGuts/record.js */ \"./src/modules/Sequencer/sequencerGuts/record.js\");\r\n// var clockSpec=require('../standards/clock.js');\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventPattern=__webpack_require__(/*! ./EventPattern.js */ \"./src/modules/Sequencer/EventPattern.js\");\r\nvar InterfaceX16 = __webpack_require__(/*! ./InterfaceX16 */ \"./src/modules/Sequencer/InterfaceX16.js\");\r\n\r\n// const fs = require('fs');\r\n// console.log(fs);\r\n// var InterfaceX28 = require('./InterfaceX28');\r\nvar headers = EventMessage.headers;\r\n\r\n\r\nconst sequencerFunctions = __webpack_require__(/*! ./sequencerGuts */ \"./src/modules/Sequencer/sequencerGuts/index.js\");\r\n/**\r\nSequencer\r\nTODO: module naming functions should be a static property, and thus defaults to \"name+number\"\r\n*/\r\nvar testcount = 0;\r\nvar testGetName = function () {\r\n  this.name = baseName + \" \" + testcount;\r\n  testcount++;\r\n}\r\nvar baseName = \"sequencer\";\r\n\r\nvar Sequencer = function (properties, environment) {\r\n  var fs=environment.fs;\r\n  testGetName.call(this);\r\n  if (properties.name) this.name = properties.name;\r\n\r\n  var currentStep = {\r\n    value: 0\r\n  };\r\n  this.currentStep = currentStep;\r\n  var recorder = new Recorder(this);\r\n  var self = this;\r\n  this.patData = {};\r\n  var currentModulus = 16;\r\n  this.loopLength = {\r\n    value: 16,\r\n    lastWatchedValue: 16\r\n  };\r\n  this.stepLength = {\r\n    value: 12\r\n  }\r\n  this.listenTransport = {\r\n    value: false\r\n  }\r\n  this.recordSettings = {\r\n    mode: 3,\r\n    namesList: ['overdub', 'grow', 'fold', 'adjust'/*,stop*/],\r\n    growStep: 16,\r\n    recording: false,\r\n    switchOnEnd: 0,\r\n  }\r\n  let recordSettings = this.recordSettings;\r\n\r\n  this.noteLenManager = sequencerFunctions.NoteLenManager(this);\r\n  var patchMem = sequencerFunctions.PatchMem(this);\r\n  //import \"gut\" functions to my own;\r\n  //I don't use an iterator to have more clear control of the namespace\r\n  //but in some text tools you can always multiline edit\r\n  this.store = patchMem.store;\r\n  this.loopDisplace = patchMem.loopDisplace;\r\n  this.storeNoDup = patchMem.storeNoDup;\r\n  this.clearStepNewest = patchMem.clearStepNewest;\r\n  this.clearStepOldest = patchMem.clearStepOldest;\r\n  this.clearStep = patchMem.clearStep;\r\n  this.clearStepByFilter = patchMem.clearStepByFilter;\r\n  this.getBoolean = patchMem.getBoolean;\r\n  this.stepDivide = patchMem.stepDivide;\r\n  this.microStep = patchMem.microStep;\r\n  this.microStepDivide = patchMem.microStepDivide;\r\n  this.microStepDisplace = patchMem.microStepDisplace\r\n  // this.eachFold=patchMem.eachFold;\r\n  // this.getThroughfoldBoolean=patchMem.getThroughfoldBoolean;\r\n  this.clearStepRange = patchMem.clearStepRange;\r\n  this.duplicateSequence = patchMem.duplicateSequence;\r\n  this.offsetSequence = patchMem.offsetSequence;\r\n  this.sequenceBounds = patchMem.sequenceBounds;\r\n  // this.getBitmapx16=patchMem.getBitmapx16;\r\n  this.step = patchMem.step;\r\n  this.restart = patchMem.restart;\r\n  this.stepAbsolute = patchMem.stepAbsolute;\r\n  this.playing = patchMem.playing;\r\n  // this.stepIncremental=patchMem.stepIncremental;\r\n  this.stepMicro = patchMem.stepMicro;\r\n  var thisInstance = this;\r\n\r\n  this.compensatedOffsetSequence = function (steps) {\r\n    self.offsetSequence(steps);\r\n    currentStep.value += steps;\r\n  }\r\n  this.trimSequence = function (grid = 1) {\r\n    var bounds = self.sequenceBounds();\r\n    //quantize trim to grid\r\n    console.log(\"sequence bounds\",bounds);\r\n\r\n    bounds.start = Math.round(bounds.start / grid) * grid;\r\n    bounds.end = Math.round(bounds.end / grid) * grid;\r\n\r\n    //trim first and last chunks\r\n\r\n    // bounds.start += grid;\r\n    // bounds.end -= grid;\r\n\r\n\r\n    self.loopLength.value = bounds.end -bounds.start;\r\n\r\n    console.log(\"trim from step\", bounds.start,\"to\",bounds.end);\r\n    if (bounds.start > 0) {\r\n      self.compensatedOffsetSequence(-bounds.start);\r\n    }\r\n\r\n\r\n  }\r\n\r\n  this.onPatchStep = function (evt) {\r\n    if (recordSettings.recording) {\r\n      if (currentStep.value >= self.loopLength.value - 2) {\r\n        switch (recordSettings.mode) {\r\n          case 1: {\r\n            // console.log(\"Grow \");\r\n            self.loopLength.value += recordSettings.growStep;\r\n            break;\r\n          } case 2: {\r\n            // console.log(\"Fold\");\r\n            self.loopLength.value *= 2;\r\n            break;\r\n          } case 3: {\r\n            // console.log(\"adjust\");\r\n            self.loopLength.value += recordSettings.growStep;\r\n            break;\r\n          }/*case :{\r\n              console.log(\"Stop\");\r\n              controlledModule.loopLength.value *= 2;\r\n              break;\r\n            }*/\r\n          // default: console.log(\"overdub\");\r\n        }\r\n      }\r\n    }\r\n    this.handle('step', evt);\r\n    if (self.loopLength.lastWatchedValue != self.loopLength.value) {\r\n      this.handleStepsChange();\r\n    }\r\n  }\r\n  // selfm.on('~module',console.log);\r\n  this.handleStepsChange = function () {\r\n    // console.log(\"STEPCHANGE\");\r\n    self.handle('~module', { steps: self.loopLength.value });\r\n    self.loopLength.lastWatchedValue = self.loopLength.value;\r\n  }\r\n  this.play = function () {\r\n    thisInstance.playing.value = true;\r\n    // thisInstance.restart();\r\n  }\r\n  this.stop = function () {\r\n    thisInstance.playing.value = false;\r\n  }\r\n  /**\r\n\r\n\r\n  # module interpretation of eventMessages:\r\n  [header,data1,data2]\r\n  * Header is 0: eventMessage is a clock tick\r\n    * A indicates how many clocks makes one step. i.e. source clock rate is bpm*4\r\n    * B indicates what clock number is the current clock number\r\n  * Header is 1: set the playhead to a position indicated by data2, set the state to play (not implemented yet)\r\n  * Header is 2: stop playing (not implemented yet)\r\n  * Header is 3: jump playhead to position indicated by data 2, but don't change the playing state (not implemented yet)\r\n\r\n  * Header is 70: request of stored data, it will trigger a data response. Not implemented yet\r\n\r\n  */\r\n  this.recordingReceived = function (event) {\r\n    var evt = event.eventMessage;\r\n    // if(evt.value[0]!=headers.clockTick) console.log(evt);\r\n    // console.log(evt.value);\r\n    switch (evt.value[0]) {\r\n      case headers.record: {\r\n        // console.log(\"sq:headers.record\");\r\n        // console.log(evt.value);\r\n        // console.log(\"REC\");\r\n        evt.value.shift();\r\n        // console.log(evt.value[0]);\r\n        if (evt.value[0] == headers.triggerOn) {\r\n          recorder.recordNoteStart([evt.value[1], evt.value[2]], evt);\r\n          // console.log(\"ON\",[evt.value[1],evt.value[2]]);\r\n        } else if (evt.value[0] == headers.triggerOff) {\r\n          recorder.recordNoteEnd([evt.value[1], evt.value[2]]);\r\n        } else {\r\n          recorder.recordSingularEvent(evt);\r\n        }\r\n        // thisInstance.recorder.start();\r\n        break;\r\n      } case headers.recordStatus: {\r\n        recordSettings.recording = evt.value[1];\r\n        if (!recordSettings.recording) {\r\n\r\n          if (recordSettings.mode == 3) {\r\n            //trimSequence uses the loopLength, so it must be floored\r\n            if (self.loopLength.value > recordSettings.growStep) {\r\n              self.loopLength.value -= recordSettings.growStep;\r\n            }\r\n            self.trimSequence(recordSettings.growStep / 2, true);\r\n            //quantize length to the growStep\r\n            if (self.loopLength.value > recordSettings.growStep) {\r\n              self.loopLength.value -= self.loopLength.value % recordSettings.growStep;\r\n            }\r\n            //prevent negative or zero length sequences\r\n            if (self.loopLength.value < recordSettings.growStep) {\r\n              self.loopLength.value = recordSettings.growStep;\r\n            }\r\n          }\r\n\r\n          if (recordSettings.switchOnEnd !== false) {\r\n            recordSettings.mode = recordSettings.switchOnEnd;\r\n          }\r\n        }\r\n        // console.log(\"RECSTATUS\",evt.value);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  this.listSequenceFiles=function(){\r\n    const folder = './patches/Sequencer/';\r\n    // console.log(fs);\r\n    return new Promise((sux,rej)=>{\r\n      var flist=[];\r\n      fs.readdir(folder, (err, files) => {\r\n        if(err){\r\n          console.log(err);\r\n          rej(err);\r\n          return err;\r\n        }\r\n        files.forEach(file => {\r\n          console.log(file);\r\n          flist.push(file);\r\n        });\r\n        sux(flist);\r\n      });\r\n    });\r\n  }\r\n  this.loadSequenceFile=function(fname){\r\n    var content;\r\n    console.log(\"load sequence\");\r\n    return new Promise((sux,rej)=>{\r\n      fs.readFile(\"./patches/Sequencer/\"+fname, function read(err, data) {\r\n          if (err) {\r\n              console.log( err);\r\n              rej(err);\r\n              return;\r\n          }\r\n          var data=JSON.parse(data);\r\n          for(var stepn in data){\r\n            console.log(\"load step\",stepn);\r\n            for(var evPatN in data[stepn]){\r\n              console.log(\"load evt\",data[stepn][evPatN]);\r\n\r\n              patchMem.storeNoDup(stepn,new EventPattern(data[stepn][evPatN]));\r\n            }\r\n          }\r\n          sux(self.patData);\r\n        });\r\n    });\r\n  }\r\n  this.saveSequenceFile=function(fname){\r\n    return new Promise((sux,rej)=>{\r\n      var writePatData=JSON.parse(JSON.stringify(self.patData));\r\n      for(var stepn in writePatData){\r\n        for(var evPatN in writePatData[stepn]){\r\n          writePatData[stepn][evPatN].on.isEventMessage=false;\r\n          delete writePatData[stepn][evPatN].on.isEventMessage;\r\n          writePatData[stepn][evPatN].off.isEventMessage=false;\r\n          delete writePatData[stepn][evPatN].off.isEventMessage;\r\n        }\r\n      }\r\n      fs.writeFile(\"./patches/Sequencer/\"+fname, JSON.stringify(writePatData,null,'\\t'), function(err) {\r\n          if(err) {\r\n            rej(err);\r\n            return console.log(err);\r\n          }\r\n          sux();\r\n          console.log(\"The file was s\");\r\n        });\r\n    });\r\n  }\r\n  // x71: data response\r\n  this.messageReceived = function (event) {\r\n    var evt = event.eventMessage;\r\n    // if(evt.value[0]!=headers.clockTick) console.log(evt);\r\n    // console.log(evt.value);\r\n    switch (evt.value[0]) {\r\n      case headers.clockTick: {\r\n        // console.log(\"sq:headers.clockTick\");\r\n        thisInstance.stepMicro(evt.value[1], evt.value[2]);\r\n        thisInstance.lastMicroStepBase = evt.value[1];\r\n        // console.log(\"0 stepMicro(\"+evt.value[1]+\",\"+evt.value[2]+\");\");\r\n        break;\r\n      }\r\n      case headers.triggerOn: {\r\n        // console.log(\"sq:headers.triggerOn\");\r\n        thisInstance.stepAbsolute(evt.value[1]);\r\n        if (self.listenTransport.value) {\r\n          thisInstance.play();\r\n        }\r\n        // console.log(\"1 thisInstance.stepAbsolute(\"+evt.value[1]+\");\");\r\n        break;\r\n      } case headers.triggerOff: {\r\n        // console.log(\"sq:headers.triggerOff\");\r\n        if (self.listenTransport.value) {\r\n          thisInstance.stop();\r\n        }\r\n        // console.log(\"2 stop\");\r\n        break;\r\n      }\r\n        this.handle('receive', evt);\r\n    }\r\n  }\r\n  this.interfaces.X16 = InterfaceX16;\r\n  // this.interfaces.X28 = InterfaceX28;\r\n  this.interfaces.Http = __webpack_require__(/*! ./InterfaceHttp.js */ \"./src/modules/Sequencer/InterfaceHttp.js\");\r\n\r\n}\r\nSequencer.color = [0, 0, 255];\r\nmodule.exports = Sequencer\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/index.js?");

/***/ }),

/***/ "./src/modules/Sequencer/sequencerGuts/NoteLenManager.js":
/*!***************************************************************!*\
  !*** ./src/modules/Sequencer/sequencerGuts/NoteLenManager.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=function(sequencerModule){ return new(function(){\r\n  var notesInCreation=[];\r\n  var notesInPlay=[];\r\n  var stepCounter=0;\r\n\r\n  this.noteStarted=function(stepEvent){\r\n    if(!stepEvent.stepLength)stepEvent.stepLength=1;\r\n    notesInPlay.push({sequencerEvent:stepEvent,offInStep:stepCounter+stepEvent.stepLength});\r\n  }\r\n  this.step=function(evt){\r\n    for(var a in notesInPlay){\r\n      if(notesInPlay[a].offInStep==stepCounter){\r\n        if(notesInPlay[a].sequencerEvent.off){\r\n          sequencerModule.output(notesInPlay[a].sequencerEvent.off,true);\r\n          notesInPlay[a]=false;\r\n        }\r\n      }\r\n    }\r\n    //splicing requires backward iteration\r\n    var a=notesInPlay.length;\r\n    while(a>0){\r\n      if(notesInPlay[a]===false)\r\n        notesInPlay.splice(a,1);\r\n      a--;\r\n    }\r\n    stepCounter++;\r\n  }\r\n})();};\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/sequencerGuts/NoteLenManager.js?");

/***/ }),

/***/ "./src/modules/Sequencer/sequencerGuts/NoteLengthner.js":
/*!**************************************************************!*\
  !*** ./src/modules/Sequencer/sequencerGuts/NoteLengthner.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\nobject that keeps track of the length of all the notes that are being created, in order to add the note ends in their corresponding times in the sequencer.\r\n*/\r\nvar NoteLengthner=module.exports=function(controlledModule){\r\n  var thisNoteLengthner=this;\r\n\r\n  var notesInCreation=[];\r\n  //count of notes in creation\r\n  var nicCount=0;\r\n  var stepCounter=0;\r\n  this.startAdding=function(differenciator,newStepEv){\r\n    if(!newStepEv.stepLength){\r\n      newStepEv.stepLength=1;\r\n    }\r\n    notesInCreation[differenciator]={sequencerEvent:newStepEv,started:stepCounter};\r\n    nicCount++;\r\n    // console.log(notesInCreation[differenciator]);\r\n  }\r\n  this.finishAdding=function(differenciator,storeCallback=false){\r\n    if(notesInCreation[differenciator]){\r\n\r\n      notesInCreation[differenciator].sequencerEvent.stepLength=stepCounter-notesInCreation[differenciator].started;\r\n      nicCount--;\r\n      if(storeCallback){\r\n        //TODO: these callback parameters are stupid, perhaps should pass an object instead of many parameters\r\n        storeCallback(differenciator,notesInCreation[differenciator].sequencerEvent,nicCount);\r\n      }else{\r\n        console.warn(\"noteLengthner didn't have a sequencer event store function, which defeats the purpose of the noteLengthner\");\r\n      }\r\n      // console.log(notesInCreation[differenciator]);\r\n      delete notesInCreation[differenciator];\r\n    }\r\n  }\r\n  var stepCallback=false;\r\n  function step(){\r\n    stepCounter++;\r\n  }\r\n  controlledModule.on('step',function(event){\r\n    step();\r\n    if(stepCallback){\r\n      stepCallback(thisNoteLengthner,nicCount);\r\n    }\r\n  });\r\n  this.onStep=function(nStepCallback){\r\n    stepCallback=nStepCallback;\r\n  }\r\n};\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/sequencerGuts/NoteLengthner.js?");

/***/ }),

/***/ "./src/modules/Sequencer/sequencerGuts/PatchMem.js":
/*!*********************************************************!*\
  !*** ./src/modules/Sequencer/sequencerGuts/PatchMem.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar EventMessage=__webpack_require__(/*! ../../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventPattern=__webpack_require__(/*! ../EventPattern.js */ \"./src/modules/Sequencer/EventPattern.js\");\r\n\r\nmodule.exports=function(sequencerModule){ return new(function(){\r\n  var self=this;\r\n  /**\r\n  whether module is playing\r\n  */\r\n  self.playing={value:true};\r\n\r\n  //the \"invisible\" sub-unit of a step, good for recording quantization and midi clock input\r\n  var microStep={value:0};\r\n  this.microStep=microStep;\r\n  this.microStepDisplace={value:0};\r\n  var microStepDivide={value:12};\r\n  this.microStepDivide=microStepDivide;\r\n\r\n  this.useMicroDelay=true;\r\n\r\n  //the visible step that can be divided if the user wants a slower sequence\r\n  var substep={value:0};\r\n  var stepDivide={value:1}\r\n  this.stepDivide=stepDivide;\r\n\r\n  //the step that is used to read the pattern memory\r\n  var currentStep=sequencerModule.currentStep;\r\n\r\n  var loopLength=sequencerModule.loopLength;\r\n  var patData=sequencerModule.patData;\r\n  var loopDisplace={value:0};\r\n  this.loopDisplace=loopDisplace;\r\n  var store=function(step,data){\r\n    if(!patData[step]) patData[step]=[];\r\n    if(data){\r\n      patData[step].push(data);\r\n      return data;\r\n    }\r\n  }\r\n  /**\r\n\r\n  store a EventPattern in the sequencer memory ensuring that the event doesn't already exist in that step\r\n  @param {numbar} step the step where the EventPattern will be stored\r\n  @param {EventPattern} data the EventPattern to store\r\n  @returns stored data, or false if data was already found and not stored\r\n  */\r\n  var storeNoDup=function(step,data){\r\n    if(!patData[step]) patData[step]=[];\r\n    if(data){\r\n      var replace=false;\r\n      for(var a in patData[step]){\r\n        try{\r\n          if(patData[step][a].on.compareTo(data.on,['value.0','value.1','value.2'])){\r\n            // console.log(\"DUP!\");\r\n            replace=a;\r\n            break;\r\n          }\r\n        }catch(e){\r\n          // console.log(patData[step]);\r\n          // console.log(e);\r\n        }\r\n      }\r\n      if(replace===false){\r\n        patData[step].push(data);\r\n        return data;\r\n      }else{\r\n        patData[step][replace]=data;\r\n      }\r\n      return !replace;\r\n    }else{\r\n      console.error(\"wrong storeNoDup data is \",data);\r\n    }\r\n  }\r\n  var clearStepNewest=function(step){\r\n    patData[step].pop();\r\n  }\r\n  var clearStepOldest=function(step){\r\n    patData[step].shift();\r\n  }\r\n  var clearStep=function(step){\r\n    delete patData[step];\r\n  }\r\n  var clearStepByFilter=function(step,filterFunction){\r\n    if(patData[step])\r\n      if(typeof filterFunction===\"function\"){\r\n        for(var sEvt in patData[step]){\r\n          if(filterFunction(patData[step][sEvt])){\r\n            return patData[step].splice(sEvt,1);\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n    return false;\r\n  }\r\n  var getBoolean=function(step,filterFunction){\r\n    if(patData[step])\r\n      if(typeof filterFunction===\"function\"){\r\n        //yes, every step is an array\r\n        for(var stepData of patData[step]){\r\n          if(filterFunction(stepData))\r\n            return true;\r\n          return false;\r\n        }\r\n      }else{\r\n        for(var stepData of patData[step]){\r\n          if(patData[step]||false)\r\n            return true;\r\n          return false;\r\n        }\r\n      }\r\n    return false;\r\n  };\r\n\r\n  var clearStepRange=function(from,to){\r\n    console.log(\"CLR\",from,to);\r\n    for(var step=to; step>from; step--){\r\n      //maybe this iteration is unnecesary?\r\n      for(var a in patData[step]){\r\n        delete patData[step][a];\r\n      }\r\n      delete patData[step];\r\n    }\r\n  }\r\n  var sequenceBounds=function(){\r\n    var ret={start:0,end:0}\r\n    for(let step in patData){\r\n      if(!ret.start){\r\n        ret.start=step;\r\n      }\r\n      ret.end=step;\r\n      if(step>loopLength.value){\r\n        return ret;\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n  var offsetSequence=function(steps){\r\n    let newSequence=[];\r\n    // console.log(\"OFFSETOP\",steps);\r\n    // clearStepRange(0,-steps);\r\n    for(let stepIndex in patData){\r\n      newSequence[parseInt(stepIndex)+steps]=patData[stepIndex];\r\n      delete patData[stepIndex];\r\n    }\r\n    for(let stepIndex in newSequence){\r\n      // console.log(\"ASS\",stepIndex);\r\n      patData[stepIndex]=newSequence[stepIndex];\r\n    }\r\n  }\r\n\r\n  var duplicateSequence=function(startingStep,originalEndingStep,multiplyFactor){\r\n    var initialStepSize=originalEndingStep-startingStep;\r\n    if(multiplyFactor>1){\r\n      clearStepRange(originalEndingStep,initialStepSize*(multiplyFactor));\r\n      // displaceStepRange(originalEndingStep);\r\n      //starts in 1 because the 0 is the currently existing one\r\n      for(var duplicationNumber=1; duplicationNumber<multiplyFactor; duplicationNumber++){\r\n        console.log(\"DUPOP\",duplicationNumber);\r\n        for(var step=startingStep; step<originalEndingStep; step++){\r\n          // var testc=0;\r\n          if(patData[step])\r\n          for(var a=0; a<patData[step].length; a++){\r\n            // testc++;\r\n            var targetStep=(initialStepSize*duplicationNumber)+step;\r\n            // console.log(duplicationNumber,step,testc,targetStep);\r\n            // TODO: in many places I create these sequencer memory events, they should be\r\n            //instances of the same class, to avoid easter egg bugs\r\n            if(!patData[targetStep]) patData[targetStep]=[];\r\n            patData[targetStep].push(new EventPattern({\r\n              on:new EventMessage(patData[step][a].on),\r\n              off:new EventMessage(patData[step][a].off),\r\n              stepLength:patData[step][a].stepLength,\r\n            }));\r\n          }\r\n        }\r\n      }\r\n    }else{\r\n      clearStepRange(originalEndingStep*multiplyFactor,originalEndingStep);\r\n    }\r\n  }\r\n\r\n  // var clockIncremental=false;\r\n  this.stepAbsolute=function(s){\r\n    // clockIncremental=false;\r\n    // console.log(\"absolute\"+microStep.value);\r\n    substep.value=s%stepDivide.value;\r\n    substep.value+=loopDisplace.value;\r\n    loopDisplace.value=0;\r\n    currentStep.value=Math.floor(s/stepDivide.value);\r\n    if(currentStep.value>=loopLength.value) currentStep.value%=loopLength.value;\r\n    if(currentStep.value<0) currentStep.value%=loopLength.value;\r\n    // if(substep.value==0)\r\n    // step(s);\r\n    // console.log(\"memema\");\r\n    // console.log(\"aa\",currentStep.value,loopLength.value);\r\n    microStep.value=0;\r\n  }\r\n  this.restart=function(s){\r\n    if(!s) var s=0;\r\n    loopDisplace.value=0;\r\n    currentStep.value=s;\r\n    if(currentStep.value>=loopLength.value) currentStep.value%=loopLength.value;\r\n    if(currentStep.value<0) currentStep.value%=loopLength.value;\r\n    if(substep.value==0)\r\n    step(s);\r\n    microStep.value=0;\r\n  }\r\n  // this.stepIncremental=function(s){\r\n  //   // clockIncremental=true;\r\n  //   substep.value+=loopDisplace.value;\r\n  //   loopDisplace.value=0;\r\n  //   microStep.value=0;\r\n  // }\r\n  function ramp(t,range){\r\n    if(t>0){\r\n      return t%range-1;\r\n    }else{\r\n      return range-Math.abs(t%range)-1;\r\n    }\r\n  }\r\n  this.stepMicro=function(base,number){\r\n    microStepDivide.value=base;\r\n    if(stepDivide.value<1){\r\n      microStepDivide.value*=stepDivide.value;\r\n    }\r\n    microStep.value=ramp(number-self.microStepDisplace.value,microStepDivide.value);\r\n    if(microStep.value%microStepDivide.value==0){\r\n      if(self.playing.value){\r\n        substep.value++;\r\n        currentStep.value+=loopDisplace.value;\r\n        loopDisplace.value=0;\r\n        if(substep.value>=stepDivide.value){\r\n          // console.log(stepDivide);\r\n          step(currentStep.value);\r\n          currentStep.value++;\r\n          // console.log(\"mememe\");\r\n          substep.value=substep.value%stepDivide.value;\r\n          if(currentStep.value>=loopLength.value) currentStep.value%=loopLength.value;\r\n          if(currentStep.value<0) currentStep.value%=Math.abs(loopLength.value);\r\n        }\r\n      }else{\r\n        sequencerModule.noteLenManager.step();\r\n      }\r\n    }\r\n  }\r\n\r\n  function step(evt){\r\n    sequencerModule.noteLenManager.step();\r\n    if(!sequencerModule.mute)\r\n      if(getBoolean(currentStep.value)){\r\n        for(var stepData of patData[currentStep.value]){\r\n          sequencerModule.output(stepData.on);\r\n          sequencerModule.noteLenManager.noteStarted(stepData);\r\n        }\r\n      }\r\n      sequencerModule.onPatchStep();\r\n  }\r\n  this.store=store;\r\n  this.storeNoDup=storeNoDup;\r\n  this.clearStepNewest=clearStepNewest;\r\n  this.clearStepOldest=clearStepOldest;\r\n  this.clearStep=clearStep;\r\n  this.clearStepByFilter=clearStepByFilter;\r\n  this.getBoolean=getBoolean;\r\n  this.sequenceBounds=sequenceBounds;\r\n  // this.eachFold=eachFold;\r\n  // this.getThroughfoldBoolean=getThroughfoldBoolean;\r\n  this.clearStepRange=clearStepRange;\r\n  this.duplicateSequence=duplicateSequence;\r\n  this.offsetSequence=offsetSequence;\r\n  // this.getBitmapx16=getBitmapx16;\r\n  this.step=step;\r\n})(); };\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/sequencerGuts/PatchMem.js?");

/***/ }),

/***/ "./src/modules/Sequencer/sequencerGuts/index.js":
/*!******************************************************!*\
  !*** ./src/modules/Sequencer/sequencerGuts/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//require all the guts\r\n//programmatic:\r\n// var normalizedPath = require(\"path\").join(__dirname, \"\");\r\n\r\n// require(\"fs\").readdirSync(normalizedPath).forEach(function(file) {\r\n//   if(file!=\"index.js\"){\r\n//     // console.log(\"req\"+file);\r\n//     module.exports[file.split(\".\")[0]]=require(\"./\" + file);\r\n//   }\r\n// });\r\n//transpilable:\r\nmodule.exports={\r\n  NoteLengthner:__webpack_require__(/*! ./NoteLengthner.js */ \"./src/modules/Sequencer/sequencerGuts/NoteLengthner.js\"),\r\n  NoteLenManager:__webpack_require__(/*! ./NoteLenManager.js */ \"./src/modules/Sequencer/sequencerGuts/NoteLenManager.js\"),\r\n  PatchMem:__webpack_require__(/*! ./PatchMem.js */ \"./src/modules/Sequencer/sequencerGuts/PatchMem.js\"),\r\n  record:__webpack_require__(/*! ./record.js */ \"./src/modules/Sequencer/sequencerGuts/record.js\"),\r\n}\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/sequencerGuts/index.js?");

/***/ }),

/***/ "./src/modules/Sequencer/sequencerGuts/record.js":
/*!*******************************************************!*\
  !*** ./src/modules/Sequencer/sequencerGuts/record.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var NoteLengthner=__webpack_require__(/*! ./NoteLengthner.js */ \"./src/modules/Sequencer/sequencerGuts/NoteLengthner.js\");\r\nvar EventMessage=__webpack_require__(/*! ../../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar EventPattern=__webpack_require__(/*! ../EventPattern.js */ \"./src/modules/Sequencer/EventPattern.js\");\r\n\r\nmodule.exports=function(controlledModule){\r\n  var noteLengthner=new NoteLengthner(controlledModule);\r\n  var recorderDifferenciatorList={};\r\n  var currentStep=controlledModule.currentStep;\r\n  this.recordSingularEvent=function(eventMessage){\r\n\r\n    var nodup=controlledModule.storeNoDup(currentStep.value,new EventPattern().fromEventMessage(eventMessage));\r\n    //console.log(nodup);\r\n    // console.log(\"st\");\r\n  }\r\n  this.recordNoteStart=function(differenciator,eventOn){\r\n    if(eventOn){\r\n\r\n      eventOn.microDelayFrames=192*controlledModule.microStep.value/controlledModule.microStepDivide;\r\n\r\n      var newStepEvent=new EventPattern().fromEventMessage(eventOn);\r\n      lastRecordedNote=newStepEvent;\r\n      recorderDifferenciatorList[differenciator]=currentStep.value;\r\n      //recording is destructively quantized. here we apply a filter that forgives early notes\r\n      if(controlledModule.microStep.value<(controlledModule.lastMicroStepBase/2))recorderDifferenciatorList[differenciator]--;\r\n      noteLengthner.startAdding(differenciator,newStepEvent);\r\n    }\r\n    controlledModule.handle('noteOnRecorded',{eventMessage:eventOn,eventPattern:newStepEvent});\r\n  }\r\n  this.recordNoteEnd=function(differenciator){\r\n    // console.log(\"noteEnd\",differenciator);\r\n    noteLengthner.finishAdding(differenciator,function(subdiff,sequencerEvent,nicCount){\r\n      // console.log(\"rec\",recorderDifferenciatorList[differenciator],sequencerEvent);\r\n      controlledModule.storeNoDup(recorderDifferenciatorList[differenciator],sequencerEvent);\r\n    });\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://environment/./src/modules/Sequencer/sequencerGuts/record.js?");

/***/ }),

/***/ "./src/modules/moduleUtils/Note.js":
/*!*****************************************!*\
  !*** ./src/modules/moduleUtils/Note.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage */ \"./src/datatypes/EventMessage.js\");\r\nvar headers = EventMessage.headers;\r\nvar Note = function (props) {\r\n    var self=this;\r\n    if(!props) props={};\r\n    if (props.value) {\r\n        props.value[0] = headers.triggerOn;\r\n    }else{\r\n        props.value=[headers.triggerOn,-1,-1,-1]\r\n    }\r\n\r\n    EventMessage.call(this, props);\r\n    this.noteOff = function () {\r\n        self.value[0] = headers.triggerOff;\r\n        var ret = self.clone();\r\n        return ret;\r\n    }\r\n    this.noteOn = function () {\r\n        self.value[0] = headers.triggerOn;\r\n        var ret = self.clone();\r\n        return ret;\r\n    }\r\n    this.note = function (to) {\r\n        if (to !== undefined) self.value[1] = to;\r\n        return self.value[1];\r\n    }\r\n    this.timbre = function (to) {\r\n        if (to !== undefined) self.value[2] = to;\r\n        return self.value[2];\r\n    }\r\n    this.velo = function (to) {\r\n        if (to !== undefined) self.value[3] = to;\r\n        return self.value[3];\r\n    }\r\n}\r\nmodule.exports=Note;\n\n//# sourceURL=webpack://environment/./src/modules/moduleUtils/Note.js?");

/***/ }),

/***/ "./src/modules/moduleUtils/NoteOnTracker.js":
/*!**************************************************!*\
  !*** ./src/modules/moduleUtils/NoteOnTracker.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\nvar Note = __webpack_require__(/*! ./Note */ \"./src/modules/moduleUtils/Note.js\");\r\nvar headers = EventMessage.headers;\r\n\r\nvar NoteOnTracker = function (controlledModule) {\r\n  if(!controlledModule) controlledModule={name:\"unknown\"}\r\n  var self = this;\r\n  var checkMem = 30;\r\n  var trackedNotes = [];\r\n  function transformToNoteOff(identifier) {\r\n    trackedNotes[identifier].value[0] = headers.triggerOff;\r\n  }\r\n  this.checkMem = function (val = 16) {\r\n    checkMem = val;\r\n  }\r\n  function makeUpIdentifier(evMes) {\r\n    return [evMes.value[1], evMes.value[0]];\r\n  }\r\n\r\n  this.add = function (noteOn, identifier = false) {\r\n    if (noteOn.value[0] != headers.triggerOn)\r\n      console.warn(\"noteonTracker: tracking notes that are not a noteon is likely to give you headaches\",\r\n        noteOn,\r\n        controlledModule.name);\r\n    if (identifier === false) identifier = makeUpIdentifier(noteOn);\r\n    trackedNotes[identifier] = noteOn.clone();\r\n    transformToNoteOff(identifier);\r\n    if (checkMem) {\r\n      let amount = self.list().length;\r\n      if (amount > checkMem) console.log(controlledModule.name + \"'s trackedNotes length \" + amount);\r\n    }\r\n    return identifier;\r\n  }\r\n  var filterFunction = false;\r\n\r\n  this.ifNoteOff = function (identifier, callback) {\r\n    if (trackedNotes[identifier]) {\r\n      callback(trackedNotes[identifier]);\r\n      delete trackedNotes[identifier];\r\n    }\r\n  }\r\n  this.noteOff = function (identifier) {\r\n    let ret = trackedNotes[identifier];\r\n    delete trackedNotes[identifier];\r\n    return ret;\r\n  }\r\n  this.noteOffPeek = function (identifier) {\r\n    return trackedNotes[identifier];\r\n  }\r\n\r\n  this.eachTrackedNote = this.each = function (callback) {\r\n    if (typeof callback !== \"function\") { console.error(\"callback is not a function\"); return; }\r\n    for (identifier in trackedNotes) {\r\n      callback(trackedNotes[identifier], identifier);\r\n    }\r\n  };\r\n  this.list = function () {\r\n    return Object.keys(trackedNotes);\r\n  }\r\n  this.empty = function (cb) {\r\n    // console.log(\"EMPT\",trackedNotes.length);\r\n    var ret = trackedNotes;\r\n    if (typeof cb == \"function\") {\r\n      for (var a in trackedNotes) {\r\n        cb(trackedNotes[a], a);\r\n      }\r\n    }\r\n    trackedNotes = [];\r\n    return trackedNotes;\r\n  }\r\n}\r\nmodule.exports = NoteOnTracker;\n\n//# sourceURL=webpack://environment/./src/modules/moduleUtils/NoteOnTracker.js?");

/***/ }),

/***/ "./src/modules/x16utils/BlankConfigurator.js":
/*!***************************************************!*\
  !*** ./src/modules/x16utils/BlankConfigurator.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar MyInteractorBase=__webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n/**\r\nuser interface pattern that allows to tweak parameters\r\n@param {interactor} parentInteractor the module interactor that posesses this\r\n@param {Object} properties {values:{@link array}(deep copy),name:{@link String},varNames:{@link Array} (shallow copy)},\r\n@param {Object} vars the tree of variables that one wants to assign to this controller. The tree is shallow-copied, and each var value is not in the var directly, but in the var.value, otherwise the reference would be lost (same way as in tween.js). This also allows to attach additional parameters such as \"onValueChange\" function and the so\r\n*/\r\nvar BlankConfigurator=function(parentInteractor,properties){\r\n\r\n  MyInteractorBase.call(this);\r\n\r\n  this.vars={};\r\n  var varNames=[];\r\n\r\n  this.name=\"\";\r\n  var thisInteractor=this;\r\n\r\n\r\n  this.addVars=function(nvars){\r\n    var defaultIntChangeFunction=function(thisVar,delta){\r\n      thisVar.value+=delta;\r\n\r\n      if(thisVar.max!==undefined){\r\n        if(thisVar.min==undefined) thisVar.min=0;\r\n        if(thisVar.value>thisVar.max) thisVar.value=thisVar.min;\r\n      }\r\n      if(thisVar.min!==undefined){\r\n        if(thisVar.max==undefined) thisVar.max=1;\r\n        if(thisVar.value<thisVar.min) thisVar.value=thisVar.max;\r\n      }\r\n\r\n\r\n    }\r\n    var defaultBoolChangeFunction=function(thisVar,delta){\r\n      if(thisVar.value==true){\r\n        thisVar.value=false\r\n      }else{\r\n        thisVar.value=true\r\n      }\r\n    }\r\n    var defaultSelectFunction=function(thisVar){\r\n    }\r\n    var defaultDisengageFunction=function(thisVar){\r\n    }\r\n    var defaultNameFunction=function(thisVar){\r\n      if(thisVar.valueNames) return thisVar.valueNames[thisVar.value]+\"\";\r\n      return \"to \"+thisVar.value;\r\n    }\r\n    for(var a in nvars){\r\n      if(nvars[a]==undefined) throw `error while adding vars to a BlankConfigurator: vars[${a}] is undefined`;\r\n\r\n      switch (typeof nvars[a].value) {\r\n        case \"boolean\":\r\n            if(nvars[a].changeFunction===undefined) nvars[a].changeFunction=defaultBoolChangeFunction;\r\n          break;\r\n        default:\r\n          if(nvars[a].changeFunction===undefined) nvars[a].changeFunction=defaultIntChangeFunction;\r\n\r\n      }\r\n\r\n      if(nvars[a].disengageFunction===undefined) nvars[a].disengageFunction=defaultDisengageFunction;\r\n      if(nvars[a].selectFunction===undefined) nvars[a].selectFunction=defaultSelectFunction;\r\n      if(nvars[a].nameFunction===undefined) nvars[a].nameFunction=defaultNameFunction;\r\n      thisInteractor.vars[a]=nvars[a];\r\n    }\r\n    watchvarNames();\r\n  }\r\n  if(properties.variables){\r\n    thisInteractor.addVars(properties.variables);\r\n  }if(properties.vars){\r\n    thisInteractor.addVars(properties.vars);\r\n  }\r\n  function watchvarNames(){\r\n    varNames=Object.keys(thisInteractor.vars);\r\n  }\r\n  if(properties.name) this.name=properties.name;\r\n  var selectedVarNumber={};\r\n\r\n  var engagedHardwares=new Set();\r\n\r\n  if(properties.values){\r\n    this.vars=properties.values;\r\n  }\r\n\r\n  // var valueChanged=function(){\r\n  //   //value can change while not engaged\r\n  //   for (let hardware of engagedHardwares) {\r\n  //     updateLeds(hardware);\r\n  //   }\r\n  // }\r\n  function getSelectedVar(hardware){\r\n    if(!selectedVarNumber[hardware.instanceNumber]) selectedVarNumber[hardware.instanceNumber]=0;\r\n    return thisInteractor.vars[varNames[selectedVarNumber[hardware.instanceNumber]]]\r\n  }\r\n  function passiveUpdateHardware(){\r\n    for(var hardware of engagedHardwares){\r\n      updateScreen(hardware);\r\n      updateLeds(hardware);\r\n    }\r\n  }\r\n  var updateLeds=function(hardware){\r\n    var selectBmp=1<<selectedVarNumber[hardware.instanceNumber];\r\n    var eventLengthBmp=~(0xFFFF<<varNames.length);\r\n    hardware.draw([\r\n      selectBmp|eventLengthBmp,\r\n      selectBmp,\r\n      selectBmp|eventLengthBmp\r\n    ]);\r\n  }\r\n  function updateScreen(hardware){\r\n    // console.log(thisInteractor.vars);\r\n    var selectedVar=getSelectedVar(hardware);\r\n    hardware.sendScreenA(varNames[selectedVarNumber[hardware.instanceNumber]]);\r\n    hardware.sendScreenB(selectedVar.nameFunction(selectedVar));\r\n  }\r\n  // this.select=function(n,update = true){\r\n  //   selectedVarNumber[hardware.instanceNumber]=n;\r\n  //   if(update)\r\n  //   passiveUpdateHardware();\r\n  // }\r\n  this.matrixButtonPressed=function(event){\r\n    var hardware=event.hardware;\r\n    if(event.data[0]<varNames.length){\r\n      selectedVarNumber[hardware.instanceNumber]=event.data[0];\r\n      var selectedVar=getSelectedVar(hardware);\r\n      selectedVar.selectFunction(selectedVar);\r\n      updateLeds(hardware);\r\n      updateScreen(hardware);\r\n    }\r\n  };\r\n  this.encoderScrolled=function(event){\r\n    var hardware=event.hardware;\r\n    // console.log(\"a\");\r\n    if(varNames.length>selectedVarNumber[hardware.instanceNumber]){\r\n      // console.log(\"b\");\r\n      var thisVar=getSelectedVar(hardware);\r\n      // console.log(thisVar);\r\n      thisVar.changeFunction(thisVar,event.delta,event);\r\n      updateScreen(hardware);\r\n    }\r\n  };\r\n  // this.setCurrentVarValue=function(to){\r\n  //   if(varNames.length>selectedVarNumber[hardware.instanceNumber]){\r\n  //     var thisVar=getSelectedVar(hardware);\r\n  //     var delta=thisVar.value-to;\r\n  //     thisVar.changeFunction(thisVar,delta);\r\n  //     passiveUpdateHardware();\r\n  //   }\r\n  // }\r\n  this.encoderPressed=function(event){\r\n    var hardware=event.hardware;\r\n  };\r\n  this.encoderReleased=function(event){\r\n    var hardware=event.hardware;\r\n  };\r\n  this.engage=function(event){\r\n    var hardware=event.hardware;\r\n    engagedHardwares.add(hardware);\r\n    if(properties.engageFunction){\r\n      properties.engageFunction(thisInteractor);\r\n    }\r\n    var svar=getSelectedVar(hardware)\r\n    svar.selectFunction(svar);\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  };\r\n  this.disengage=function(event){\r\n    var hardware=event.hardware;\r\n    var svar=getSelectedVar(hardware);\r\n    if(svar)\r\n    svar.disengageFunction(svar);\r\n    if(properties.disengageFunction){\r\n      properties.disengageFunction(thisInteractor);\r\n    }\r\n    var hardware=event.hardware;\r\n    engagedHardwares.delete(hardware);\r\n  }\r\n};\r\nmodule.exports=BlankConfigurator;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/x16utils/BlankConfigurator.js?");

/***/ }),

/***/ "./src/modules/x16utils/EventConfigurator.js":
/*!***************************************************!*\
  !*** ./src/modules/x16utils/EventConfigurator.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar EventMessage = __webpack_require__(/*! ../../datatypes/EventMessage.js */ \"./src/datatypes/EventMessage.js\");\r\n\r\nvar MyInteractorBase = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n/**\r\nuser interface pattern that allows to tweak a note. A usage example is the event selector of the monoSequencer, the one used to select the note that will be set on the next tap of a matrix button\r\n@param {interactor} parentInteractor the module interactor that posesses this EventConfigurator\r\n@param {Object} properties {values:{@link array}(deep copy),name:{@link String},valueNames:{@link Array} (shallow copy)}\r\n*/\r\nvar EventConfigurator = function (parentInteractor, properties = {}) {\r\n  MyInteractorBase.call(this);\r\n  this.name = \"EventMessage\";\r\n  var self = this;\r\n  var thisInteractor = this;\r\n  if (properties.name) this.name = properties.name;\r\n  var selectedValueNumber = 1;\r\n  var presetMode = 1;\r\n  var presets = [\r\n    {\r\n      name: \"manual\",\r\n      value: [-1, -1, -1, -1],\r\n      settings: [0, 1, 2, 3],\r\n      names: [\"head\", \"num 1\", \"num 2\", \"num 3\"]\r\n    }, {\r\n      name: \"note trigger\",\r\n      value: [1, 0, -1, -1],\r\n      settings: [1, 2, 3],\r\n      names: ['note', 'timbre', 'velocity']\r\n    }, {\r\n      name: \"clock\",\r\n      value: [0, 1, 1, -1],\r\n      settings: [1, 2],\r\n      names: ['cycle', 'micro step']\r\n    }, {\r\n      name: \"preset change\",\r\n      value: [3, 0, 0, -1],\r\n      settings: [1],\r\n      names: ['preset no']\r\n    }, {\r\n      name: \"rate change\",\r\n      value: [4, 12, 12, -1],\r\n      settings: [1, 2],\r\n      names: ['divided by', 'number']\r\n    },\r\n  ]\r\n  var extraValueNames = [];\r\n  var extraVariables = [];\r\n\r\n  var engagedHardwares = new Set();\r\n  /**\r\n  the interface is based on an eventMessage, but the input and output is an eventPattern\r\n  */\r\n  var baseEvent;\r\n  function applyProps() {\r\n    if (!properties.baseEvent) {\r\n      // console.log(\"nono\");\r\n      baseEvent = self.baseEvent = new EventMessage({ value: [0, 0, 0, 0] });\r\n      setPreset(0);\r\n    } else if (properties.baseEvent.isEventMessage) {\r\n      // console.log(\"NM\");\r\n      baseEvent = self.baseEvent = properties.baseEvent;\r\n    } else if (!isNaN(properties.preset)) {\r\n      baseEvent = self.baseEvent = new EventMessage();\r\n      setPreset(properties.baseEvent);\r\n    } else {\r\n      // console.log(\"nono\");\r\n      baseEvent = self.baseEvent = new EventMessage({ value: [0, 0, 0, 0] });\r\n      setPreset(0);\r\n    }\r\n    if (properties.values) {\r\n      for (var a in properties.values) {\r\n        baseEvent.value[a] = properties.values[a];\r\n      }\r\n    }\r\n  }\r\n  function setPreset(presetNumber) {\r\n    if (!presets[presetNumber]) {\r\n      console.warn(\"event configurator: preset \" + presetNumber + \" doesn't exist\");\r\n      return false;\r\n    }\r\n    if (presets[presetNumber].settings.length <= selectedValueNumber) {\r\n      selectedValueNumber = 0;\r\n    }\r\n    //for every value that is settable in the preset, set it to the baseEvent value\r\n    for (var setnum of presets[presetNumber].settings) {\r\n      presets[presetNumber].value[setnum] = baseEvent.value[setnum];\r\n    }\r\n    for (var a in presets[presetNumber].value) {\r\n      baseEvent.value[a] = presets[presetNumber].value[a];\r\n    }\r\n    presetMode = presetNumber;\r\n  }\r\n  this.addextraVariables = function (valuesList) {\r\n    for (var a in valuesList) {\r\n      extraValueNames.push(a);\r\n      extraVariables.push(valuesList[a]);\r\n    }\r\n  }\r\n  if (properties.extraVariables) this.addextraVariables(properties.extraVariables);\r\n  var valueChanged = function () {\r\n    //value can change while not engaged\r\n    for (let hardware of engagedHardwares) {\r\n      updateLeds(hardware);\r\n    }\r\n  }\r\n\r\n  var passiveUpdateScreen = function () {\r\n    //value can change while not engaged\r\n    for (let hardware of engagedHardwares) {\r\n      updateScreen(hardware);\r\n    }\r\n  }\r\n  this.passiveUpdateScreen = passiveUpdateScreen;\r\n  var updateLeds = function (hardware) {\r\n    var amountOfVariables = presets[presetMode].settings.length;\r\n\r\n    var eventLengthBmp = ~(0xFFFF << amountOfVariables);\r\n\r\n    // console.log(\"PL\",presets.length);\r\n    var presetsBmp = (0xFFFF << (16 - presets.length));\r\n    var selectedPresetBmp = 0x1 << (16 - presets.length + presetMode);\r\n\r\n    var extraVariablesBmp = (0xF0 & ~(0xF0 << (extraValueNames.length)));\r\n\r\n    var selectBmp = 1 << selectedValueNumber;\r\n\r\n    selectBmp |= selectedPresetBmp;\r\n    hardware.draw([selectBmp | eventLengthBmp, selectBmp | extraVariablesBmp, selectBmp | eventLengthBmp | extraVariablesBmp | presetsBmp]);\r\n  }\r\n  var updateScreen = function (hardware) {\r\n    hardware.sendScreenA(\"\" + presets[presetMode].name);\r\n    if (selectedValueNumber < presets[presetMode].settings.length) {\r\n      var absoluteSelectedValueNumber = presets[presetMode].settings[selectedValueNumber];\r\n\r\n      hardware.sendScreenB(\r\n        presets[presetMode].names[selectedValueNumber]\r\n        + \"=\" + (baseEvent.value[absoluteSelectedValueNumber] === -1 ? \"transparent\" : baseEvent.value[absoluteSelectedValueNumber])\r\n      );\r\n      // console.log(\"Value->settings->\",presets[presetMode].settings[selectedValueNumber] );\r\n    } else {\r\n      var selectedExtraValue = selectedValueNumber - baseEvent.value.length;\r\n      if (extraValueNames[selectedExtraValue]) {\r\n        hardware.sendScreenB(\r\n          extraValueNames[selectedExtraValue]\r\n          + \"=\" + extraVariables[selectedExtraValue].value\r\n        );\r\n      }\r\n\r\n    }\r\n  }\r\n  this.matrixButtonPressed = function (event) {\r\n    var eventResponse = {}\r\n    var hardware = event.hardware;\r\n    if (event.data[0] < 4) {\r\n      //selection of the events variable\r\n      selectedValueNumber = event.data[0];\r\n      // console.log(\"event var select\",presets[presetMode].name);\r\n    } else if (event.data[0] < extraVariables.length + 4) {\r\n      //selection of added vars\r\n      selectedValueNumber = event.data[0];\r\n      console.log(\"extra var select\", presets[presetMode].name);\r\n    } else if (event.data[0] - presets.length > 0) {\r\n      //selection of a preset event\r\n      setPreset(presets.length + (event.data[0] - 16));\r\n      console.log(\"preset select\", presets[presetMode].name);\r\n      eventResponse.presetSelected = true;\r\n    }\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n    return eventResponse;\r\n  };\r\n  this.matrixButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.selectorButtonPressed = function (event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.selectorButtonReleased = function (event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.encoderScrolled = function (event) {\r\n    var hardware = event.hardware;\r\n    var absoluteSelectedValueNumber = presets[presetMode].settings[selectedValueNumber];\r\n    if (baseEvent.value.length > selectedValueNumber) {\r\n      // console.log(\"val:\"+baseEvent.value[selectedValueNumber]);\r\n      baseEvent.value[absoluteSelectedValueNumber] += event.delta;\r\n      if (isNaN(baseEvent.value[absoluteSelectedValueNumber])) baseEvent.value[absoluteSelectedValueNumber] = 0;\r\n      presets[presetMode].value = baseEvent.value;\r\n      console.log(\"->val:\" + baseEvent.value[absoluteSelectedValueNumber], absoluteSelectedValueNumber);\r\n      updateScreen(hardware);\r\n    } else if (extraValueNames.length > selectedValueNumber - baseEvent.value.length) {\r\n      // value += event.delta;\r\n      var thisVar = extraVariables[selectedValueNumber - 4];\r\n      if (thisVar.changeFunction) {\r\n        thisVar.changeFunction(thisVar, event.delta, event);\r\n      } else {\r\n        thisVar.value += event.delta;\r\n      }\r\n      updateScreen(hardware);\r\n    }\r\n    return { currentEvent: baseEvent, selectedValueNumber: absoluteSelectedValueNumber, selectedValueValue: baseEvent.value[absoluteSelectedValueNumber] }\r\n  };\r\n  this.encoderPressed = function (event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.encoderReleased = function (event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.engage = function (event) {\r\n    var hardware = event.hardware;\r\n    engagedHardwares.add(hardware);\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  };\r\n  this.disengage = function (event) {\r\n    var hardware = event.hardware;\r\n    engagedHardwares.delete(hardware);\r\n  }\r\n\r\n  this.Filter = function (criteria) {\r\n    this.criteria = criteria;\r\n    var criteria = this.criteria;\r\n    return function (message) {\r\n      var onMessage = message.on\r\n      var ret = true;\r\n      if (criteria) {\r\n        if (criteria.header)\r\n          ret &= (onMessage.value[0] === baseEvent.value[0]);\r\n        if (criteria.value_a)\r\n          ret &= (onMessage.value[1] === baseEvent.value[1]);\r\n        if (criteria.value_b)\r\n          ret &= (onMessage.value[2] === baseEvent.value[2]);\r\n        if (criteria.value_c)\r\n          ret &= (onMessage.value[3] === baseEvent.value[3]);\r\n      }\r\n      return ret;\r\n    }\r\n  }\r\n\r\n\r\n  this.setFromEventMessage = function (EvMes, hardware) {\r\n    // console.log(\"setFromEventMessage\");\r\n    if (EvMes) {\r\n      baseEvent = new EventMessage(EvMes);\r\n      if (hardware) {\r\n        updateScreen(hardware);\r\n      } else {\r\n        passiveUpdateScreen();\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  this.getEventMessage = function () {\r\n\r\n    // if(!newDest) newDest=options[0].presets[presetMode].names(0);\r\n    var newEvMes = new EventMessage(baseEvent);\r\n    // console.log(\"getEventMessage\",newEvMes);\r\n    return newEvMes;\r\n  }\r\n  applyProps();\r\n};\r\nmodule.exports = EventConfigurator;\r\n\n\n//# sourceURL=webpack://environment/./src/modules/x16utils/EventConfigurator.js?");

/***/ }),

/***/ "./src/modules/x16utils/RecordMenu.js":
/*!********************************************!*\
  !*** ./src/modules/x16utils/RecordMenu.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar MyInteractorBase = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n/**\r\nuser interface pattern that allows to tweak parameters\r\n@param {interactor} parentInteractor the module interactor that posesses this\r\n@param {Object} properties {values:{@link array}(deep copy),name:{@link String},varNames:{@link Array} (shallow copy)},\r\n@param {Object} vars the tree of variables that one wants to assign to this controller. The tree is shallow-copied, and each var value is not in the var directly, but in the var.value, otherwise the reference would be lost (same way as in tween.js). This also allows to attach additional parameters such as \"onValueChange\" function and the so\r\n*/\r\n\r\nvar RecordMenu = function(parentInteractor, properties) {\r\n  if (!properties.environment) throw \"RecordMenu needs you to pass the environment in the properties\";\r\n  if (!properties.controlledModule) throw \"RecordMenu needs you to pass the controlledModule in the properties\";\r\n  var environment = properties.environment;\r\n  var controlledModule = properties.controlledModule;\r\n  var modules = environment.modules.list;\r\n  var recordingOuptutsBitmap = 0;\r\n\r\n  if (properties === undefined) properties = {};\r\n  MyInteractorBase.call(this);\r\n  this.name = \"Rec\";\r\n  var thisInteractor = this;\r\n  if (properties.name) this.name = properties.name;\r\n  var selectedModuleNumber = 0;\r\n  var engagedHardwares = new Set();\r\n\r\n  if (properties.values) {\r\n    this.vars = properties.values;\r\n  }\r\n  // watchvarNames();\r\n\r\n  var limitOptions=function(){\r\n    modules=[];\r\n    for(var tmodule of environment.modules.list){\r\n      if(!tmodule.preventRecord){\r\n        if(tmodule.outputs.has(controlledModule)){\r\n          modules.push(tmodule);\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  var valueChanged = function() {\r\n    //value can change while not engaged\r\n    for (let hardware of engagedHardwares) {\r\n      updateLeds(hardware);\r\n    }\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    var eventLengthBmp = ~(0xFFFF << modules.length);\r\n\r\n    hardware.draw([\r\n      recordingOuptutsBitmap | eventLengthBmp,\r\n      eventLengthBmp ^ recordingOuptutsBitmap,\r\n      eventLengthBmp ^ recordingOuptutsBitmap\r\n    ]);\r\n  }\r\n  var updateScreen = function(hardware) {\r\n    if (modules[selectedModuleNumber]) {\r\n      hardware.sendScreenA(\"Rec dest\");\r\n      hardware.sendScreenB(\">\" + modules[selectedModuleNumber].name);\r\n    }\r\n  }\r\n  this.matrixButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    if (event.data[0] < modules.length) {\r\n      selectedModuleNumber = event.data[0];\r\n      if (controlledModule.toggleRecordOutput(modules[selectedModuleNumber])) {\r\n        recordingOuptutsBitmap |= 1 << selectedModuleNumber;\r\n      } else {\r\n        recordingOuptutsBitmap &= ~(1 << selectedModuleNumber);\r\n      }\r\n      updateLeds(hardware);\r\n      updateScreen(hardware);\r\n    }\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    // var hardware=event.hardware;\r\n    // if(thisInteractor.vars.length>selectedModuleNumber){\r\n    //   thisInteractor.vars[selectedModuleNumber].value+=event.data[1];\r\n    //   updateScreen(hardware);\r\n    // }\r\n  };\r\n  this.encoderPressed = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.encoderReleased = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.engage = function(event) {\r\n    if(!environment.vars.advancedRecording) limitOptions();\r\n    var hardware = event.hardware;\r\n    engagedHardwares.add(hardware);\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    var hardware = event.hardware;\r\n    engagedHardwares.delete(hardware);\r\n  }\r\n};\r\nmodule.exports = RecordMenu;\n\n//# sourceURL=webpack://environment/./src/modules/x16utils/RecordMenu.js?");

/***/ }),

/***/ "./src/modules/x28utils/RecordMenu.js":
/*!********************************************!*\
  !*** ./src/modules/x28utils/RecordMenu.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar MyInteractorBase = __webpack_require__(/*! ../../interaction/x16basic/interactorBase.js */ \"./src/interaction/x16basic/interactorBase.js\");\r\n/**\r\nuser interface pattern that allows to tweak parameters\r\n@param {interactor} parentInteractor the module interactor that posesses this\r\n@param {Object} properties {values:{@link array}(deep copy),name:{@link String},varNames:{@link Array} (shallow copy)},\r\n@param {Object} vars the tree of variables that one wants to assign to this controller. The tree is shallow-copied, and each var value is not in the var directly, but in the var.value, otherwise the reference would be lost (same way as in tween.js). This also allows to attach additional parameters such as \"onValueChange\" function and the so\r\n*/\r\n\r\nvar RecordMenu = function(parentInteractor, properties) {\r\n  var self=this;\r\n  if (!properties.environment) throw \"RecordMenu needs you to pass the environment in the properties\";\r\n  if (!properties.controlledModule) throw \"RecordMenu needs you to pass the controlledModule in the properties\";\r\n  var environment = properties.environment;\r\n  var controlledModule = properties.controlledModule;\r\n  var modules = environment.modules.list;\r\n  var recordingOuptutsBitmap = 0;\r\n\r\n  if (properties === undefined) properties = {};\r\n  MyInteractorBase.call(this);\r\n  this.name = \"Rec\";\r\n  var thisInteractor = this;\r\n  if (properties.name) this.name = properties.name;\r\n  var selectedModuleNumber = 0;\r\n  var engagedHardwares = new Set();\r\n  var windowEngagedHardwares = new Set();\r\n  if (properties.values) {\r\n    this.vars = properties.values;\r\n  }\r\n  // watchvarNames();\r\n\r\n  var limitOptions=function(){\r\n    modules=[];\r\n    for(var tmodule of environment.modules.list){\r\n      if(!tmodule.preventRecord){\r\n        if(tmodule.outputs.has(controlledModule)){\r\n          modules.push(tmodule);\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n\r\n  var valueChanged = function() {\r\n    //value can change while not engaged\r\n    for (let hardware of engagedHardwares) {\r\n      updateLeds(hardware);\r\n    }\r\n    for (let hardware of windowEngagedHardwares) {\r\n      updateWindowLeds(hardware);\r\n    }\r\n  }\r\n  var updateLeds = function(hardware) {\r\n    var eventLengthBmp = ~(0xFFFF << modules.length);\r\n\r\n    hardware.draw([\r\n      recordingOuptutsBitmap | eventLengthBmp,\r\n      eventLengthBmp ^ recordingOuptutsBitmap,\r\n      eventLengthBmp ^ recordingOuptutsBitmap\r\n    ]);\r\n    //\r\n    // hardware.drawLowerSelectorButtonsColor(eventLengthBmp,[0,32,32],false);\r\n    // hardware.drawLowerSelectorButtonsColor(recordingOuptutsBitmap,[255,0,0]);\r\n  }\r\n\r\n  var updateWindowLeds = function(hardware) {\r\n    var eventLengthBmp = ~(0xFFFF << modules.length);\r\n\r\n    // hardware.draw([\r\n    //   recordingOuptutsBitmap | eventLengthBmp,\r\n    //   eventLengthBmp ^ recordingOuptutsBitmap,\r\n    //   eventLengthBmp ^ recordingOuptutsBitmap\r\n    // ]);\r\n\r\n    hardware.drawLowerSelectorButtonsColor(eventLengthBmp,[0,32,32],false);\r\n    hardware.drawLowerSelectorButtonsColor(recordingOuptutsBitmap,[255,0,0]);\r\n  }\r\n\r\n  var updateScreen = function(hardware) {\r\n    if (modules[selectedModuleNumber]) {\r\n      hardware.sendScreenA(\"Rec dest\");\r\n      hardware.sendScreenB(\">\" + modules[selectedModuleNumber].name);\r\n    }\r\n  }\r\n  this.windowButtonPressed=function(button){\r\n    if (button < modules.length) {\r\n      selectedModuleNumber = button;\r\n      if (controlledModule.toggleRecordOutput(modules[selectedModuleNumber])) {\r\n        recordingOuptutsBitmap |= 1 << selectedModuleNumber;\r\n      } else {\r\n        recordingOuptutsBitmap &= ~(1 << selectedModuleNumber);\r\n      }\r\n      valueChanged();\r\n    }\r\n  }\r\n  this.matrixButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n    self.windowButtonPressed(event.button);\r\n\r\n    // updateLeds(hardware);//it happens because valueChanged()\r\n    updateScreen(hardware);\r\n  };\r\n  this.matrixButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.selectorButtonPressed = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.selectorButtonReleased = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.encoderScrolled = function(event) {\r\n    // var hardware=event.hardware;\r\n    // if(thisInteractor.vars.length>selectedModuleNumber){\r\n    //   thisInteractor.vars[selectedModuleNumber].value+=event.data[1];\r\n    //   updateScreen(hardware);\r\n    // }\r\n  };\r\n  this.encoderPressed = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.encoderReleased = function(event) {\r\n    var hardware = event.hardware;\r\n  };\r\n  this.redraw = function(hardware){\r\n    updateLeds(hardware);\r\n  }\r\n\r\n  this.autoEngageWindow=function(){\r\n    var _pief=parentInteractor.engage;\r\n    var _pidf=parentInteractor.disengage;\r\n    parentInteractor.engage=function(evt){\r\n      // console.log(\"AUTOENG\");\r\n      self.engageWindow(evt);\r\n      _pief(evt);\r\n    }\r\n    parentInteractor.disengage=function(evt){\r\n      self.disengageWindow(evt);\r\n      _pidf(evt);\r\n    }\r\n  }\r\n  this.engageWindow = function(event){\r\n    var hardware = event.hardware;\r\n    updateWindowLeds(hardware);\r\n    windowEngagedHardwares.add(hardware);\r\n  }\r\n  this.disengageWindow = function(event) {\r\n    var hardware = event.hardware;\r\n    windowEngagedHardwares.delete(hardware);\r\n  }\r\n\r\n  this.engage = function(event) {\r\n    if(!environment.vars.advancedRecording) limitOptions();\r\n    //\r\n    if(event.button>=8){\r\n      self.windowButtonPressed(event.button-8);\r\n      // updateLeds(event.hardware);\r\n      // updateScreen(event.hardware);\r\n    }\r\n\r\n    var hardware = event.hardware;\r\n    engagedHardwares.add(hardware);\r\n    updateLeds(hardware);\r\n    updateScreen(hardware);\r\n  };\r\n  this.disengage = function(event) {\r\n    var hardware = event.hardware;\r\n    engagedHardwares.delete(hardware);\r\n  }\r\n  return this;\r\n};\r\nmodule.exports = RecordMenu;\n\n//# sourceURL=webpack://environment/./src/modules/x28utils/RecordMenu.js?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack://environment/external_%22fs%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack://environment/external_%22path%22?");

/***/ })

/******/ });